(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperty = $Object.defineProperty;
  var $freeze = $Object.freeze;
  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
  var $keys = $Object.keys;
  var $toString = $Object.prototype.toString;
  var $preventExtensions = Object.preventExtensions;
  var $seal = Object.seal;
  var $isExtensible = Object.isExtensible;
  var $apply = Function.prototype.call.bind(Function.prototype.apply);
  function $bind(operand, thisArg, args) {
    var argArray = [thisArg];
    for (var i = 0; i < args.length; i++) {
      argArray[i + 1] = args[i];
    }
    var func = $apply(Function.prototype.bind, operand, argArray);
    return func;
  }
  function $construct(func, argArray) {
    var object = new ($bind(func, null, argArray));
    return object;
  }
  var counter = 0;
  function newUniqueString() {
    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
  }
  var privateNames = $create(null);
  function isPrivateName(s) {
    return privateNames[s];
  }
  function createPrivateName() {
    var s = newUniqueString();
    privateNames[s] = true;
    return s;
  }
  var CONTINUATION_TYPE = Object.create(null);
  function createContinuation(operand, thisArg, argsArray) {
    return [CONTINUATION_TYPE, operand, thisArg, argsArray];
  }
  function isContinuation(object) {
    return object && object[0] === CONTINUATION_TYPE;
  }
  var isTailRecursiveName = null;
  function setupProperTailCalls() {
    isTailRecursiveName = createPrivateName();
    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {
      var result = tailCall(function(thisArg) {
        var argArray = [];
        for (var i = 1; i < arguments.length; ++i) {
          argArray[i - 1] = arguments[i];
        }
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {
      var result = tailCall(function(thisArg, argArray) {
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
  }
  function initTailRecursiveFunction(func) {
    if (isTailRecursiveName === null) {
      setupProperTailCalls();
    }
    func[isTailRecursiveName] = true;
    return func;
  }
  function isTailRecursive(func) {
    return !!func[isTailRecursiveName];
  }
  function tailCall(func, thisArg, argArray) {
    var continuation = argArray[0];
    if (isContinuation(continuation)) {
      continuation = $apply(func, thisArg, continuation[3]);
      return continuation;
    }
    continuation = createContinuation(func, thisArg, argArray);
    while (true) {
      if (isTailRecursive(func)) {
        continuation = $apply(func, continuation[2], [continuation]);
      } else {
        continuation = $apply(func, continuation[2], continuation[3]);
      }
      if (!isContinuation(continuation)) {
        return continuation;
      }
      func = continuation[1];
    }
  }
  function construct() {
    var object;
    if (isTailRecursive(this)) {
      object = $construct(this, [createContinuation(null, null, arguments)]);
    } else {
      object = $construct(this, arguments);
    }
    return object;
  }
  var $traceurRuntime = {
    initTailRecursiveFunction: initTailRecursiveFunction,
    call: tailCall,
    continuation: createContinuation,
    construct: construct
  };
  (function() {
    function nonEnum(value) {
      return {
        configurable: true,
        enumerable: false,
        value: value,
        writable: true
      };
    }
    var method = nonEnum;
    var symbolInternalProperty = newUniqueString();
    var symbolDescriptionProperty = newUniqueString();
    var symbolDataProperty = newUniqueString();
    var symbolValues = $create(null);
    function Symbol(description) {
      var value = new SymbolValue(description);
      if (!(this instanceof Symbol))
        return value;
      throw new TypeError('Symbol cannot be new\'ed');
    }
    $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
    $defineProperty(Symbol.prototype, 'toString', method(function() {
      var symbolValue = this[symbolDataProperty];
      return symbolValue[symbolInternalProperty];
    }));
    $defineProperty(Symbol.prototype, 'valueOf', method(function() {
      var symbolValue = this[symbolDataProperty];
      if (!symbolValue)
        throw TypeError('Conversion from symbol to string');
      return symbolValue[symbolInternalProperty];
    }));
    function SymbolValue(description) {
      var key = newUniqueString();
      $defineProperty(this, symbolDataProperty, {value: this});
      $defineProperty(this, symbolInternalProperty, {value: key});
      $defineProperty(this, symbolDescriptionProperty, {value: description});
      freeze(this);
      symbolValues[key] = this;
    }
    $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
    $defineProperty(SymbolValue.prototype, 'toString', {
      value: Symbol.prototype.toString,
      enumerable: false
    });
    $defineProperty(SymbolValue.prototype, 'valueOf', {
      value: Symbol.prototype.valueOf,
      enumerable: false
    });
    var hashProperty = createPrivateName();
    var hashPropertyDescriptor = {value: undefined};
    var hashObjectProperties = {
      hash: {value: undefined},
      self: {value: undefined}
    };
    var hashCounter = 0;
    function getOwnHashObject(object) {
      var hashObject = object[hashProperty];
      if (hashObject && hashObject.self === object)
        return hashObject;
      if ($isExtensible(object)) {
        hashObjectProperties.hash.value = hashCounter++;
        hashObjectProperties.self.value = object;
        hashPropertyDescriptor.value = $create(null, hashObjectProperties);
        $defineProperty(object, hashProperty, hashPropertyDescriptor);
        return hashPropertyDescriptor.value;
      }
      return undefined;
    }
    function freeze(object) {
      getOwnHashObject(object);
      return $freeze.apply(this, arguments);
    }
    function preventExtensions(object) {
      getOwnHashObject(object);
      return $preventExtensions.apply(this, arguments);
    }
    function seal(object) {
      getOwnHashObject(object);
      return $seal.apply(this, arguments);
    }
    freeze(SymbolValue.prototype);
    function isSymbolString(s) {
      return symbolValues[s] || privateNames[s];
    }
    function removeSymbolKeys(array) {
      var rv = [];
      for (var i = 0; i < array.length; i++) {
        if (!isSymbolString(array[i])) {
          rv.push(array[i]);
        }
      }
      return rv;
    }
    function getOwnPropertyNames(object) {
      return removeSymbolKeys($getOwnPropertyNames(object));
    }
    function keys(object) {
      return removeSymbolKeys($keys(object));
    }
    function getOwnPropertySymbols(object) {
      var rv = [];
      var names = $getOwnPropertyNames(object);
      for (var i = 0; i < names.length; i++) {
        var symbol = symbolValues[names[i]];
        if (symbol) {
          rv.push(symbol);
        }
      }
      return rv;
    }
    function polyfillObject(Object) {
      $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});
      $defineProperty(Object, 'freeze', {value: freeze});
      $defineProperty(Object, 'preventExtensions', {value: preventExtensions});
      $defineProperty(Object, 'seal', {value: seal});
      $defineProperty(Object, 'keys', {value: keys});
    }
    function exportStar(object) {
      for (var i = 1; i < arguments.length; i++) {
        var names = $getOwnPropertyNames(arguments[i]);
        for (var j = 0; j < names.length; j++) {
          var name = names[j];
          if (name === '__esModule' || name === 'default' || isSymbolString(name))
            continue;
          (function(mod, name) {
            $defineProperty(object, name, {
              get: function() {
                return mod[name];
              },
              enumerable: true
            });
          })(arguments[i], names[j]);
        }
      }
      return object;
    }
    function isObject(x) {
      return x != null && (typeof x === 'object' || typeof x === 'function');
    }
    function toObject(x) {
      if (x == null)
        throw $TypeError();
      return $Object(x);
    }
    function checkObjectCoercible(argument) {
      if (argument == null) {
        throw new TypeError('Value cannot be converted to an Object');
      }
      return argument;
    }
    var hasNativeSymbol;
    function polyfillSymbol(global, Symbol) {
      if (!global.Symbol) {
        global.Symbol = Symbol;
        Object.getOwnPropertySymbols = getOwnPropertySymbols;
        hasNativeSymbol = false;
      } else {
        hasNativeSymbol = true;
      }
      if (!global.Symbol.iterator) {
        global.Symbol.iterator = Symbol('Symbol.iterator');
      }
      if (!global.Symbol.observer) {
        global.Symbol.observer = Symbol('Symbol.observer');
      }
    }
    function hasNativeSymbolFunc() {
      return hasNativeSymbol;
    }
    function setupGlobals(global) {
      polyfillSymbol(global, Symbol);
      global.Reflect = global.Reflect || {};
      global.Reflect.global = global.Reflect.global || global;
      polyfillObject(global.Object);
    }
    setupGlobals(global);
    var typeOf = hasNativeSymbol ? function(x) {
      return typeof x;
    } : function(x) {
      return x instanceof SymbolValue ? 'symbol' : typeof x;
    };
    global.$traceurRuntime = {
      call: tailCall,
      checkObjectCoercible: checkObjectCoercible,
      construct: construct,
      continuation: createContinuation,
      createPrivateName: createPrivateName,
      exportStar: exportStar,
      getOwnHashObject: getOwnHashObject,
      getOwnPropertyNames: $getOwnPropertyNames,
      hasNativeSymbol: hasNativeSymbolFunc,
      initTailRecursiveFunction: initTailRecursiveFunction,
      isObject: isObject,
      isPrivateName: isPrivateName,
      isSymbolString: isSymbolString,
      keys: $keys,
      options: {},
      setupGlobals: setupGlobals,
      toObject: toObject,
      typeof: typeOf
    };
  })();
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__3 = $traceurRuntime,
      canonicalizeUrl = $__3.canonicalizeUrl,
      resolveUrl = $__3.resolveUrl,
      isAbsolute = $__3.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  }
  function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  }
  ModuleEvaluationError.prototype = Object.create(Error.prototype);
  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;
  ModuleEvaluationError.prototype.stripError = function(message) {
    return message.replace(/.*Error:/, this.constructor.name + ':');
  };
  ModuleEvaluationError.prototype.stripCause = function(cause) {
    if (!cause)
      return '';
    if (!cause.message)
      return cause + '';
    return this.stripError(cause.message);
  };
  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {
    this.stack += '\n loaded by ' + moduleName;
  };
  ModuleEvaluationError.prototype.stripStack = function(causeStack) {
    var stack = [];
    causeStack.split('\n').some(function(frame) {
      if (/UncoatedModuleInstantiator/.test(frame))
        return true;
      stack.push(frame);
    });
    stack[0] = this.stripError(stack[0]);
    return stack.join('\n');
  };
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  function UncoatedModuleInstantiator(url, func) {
    UncoatedModuleEntry.call(this, url, null);
    this.func = func;
  }
  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);
  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {
    var $__2 = this;
    if (this.value_)
      return this.value_;
    try {
      var relativeRequire;
      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {
        relativeRequire = $traceurRuntime.require.bind(null, this.url);
      }
      return this.value_ = this.func.call(global, relativeRequire);
    } catch (ex) {
      if (ex instanceof ModuleEvaluationError) {
        ex.loadedBy(this.url);
        throw ex;
      }
      if (ex.stack) {
        var lines = this.func.toString().split('\n');
        var evaled = [];
        ex.stack.split('\n').some(function(frame, index) {
          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
            return true;
          var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
          if (m) {
            var line = parseInt(m[2], 10);
            evaled = evaled.concat(beforeLines(lines, line));
            if (index === 1) {
              evaled.push(columnSpacing(m[3]) + '^ ' + $__2.url);
            } else {
              evaled.push(columnSpacing(m[3]) + '^');
            }
            evaled = evaled.concat(afterLines(lines, line));
            evaled.push('= = = = = = = = =');
          } else {
            evaled.push(frame);
          }
        });
        ex.stack = evaled.join('\n');
      }
      throw new ModuleEvaluationError(this.url, ex);
    }
  };
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    });
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {
        return module;
      });
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__2 = arguments;
            var depMap = {};
            deps.forEach(function(dep, index) {
              return depMap[dep] = $__2[index];
            });
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func.call(global), liveModuleSentinel);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  global.System = {
    register: ModuleStore.register.bind(ModuleStore),
    registerModule: ModuleStore.registerModule.bind(ModuleStore),
    get: ModuleStore.get,
    set: ModuleStore.set,
    normalize: ModuleStore.normalize
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
System.registerModule("traceur-runtime@0.0.92/src/runtime/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/async.js";
  if (typeof $traceurRuntime !== 'object') {
    throw new Error('traceur runtime not found.');
  }
  var createPrivateName = $traceurRuntime.createPrivateName;
  var $__12 = Object,
      create = $__12.create,
      defineProperty = $__12.defineProperty;
  var thisName = createPrivateName();
  var argsName = createPrivateName();
  var observeName = createPrivateName();
  function AsyncGeneratorFunction() {}
  function AsyncGeneratorFunctionPrototype() {}
  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;
  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;
  defineProperty(AsyncGeneratorFunctionPrototype, 'constructor', {enumerable: false});
  var AsyncGeneratorContext = function() {
    function AsyncGeneratorContext(observer) {
      var $__2 = this;
      this.decoratedObserver = $traceurRuntime.createDecoratedGenerator(observer, function() {
        $__2.done = true;
      });
      this.done = false;
      this.inReturn = false;
    }
    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {
      throw: function(error) {
        if (!this.inReturn) {
          throw error;
        }
      },
      yield: function(value) {
        if (this.done) {
          this.inReturn = true;
          throw undefined;
        }
        var result;
        try {
          result = this.decoratedObserver.next(value);
        } catch (e) {
          this.done = true;
          throw e;
        }
        if (result === undefined) {
          return;
        }
        if (result.done) {
          this.done = true;
          this.inReturn = true;
          throw undefined;
        }
        return result.value;
      },
      yieldFor: function(observable) {
        var ctx = this;
        return $traceurRuntime.observeForEach(observable[Symbol.observer].bind(observable), function(value) {
          if (ctx.done) {
            this.return();
            return;
          }
          var result;
          try {
            result = ctx.decoratedObserver.next(value);
          } catch (e) {
            ctx.done = true;
            throw e;
          }
          if (result === undefined) {
            return;
          }
          if (result.done) {
            ctx.done = true;
          }
          return result;
        });
      }
    }, {});
  }();
  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {
    var observe = this[observeName];
    var ctx = new AsyncGeneratorContext(observer);
    $traceurRuntime.schedule(function() {
      return observe(ctx);
    }).then(function(value) {
      if (!ctx.done) {
        ctx.decoratedObserver.return(value);
      }
    }).catch(function(error) {
      if (!ctx.done) {
        ctx.decoratedObserver.throw(error);
      }
    });
    return ctx.decoratedObserver;
  };
  defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});
  function initAsyncGeneratorFunction(functionObject) {
    functionObject.prototype = create(AsyncGeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;
    return functionObject;
  }
  function createAsyncGeneratorInstance(observe, functionObject) {
    for (var args = [],
        $__10 = 2; $__10 < arguments.length; $__10++)
      args[$__10 - 2] = arguments[$__10];
    var object = create(functionObject.prototype);
    object[thisName] = this;
    object[argsName] = args;
    object[observeName] = observe;
    return object;
  }
  function observeForEach(observe, next) {
    return new Promise(function(resolve, reject) {
      var generator = observe({
        next: function(value) {
          return next.call(generator, value);
        },
        throw: function(error) {
          reject(error);
        },
        return: function(value) {
          resolve(value);
        }
      });
    });
  }
  function schedule(asyncF) {
    return Promise.resolve().then(asyncF);
  }
  var generator = Symbol();
  var onDone = Symbol();
  var DecoratedGenerator = function() {
    function DecoratedGenerator(_generator, _onDone) {
      this[generator] = _generator;
      this[onDone] = _onDone;
    }
    return ($traceurRuntime.createClass)(DecoratedGenerator, {
      next: function(value) {
        var result = this[generator].next(value);
        if (result !== undefined && result.done) {
          this[onDone].call(this);
        }
        return result;
      },
      throw: function(error) {
        this[onDone].call(this);
        return this[generator].throw(error);
      },
      return: function(value) {
        this[onDone].call(this);
        return this[generator].return(value);
      }
    }, {});
  }();
  function createDecoratedGenerator(generator, onDone) {
    return new DecoratedGenerator(generator, onDone);
  }
  Array.prototype[Symbol.observer] = function(observer) {
    var done = false;
    var decoratedObserver = createDecoratedGenerator(observer, function() {
      return done = true;
    });
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      for (var $__4 = void 0,
          $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        var value = $__4.value;
        {
          decoratedObserver.next(value);
          if (done) {
            return;
          }
        }
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
    decoratedObserver.return();
    return decoratedObserver;
  };
  defineProperty(Array.prototype, Symbol.observer, {enumerable: false});
  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;
  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;
  $traceurRuntime.observeForEach = observeForEach;
  $traceurRuntime.schedule = schedule;
  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/classes.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/classes.js";
  var $Object = Object;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty,
      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols,
      getPrototypeOf = $__1.getPrototypeOf;
  function superDescriptor(homeObject, name) {
    var proto = getPrototypeOf(homeObject);
    do {
      var result = getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      var value = descriptor.value;
      if (value)
        return value;
      if (!descriptor.get)
        return value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  function forEachPropertyKey(object, f) {
    getOwnPropertyNames(object).forEach(f);
    getOwnPropertySymbols(object).forEach(f);
  }
  function getDescriptors(object) {
    var descriptors = {};
    forEachPropertyKey(object, function(key) {
      descriptors[key] = getOwnPropertyDescriptor(object, key);
      descriptors[key].enumerable = false;
    });
    return descriptors;
  }
  var nonEnum = {enumerable: false};
  function makePropertiesNonEnumerable(object) {
    forEachPropertyKey(object, function(key) {
      defineProperty(object, key, nonEnum);
    });
  }
  function createClass(ctor, object, staticObject, superClass) {
    defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = create(getProtoParent(superClass), getDescriptors(object));
    } else {
      makePropertiesNonEnumerable(object);
      ctor.prototype = object;
    }
    defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/destructuring.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/destructuring.js";
  function iteratorToArray(iter) {
    var rv = [];
    var i = 0;
    var tmp;
    while (!(tmp = iter.next()).done) {
      rv[i++] = tmp.value;
    }
    return rv;
  }
  $traceurRuntime.iteratorToArray = iteratorToArray;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/generators.js";
  if (typeof $traceurRuntime !== 'object') {
    throw new Error('traceur runtime not found.');
  }
  var $TypeError = TypeError;
  var createPrivateName = $traceurRuntime.createPrivateName;
  var $__2 = Object,
      create = $__2.create,
      defineProperties = $__2.defineProperties,
      defineProperty = $__2.defineProperty;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  var RETURN_SENTINEL = {};
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.oldReturnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    maybeUncatchable: function() {
      if (this.storedException === RETURN_SENTINEL) {
        throw RETURN_SENTINEL;
      }
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    },
    wrapYieldStar: function(iterator) {
      var ctx = this;
      return {
        next: function(v) {
          return iterator.next(v);
        },
        throw: function(e) {
          var result;
          if (e === RETURN_SENTINEL) {
            if (iterator.return) {
              result = iterator.return(ctx.returnValue);
              if (!result.done) {
                ctx.returnValue = ctx.oldReturnValue;
                return result;
              }
              ctx.returnValue = result.value;
            }
            throw e;
          }
          if (iterator.throw) {
            return iterator.throw(e);
          }
          iterator.return && iterator.return();
          throw $TypeError('Inner iterator does not have a throw method');
        }
      };
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        if (x === RETURN_SENTINEL) {
          return {
            value: ctx.returnValue,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          if (x === RETURN_SENTINEL) {
            return {
              value: ctx.returnValue,
              done: true
            };
          }
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value;
        try {
          value = moveNext(ctx);
        } catch (ex) {
          if (ex === RETURN_SENTINEL) {
            value = ctx;
          } else {
            throw ex;
          }
        }
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateName();
  var moveNextName = createPrivateName();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', v);
    },
    return: function(v) {
      this[ctxName].oldReturnValue = this[ctxName].returnValue;
      this[ctxName].returnValue = v;
      return nextOrThrow(this[ctxName], this[moveNextName], 'throw', RETURN_SENTINEL);
    }
  };
  defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false},
    return: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = create(functionObject.prototype);
    object[ctxName] = ctx;
    object[moveNextName] = moveNext;
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return;
    }
    ctx.state = last.catch !== undefined ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/relativeRequire.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/relativeRequire.js";
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/spread.js";
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[Symbol.iterator] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[Symbol.iterator]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  $traceurRuntime.spread = spread;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/template.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/template.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      freeze = $__1.freeze;
  var slice = Array.prototype.slice;
  var map = Object.create(null);
  function getTemplateObject(raw) {
    var cooked = arguments[1];
    var key = raw.join('${}');
    var templateObject = map[key];
    if (templateObject)
      return templateObject;
    if (!cooked) {
      cooked = slice.call(raw);
    }
    return map[key] = freeze(defineProperty(cooked, 'raw', {value: freeze(raw)}));
  }
  $traceurRuntime.getTemplateObject = getTemplateObject;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/type-assertions.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/type-assertions.js";
  var types = {
    any: {name: 'any'},
    boolean: {name: 'boolean'},
    number: {name: 'number'},
    string: {name: 'string'},
    symbol: {name: 'symbol'},
    void: {name: 'void'}
  };
  var GenericType = function() {
    function GenericType(type, argumentTypes) {
      this.type = type;
      this.argumentTypes = argumentTypes;
    }
    return ($traceurRuntime.createClass)(GenericType, {}, {});
  }();
  var typeRegister = Object.create(null);
  function genericType(type) {
    for (var argumentTypes = [],
        $__2 = 1; $__2 < arguments.length; $__2++)
      argumentTypes[$__2 - 1] = arguments[$__2];
    var typeMap = typeRegister;
    var key = $traceurRuntime.getOwnHashObject(type).hash;
    if (!typeMap[key]) {
      typeMap[key] = Object.create(null);
    }
    typeMap = typeMap[key];
    for (var i = 0; i < argumentTypes.length - 1; i++) {
      key = $traceurRuntime.getOwnHashObject(argumentTypes[i]).hash;
      if (!typeMap[key]) {
        typeMap[key] = Object.create(null);
      }
      typeMap = typeMap[key];
    }
    var tail = argumentTypes[argumentTypes.length - 1];
    key = $traceurRuntime.getOwnHashObject(tail).hash;
    if (!typeMap[key]) {
      typeMap[key] = new GenericType(type, argumentTypes);
    }
    return typeMap[key];
  }
  $traceurRuntime.GenericType = GenericType;
  $traceurRuntime.genericType = genericType;
  $traceurRuntime.type = types;
  return {};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/runtime-modules.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/runtime-modules.js";
  System.get("traceur-runtime@0.0.92/src/runtime/relativeRequire.js");
  System.get("traceur-runtime@0.0.92/src/runtime/spread.js");
  System.get("traceur-runtime@0.0.92/src/runtime/destructuring.js");
  System.get("traceur-runtime@0.0.92/src/runtime/classes.js");
  System.get("traceur-runtime@0.0.92/src/runtime/async.js");
  System.get("traceur-runtime@0.0.92/src/runtime/generators.js");
  System.get("traceur-runtime@0.0.92/src/runtime/template.js");
  System.get("traceur-runtime@0.0.92/src/runtime/type-assertions.js");
  return {};
});
System.get("traceur-runtime@0.0.92/src/runtime/runtime-modules.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var toObject = $traceurRuntime.toObject;
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach(function(f) {
      return f(global);
    });
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Map.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      registerPolyfill = $__0.registerPolyfill;
  var $__10 = $traceurRuntime,
      getOwnHashObject = $__10.getOwnHashObject,
      hasNativeSymbol = $__10.hasNativeSymbol;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  var deletedSentinel = {};
  function lookupIndex(map, key) {
    if (isObject(key)) {
      var hashObject = getOwnHashObject(key);
      return hashObject && map.objectIndex_[hashObject.hash];
    }
    if (typeof key === 'string')
      return map.stringIndex_[key];
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.deletedCount_ = 0;
  }
  var Map = function() {
    function Map() {
      var $__12,
          $__13;
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Map called on incompatible type');
      if ($hasOwnProperty.call(this, 'entries_')) {
        throw new TypeError('Map can not be reentrantly initialised');
      }
      initMap(this);
      if (iterable !== null && iterable !== undefined) {
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (iterable)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__11 = $__4.value,
                key = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
                value = ($__13 = $__12.next()).done ? void 0 : $__13.value;
            {
              this.set(key, value);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Map, {
      get size() {
        return this.entries_.length / 2 - this.deletedCount_;
      },
      get: function(key) {
        var index = lookupIndex(this, key);
        if (index !== undefined)
          return this.entries_[index + 1];
      },
      set: function(key, value) {
        var objectMode = isObject(key);
        var stringMode = typeof key === 'string';
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          this.entries_[index + 1] = value;
        } else {
          index = this.entries_.length;
          this.entries_[index] = key;
          this.entries_[index + 1] = value;
          if (objectMode) {
            var hashObject = getOwnHashObject(key);
            var hash = hashObject.hash;
            this.objectIndex_[hash] = index;
          } else if (stringMode) {
            this.stringIndex_[key] = index;
          } else {
            this.primitiveIndex_[key] = index;
          }
        }
        return this;
      },
      has: function(key) {
        return lookupIndex(this, key) !== undefined;
      },
      delete: function(key) {
        var objectMode = isObject(key);
        var stringMode = typeof key === 'string';
        var index;
        var hash;
        if (objectMode) {
          var hashObject = getOwnHashObject(key);
          if (hashObject) {
            index = this.objectIndex_[hash = hashObject.hash];
            delete this.objectIndex_[hash];
          }
        } else if (stringMode) {
          index = this.stringIndex_[key];
          delete this.stringIndex_[key];
        } else {
          index = this.primitiveIndex_[key];
          delete this.primitiveIndex_[key];
        }
        if (index !== undefined) {
          this.entries_[index] = deletedSentinel;
          this.entries_[index + 1] = undefined;
          this.deletedCount_++;
          return true;
        }
        return false;
      },
      clear: function() {
        initMap(this);
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        for (var i = 0; i < this.entries_.length; i += 2) {
          var key = this.entries_[i];
          var value = this.entries_[i + 1];
          if (key === deletedSentinel)
            continue;
          callbackFn.call(thisArg, value, key, this);
        }
      },
      entries: $traceurRuntime.initGeneratorFunction(function $__14() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return [key, value];
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__14, this);
      }),
      keys: $traceurRuntime.initGeneratorFunction(function $__15() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return key;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      }),
      values: $traceurRuntime.initGeneratorFunction(function $__16() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return value;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__16, this);
      })
    }, {});
  }();
  Object.defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function needsPolyfill(global) {
    var $__11 = global,
        Map = $__11.Map,
        Symbol = $__11.Symbol;
    if (!Map || !$traceurRuntime.hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {
      return true;
    }
    try {
      return new Map([[]]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillMap(global) {
    if (needsPolyfill(global)) {
      global.Map = Map;
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Map.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Set.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      isObject = $__0.isObject,
      registerPolyfill = $__0.registerPolyfill;
  var Map = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Map.js").Map;
  var getOwnHashObject = $traceurRuntime.getOwnHashObject;
  var $hasOwnProperty = Object.prototype.hasOwnProperty;
  function initSet(set) {
    set.map_ = new Map();
  }
  var Set = function() {
    function Set() {
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Set called on incompatible type');
      if ($hasOwnProperty.call(this, 'map_')) {
        throw new TypeError('Set can not be reentrantly initialised');
      }
      initSet(this);
      if (iterable !== null && iterable !== undefined) {
        var $__8 = true;
        var $__9 = false;
        var $__10 = undefined;
        try {
          for (var $__6 = void 0,
              $__5 = (iterable)[Symbol.iterator](); !($__8 = ($__6 = $__5.next()).done); $__8 = true) {
            var item = $__6.value;
            {
              this.add(item);
            }
          }
        } catch ($__11) {
          $__9 = true;
          $__10 = $__11;
        } finally {
          try {
            if (!$__8 && $__5.return != null) {
              $__5.return();
            }
          } finally {
            if ($__9) {
              throw $__10;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Set, {
      get size() {
        return this.map_.size;
      },
      has: function(key) {
        return this.map_.has(key);
      },
      add: function(key) {
        this.map_.set(key, key);
        return this;
      },
      delete: function(key) {
        return this.map_.delete(key);
      },
      clear: function() {
        return this.map_.clear();
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        var $__4 = this;
        return this.map_.forEach(function(value, key) {
          callbackFn.call(thisArg, key, key, $__4);
        });
      },
      values: $traceurRuntime.initGeneratorFunction(function $__13() {
        var $__14,
            $__15;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__14 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__15 = $__14[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__15.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__15.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__15.value;
              default:
                return $ctx.end();
            }
        }, $__13, this);
      }),
      entries: $traceurRuntime.initGeneratorFunction(function $__16() {
        var $__17,
            $__18;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__17 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__18 = $__17[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__18.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__18.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__18.value;
              default:
                return $ctx.end();
            }
        }, $__16, this);
      })
    }, {});
  }();
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function needsPolyfill(global) {
    var $__12 = global,
        Set = $__12.Set,
        Symbol = $__12.Symbol;
    if (!Set || !$traceurRuntime.hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {
      return true;
    }
    try {
      return new Set([1]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillSet(global) {
    if (needsPolyfill(global)) {
      global.Set = Set;
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Set.js" + '');
System.registerModule("traceur-runtime@0.0.92/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var $__default = asap;
  var browserGlobal = (typeof window !== 'undefined') ? window : {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    return function() {
      process.nextTick(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  var scheduleFlush;
  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return $__default;
    }};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Promise.js";
  var async = System.get("traceur-runtime@0.0.92/node_modules/rsvp/lib/rsvp/asap.js").default;
  var registerPolyfill = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js").registerPolyfill;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: function(x) {
          promiseResolve(promise, x);
        },
        reject: function(r) {
          promiseReject(promise, r);
        }
      };
    } else {
      var result = {};
      result.promise = new C(function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      });
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function() {
    function Promise(resolver) {
      if (resolver === promiseRaw)
        return;
      if (typeof resolver !== 'function')
        throw new TypeError;
      var promise = promiseInit(this);
      try {
        resolver(function(x) {
          promiseResolve(promise, x);
        }, function(r) {
          promiseReject(promise, r);
        });
      } catch (e) {
        promiseReject(promise, e);
      }
    }
    return ($traceurRuntime.createClass)(Promise, {
      catch: function(onReject) {
        return this.then(undefined, onReject);
      },
      then: function(onResolve, onReject) {
        if (typeof onResolve !== 'function')
          onResolve = idResolveHandler;
        if (typeof onReject !== 'function')
          onReject = idRejectHandler;
        var that = this;
        var constructor = this.constructor;
        return chain(this, function(x) {
          x = promiseCoerce(constructor, x);
          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
        }, onReject);
      }
    }, {
      resolve: function(x) {
        if (this === $Promise) {
          if (isPromise(x)) {
            return x;
          }
          return promiseSet(new $Promise(promiseRaw), +1, x);
        } else {
          return new this(function(resolve, reject) {
            resolve(x);
          });
        }
      },
      reject: function(r) {
        if (this === $Promise) {
          return promiseSet(new $Promise(promiseRaw), -1, r);
        } else {
          return new this(function(resolve, reject) {
            reject(r);
          });
        }
      },
      all: function(values) {
        var deferred = getDeferred(this);
        var resolutions = [];
        try {
          var makeCountdownFunction = function(i) {
            return function(x) {
              resolutions[i] = x;
              if (--count === 0)
                deferred.resolve(resolutions);
            };
          };
          var count = 0;
          var i = 0;
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (values)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var value = $__4.value;
              {
                var countdownFunction = makeCountdownFunction(i);
                this.resolve(value).then(countdownFunction, function(r) {
                  deferred.reject(r);
                });
                ++i;
                ++count;
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
          if (count === 0) {
            deferred.resolve(resolutions);
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      },
      race: function(values) {
        var deferred = getDeferred(this);
        try {
          for (var i = 0; i < values.length; i++) {
            this.resolve(values[i]).then(function(x) {
              deferred.resolve(x);
            }, function(r) {
              deferred.reject(r);
            });
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      }
    });
  }();
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async(function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    });
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = '@@thenable';
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        x[thenableSymbol] = promise;
        return promise;
      }
      if (typeof then === 'function') {
        var p = x[thenableSymbol];
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          x[thenableSymbol] = deferred.promise;
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Promise.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/StringIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      createIteratorResultObject = $__0.createIteratorResultObject,
      isObject = $__0.isObject;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function() {
    var $__3;
    function StringIterator() {}
    return ($traceurRuntime.createClass)(StringIterator, ($__3 = {}, Object.defineProperty($__3, "next", {
      value: function() {
        var o = this;
        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
          throw new TypeError('this must be a StringIterator object');
        }
        var s = o[iteratedString];
        if (s === undefined) {
          return createIteratorResultObject(undefined, true);
        }
        var position = o[stringIteratorNextIndex];
        var len = s.length;
        if (position >= len) {
          o[iteratedString] = undefined;
          return createIteratorResultObject(undefined, true);
        }
        var first = s.charCodeAt(position);
        var resultString;
        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
          resultString = String.fromCharCode(first);
        } else {
          var second = s.charCodeAt(position + 1);
          if (second < 0xDC00 || second > 0xDFFF) {
            resultString = String.fromCharCode(first);
          } else {
            resultString = String.fromCharCode(first) + String.fromCharCode(second);
          }
        }
        o[stringIteratorNextIndex] = position + resultString.length;
        return createIteratorResultObject(resultString, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__3, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__3), {});
  }();
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[iteratedString] = s;
    iterator[stringIteratorNextIndex] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/String.js";
  var createStringIterator = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/StringIterator.js").createStringIterator;
  var $__1 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint(_) {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = $traceurRuntime.checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/String.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/ArrayIterator.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      toObject = $__0.toObject,
      toUint32 = $__0.toUint32,
      createIteratorResultObject = $__0.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function() {
    var $__3;
    function ArrayIterator() {}
    return ($traceurRuntime.createClass)(ArrayIterator, ($__3 = {}, Object.defineProperty($__3, "next", {
      value: function() {
        var iterator = toObject(this);
        var array = iterator.iteratorObject_;
        if (!array) {
          throw new TypeError('Object is not an ArrayIterator');
        }
        var index = iterator.arrayIteratorNextIndex_;
        var itemKind = iterator.arrayIterationKind_;
        var length = toUint32(array.length);
        if (index >= length) {
          iterator.arrayIteratorNextIndex_ = Infinity;
          return createIteratorResultObject(undefined, true);
        }
        iterator.arrayIteratorNextIndex_ = index + 1;
        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
          return createIteratorResultObject(array[index], false);
        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
          return createIteratorResultObject([index, array[index]], false);
        return createIteratorResultObject(index, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__3, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__3), {});
  }();
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Array.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/ArrayIterator.js"),
      entries = $__0.entries,
      keys = $__0.keys,
      jsValues = $__0.values;
  var $__1 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      checkIterable = $__1.checkIterable,
      isCallable = $__1.isCallable,
      isConstructor = $__1.isConstructor,
      maybeAddFunctions = $__1.maybeAddFunctions,
      maybeAddIterator = $__1.maybeAddIterator,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger,
      toLength = $__1.toLength,
      toObject = $__1.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      var $__6 = true;
      var $__7 = false;
      var $__8 = undefined;
      try {
        for (var $__4 = void 0,
            $__3 = (items)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
          var item = $__4.value;
          {
            if (mapping) {
              arr[k] = mapFn.call(thisArg, item, k);
            } else {
              arr[k] = item;
            }
            k++;
          }
        }
      } catch ($__9) {
        $__7 = true;
        $__8 = $__9;
      } finally {
        try {
          if (!$__6 && $__3.return != null) {
            $__3.return();
          }
        } finally {
          if ($__7) {
            throw $__8;
          }
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__10 = 0; $__10 < arguments.length; $__10++)
      items[$__10] = arguments[$__10];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__11 = global,
        Array = $__11.Array,
        Object = $__11.Object,
        Symbol = $__11.Symbol;
    var values = jsValues;
    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {
      values = Array.prototype[Symbol.iterator];
    }
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Array.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Object.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill;
  var $__2 = $traceurRuntime,
      getOwnPropertyNames = $__2.getOwnPropertyNames,
      isPrivateName = $__2.isPrivateName,
      keys = $__2.keys;
  var $__3 = Object,
      defineProperty = $__3.defineProperty,
      getOwnPropertyDescriptor = $__3.getOwnPropertyDescriptor;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p = void 0,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        if (isPrivateName(name))
          continue;
        target[name] = source[name];
      }
    }
    return target;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      if (isPrivateName(name))
        continue;
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get is() {
      return is;
    },
    get assign() {
      return assign;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Object.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Number.js";
  var $__0 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      isNumber = $__0.isNumber,
      maybeAddConsts = $__0.maybeAddConsts,
      maybeAddFunctions = $__0.maybeAddFunctions,
      registerPolyfill = $__0.registerPolyfill,
      toInteger = $__0.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Number.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/fround.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/fround.js";
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__1 = Math,
      LN2 = $__1.LN2,
      abs = $__1.abs,
      floor = $__1.floor,
      log = $__1.log,
      min = $__1.min,
      pow = $__1.pow;
  function packIEEE754(v, ebits, fbits) {
    var bias = (1 << (ebits - 1)) - 1,
        s,
        e,
        f,
        ln,
        i,
        bits,
        str,
        bytes;
    function roundToEven(n) {
      var w = floor(n),
          f = n - w;
      if (f < 0.5)
        return w;
      if (f > 0.5)
        return w + 1;
      return w % 2 ? w + 1 : w;
    }
    if (v !== v) {
      e = (1 << ebits) - 1;
      f = pow(2, fbits - 1);
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << ebits) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = abs(v);
      if (v >= pow(2, 1 - bias)) {
        e = min(floor(log(v) / LN2), 1023);
        f = roundToEven(v / pow(2, e) * pow(2, fbits));
        if (f / pow(2, fbits) >= 2) {
          e = e + 1;
          f = 1;
        }
        if (e > bias) {
          e = (1 << ebits) - 1;
          f = 0;
        } else {
          e = e + bias;
          f = f - pow(2, fbits);
        }
      } else {
        e = 0;
        f = roundToEven(v / pow(2, 1 - bias - fbits));
      }
    }
    bits = [];
    for (i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  }
  function unpackIEEE754(bytes, ebits, fbits) {
    var bits = [],
        i,
        j,
        b,
        str,
        bias,
        s,
        e,
        f;
    for (i = bytes.length; i; i -= 1) {
      b = bytes[i - 1];
      for (j = 8; j; j -= 1) {
        bits.push(b % 2 ? 1 : 0);
        b = b >> 1;
      }
    }
    bits.reverse();
    str = bits.join('');
    bias = (1 << (ebits - 1)) - 1;
    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    e = parseInt(str.substring(1, 1 + ebits), 2);
    f = parseInt(str.substring(1 + ebits), 2);
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    } else if (e > 0) {
      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
    } else if (f !== 0) {
      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
    } else {
      return s < 0 ? -0 : 0;
    }
  }
  function unpackF32(b) {
    return unpackIEEE754(b, 8, 23);
  }
  function packF32(v) {
    return packIEEE754(v, 8, 23);
  }
  function fround(x) {
    if (x === 0 || !$isFinite(x) || $isNaN(x)) {
      return x;
    }
    return unpackF32(packF32(Number(x)));
  }
  return {get fround() {
      return fround;
    }};
});
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/Math.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/Math.js";
  var jsFround = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/fround.js").fround;
  var $__1 = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js"),
      maybeAddFunctions = $__1.maybeAddFunctions,
      registerPolyfill = $__1.registerPolyfill,
      toUint32 = $__1.toUint32;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__3 = Math,
      abs = $__3.abs,
      ceil = $__3.ceil,
      exp = $__3.exp,
      floor = $__3.floor,
      log = $__3.log,
      pow = $__3.pow,
      sqrt = $__3.sqrt;
  function clz32(x) {
    x = toUint32(+x);
    if (x == 0)
      return 32;
    var result = 0;
    if ((x & 0xFFFF0000) === 0) {
      x <<= 16;
      result += 16;
    }
    ;
    if ((x & 0xFF000000) === 0) {
      x <<= 8;
      result += 8;
    }
    ;
    if ((x & 0xF0000000) === 0) {
      x <<= 4;
      result += 4;
    }
    ;
    if ((x & 0xC0000000) === 0) {
      x <<= 2;
      result += 2;
    }
    ;
    if ((x & 0x80000000) === 0) {
      x <<= 1;
      result += 1;
    }
    ;
    return result;
  }
  function imul(x, y) {
    x = toUint32(+x);
    y = toUint32(+y);
    var xh = (x >>> 16) & 0xffff;
    var xl = x & 0xffff;
    var yh = (y >>> 16) & 0xffff;
    var yl = y & 0xffff;
    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;
  }
  function sign(x) {
    x = +x;
    if (x > 0)
      return 1;
    if (x < 0)
      return -1;
    return x;
  }
  function log10(x) {
    return log(x) * 0.434294481903251828;
  }
  function log2(x) {
    return log(x) * 1.442695040888963407;
  }
  function log1p(x) {
    x = +x;
    if (x < -1 || $isNaN(x)) {
      return NaN;
    }
    if (x === 0 || x === Infinity) {
      return x;
    }
    if (x === -1) {
      return -Infinity;
    }
    var result = 0;
    var n = 50;
    if (x < 0 || x > 1) {
      return log(1 + x);
    }
    for (var i = 1; i < n; i++) {
      if ((i % 2) === 0) {
        result -= pow(x, i) / i;
      } else {
        result += pow(x, i) / i;
      }
    }
    return result;
  }
  function expm1(x) {
    x = +x;
    if (x === -Infinity) {
      return -1;
    }
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return exp(x) - 1;
  }
  function cosh(x) {
    x = +x;
    if (x === 0) {
      return 1;
    }
    if ($isNaN(x)) {
      return NaN;
    }
    if (!$isFinite(x)) {
      return Infinity;
    }
    if (x < 0) {
      x = -x;
    }
    if (x > 21) {
      return exp(x) / 2;
    }
    return (exp(x) + exp(-x)) / 2;
  }
  function sinh(x) {
    x = +x;
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  }
  function tanh(x) {
    x = +x;
    if (x === 0)
      return x;
    if (!$isFinite(x))
      return sign(x);
    var exp1 = exp(x);
    var exp2 = exp(-x);
    return (exp1 - exp2) / (exp1 + exp2);
  }
  function acosh(x) {
    x = +x;
    if (x < 1)
      return NaN;
    if (!$isFinite(x))
      return x;
    return log(x + sqrt(x + 1) * sqrt(x - 1));
  }
  function asinh(x) {
    x = +x;
    if (x === 0 || !$isFinite(x))
      return x;
    if (x > 0)
      return log(x + sqrt(x * x + 1));
    return -log(-x + sqrt(x * x + 1));
  }
  function atanh(x) {
    x = +x;
    if (x === -1) {
      return -Infinity;
    }
    if (x === 1) {
      return Infinity;
    }
    if (x === 0) {
      return x;
    }
    if ($isNaN(x) || x < -1 || x > 1) {
      return NaN;
    }
    return 0.5 * log((1 + x) / (1 - x));
  }
  function hypot(x, y) {
    var length = arguments.length;
    var args = new Array(length);
    var max = 0;
    for (var i = 0; i < length; i++) {
      var n = arguments[i];
      n = +n;
      if (n === Infinity || n === -Infinity)
        return Infinity;
      n = abs(n);
      if (n > max)
        max = n;
      args[i] = n;
    }
    if (max === 0)
      max = 1;
    var sum = 0;
    var compensation = 0;
    for (var i = 0; i < length; i++) {
      var n = args[i] / max;
      var summand = n * n - compensation;
      var preliminary = sum + summand;
      compensation = (preliminary - sum) - summand;
      sum = preliminary;
    }
    return sqrt(sum) * max;
  }
  function trunc(x) {
    x = +x;
    if (x > 0)
      return floor(x);
    if (x < 0)
      return ceil(x);
    return x;
  }
  var fround,
      f32;
  if (typeof Float32Array === 'function') {
    f32 = new Float32Array(1);
    fround = function(x) {
      f32[0] = Number(x);
      return f32[0];
    };
  } else {
    fround = jsFround;
  }
  function cbrt(x) {
    x = +x;
    if (x === 0)
      return x;
    var negate = x < 0;
    if (negate)
      x = -x;
    var result = pow(x, 1 / 3);
    return negate ? -result : result;
  }
  function polyfillMath(global) {
    var Math = global.Math;
    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);
  }
  registerPolyfill(polyfillMath);
  return {
    get clz32() {
      return clz32;
    },
    get imul() {
      return imul;
    },
    get sign() {
      return sign;
    },
    get log10() {
      return log10;
    },
    get log2() {
      return log2;
    },
    get log1p() {
      return log1p;
    },
    get expm1() {
      return expm1;
    },
    get cosh() {
      return cosh;
    },
    get sinh() {
      return sinh;
    },
    get tanh() {
      return tanh;
    },
    get acosh() {
      return acosh;
    },
    get asinh() {
      return asinh;
    },
    get atanh() {
      return atanh;
    },
    get hypot() {
      return hypot;
    },
    get trunc() {
      return trunc;
    },
    get fround() {
      return fround;
    },
    get cbrt() {
      return cbrt;
    },
    get polyfillMath() {
      return polyfillMath;
    }
  };
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/Math.js" + '');
System.registerModule("traceur-runtime@0.0.92/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.92/src/runtime/polyfills/polyfills.js";
  var polyfillAll = System.get("traceur-runtime@0.0.92/src/runtime/polyfills/utils.js").polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
System.get("traceur-runtime@0.0.92/src/runtime/polyfills/polyfills.js" + '');
;(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;
        if (!u && a)
          return a(o, !0);
        if (i)
          return i(o, !0);
        var f = new Error("Cannot find module '" + o + "'");
        throw f.code = "MODULE_NOT_FOUND", f;
      }
      var l = n[o] = {exports: {}};
      t[o][0].call(l.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == "function" && require;
  for (var o = 0; o < r.length; o++)
    s(r[o]);
  return s;
})({
  1: [function(require, module, exports) {
    module.exports = (function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            parser = this,
            peg$FAILED = {},
            peg$startRuleFunctions = {TranslationUnit: peg$parseTranslationUnit},
            peg$startRuleFunction = peg$parseTranslationUnit,
            peg$c0 = function(a) {
              return addPositionInfo({
                type: 'TranslationUnit',
                ExternalDeclarations: a
              });
            },
            peg$c1 = function(a, b) {
              return addPositionInfo({
                type: 'NamespaceDefinition',
                Identifier: a,
                ExternalDeclarations: b
              });
            },
            peg$c2 = function(a) {
              return addPositionInfo({
                type: 'UsingDirective',
                Identifier: a
              });
            },
            peg$c3 = function(a, b) {
              return addPositionInfo({
                type: 'UsingDeclaration',
                scope: a,
                Identifier: b
              });
            },
            peg$c4 = function(a, b) {
              return addPositionInfo({
                type: 'NamespaceAliasDefinition',
                target: b,
                Identifier: a
              });
            },
            peg$c5 = function(a, b) {
              return a;
            },
            peg$c6 = function(a, b, c) {
              return addPositionInfo({
                type: 'TypedefDeclaration',
                DeclarationSpecifiers: a,
                Declarators: [b].concat(c)
              });
            },
            peg$c7 = function(a, b) {
              return null;
            },
            peg$c8 = function(a, b, c) {
              return addPositionInfo({
                type: 'FunctionDefinition',
                DeclarationSpecifiers: a,
                Declarator: b,
                CompoundStatement: c
              });
            },
            peg$c9 = function(a) {
              return addPositionInfo({
                type: 'DeclarationList',
                Declarations: a
              });
            },
            peg$c10 = function(a) {
              return addPositionInfo({
                type: 'Label_case',
                ConstantExpression: a
              });
            },
            peg$c11 = function() {
              return addPositionInfo({type: 'Label_default'});
            },
            peg$c12 = function(a) {
              return addPositionInfo({
                type: 'CompoundStatement',
                Statements: a
              });
            },
            peg$c13 = function(a) {
              return addPositionInfo({
                type: 'ExpressionStatement',
                Expression: a
              });
            },
            peg$c14 = function(a, b, c) {
              return addPositionInfo({
                type: 'SelectionStatement_if',
                Expression: a,
                Statement: b,
                ElseStatement: c ? c[1] : null
              });
            },
            peg$c15 = function(a, b) {
              return addPositionInfo({
                type: 'SelectionStatement_switch',
                Expression: a,
                Statement: b
              });
            },
            peg$c16 = function(a, b) {
              return addPositionInfo({
                type: 'IterationStatement_while',
                Expression: a,
                Statement: b
              });
            },
            peg$c17 = function(a, b) {
              return addPositionInfo({
                type: 'IterationStatement_do',
                Expression: b,
                Statement: a
              });
            },
            peg$c18 = function(a, c, d, e) {
              return addPositionInfo({
                type: 'IterationStatement_for',
                Initializer: a,
                Expression: c,
                Loop: d,
                Statement: e
              });
            },
            peg$c19 = function(a) {
              return addPositionInfo({
                type: 'JumpStatement_goto',
                Identifier: a
              });
            },
            peg$c20 = function() {
              return addPositionInfo({type: 'JumpStatement_continue'});
            },
            peg$c21 = function() {
              return addPositionInfo({type: 'JumpStatement_break'});
            },
            peg$c22 = function(a) {
              return addPositionInfo({
                type: 'JumpStatement_return',
                Expression: a
              });
            },
            peg$c23 = function(a, b) {
              return addPositionInfo({
                type: 'Declaration',
                DeclarationSpecifiers: a,
                InitDeclaratorList: b
              });
            },
            peg$c24 = function(a, b, c) {
              return a.concat([b]).concat(c);
            },
            peg$c25 = function(a) {
              return a;
            },
            peg$c26 = function(a) {
              return a;
            },
            peg$c27 = function(a) {
              return a;
            },
            peg$c28 = function(a, x) {
              return x;
            },
            peg$c29 = function(a, b) {
              return [a].concat(b);
            },
            peg$c30 = function(a, b) {
              return addPositionInfo({
                type: 'InitDeclarator',
                Declarator: a,
                Initializers: b
              });
            },
            peg$c31 = function(a) {
              return a;
            },
            peg$c32 = function(a) {
              return addPositionInfo({
                type: 'Identifier',
                Identifier: a
              });
            },
            peg$c33 = function(a) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_ParameterTypeList',
                ParameterTypeList: a
              });
            },
            peg$c34 = function(a, b) {
              return addPositionInfo({
                type: 'DirectDeclarator',
                left: a,
                right: b
              });
            },
            peg$c35 = function(a, b) {
              b.Pointer = a;
              return b;
            },
            peg$c36 = function(a, b) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_array',
                Modifier: a || [],
                Expression: b
              });
            },
            peg$c37 = function(a, b) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_array',
                Modifier: ['static'].concat(a),
                Expression: b
              });
            },
            peg$c38 = function(a) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_star_array',
                Modifier: a.concat['*']
              });
            },
            peg$c39 = function(a) {
              return addPositionInfo({
                type: 'DirectDeclarator_modifier_IdentifierList',
                IdentifierList: a
              });
            },
            peg$c40 = function(a, b) {
              return addPositionInfo({
                type: 'ParameterTypeList',
                ParameterList: a,
                varargs: b !== null
              });
            },
            peg$c41 = function(a, b) {
              if (a)
                return [a].concat(b);
              else
                return b;
            },
            peg$c42 = function(a, b) {
              return addPositionInfo({
                type: 'ParameterDeclaration',
                DeclarationSpecifiers: a,
                Declarator: b
              });
            },
            peg$c43 = function(a, b) {
              return addPositionInfo({
                type: 'TypeName',
                base: a,
                extra: b
              });
            },
            peg$c44 = function(a) {
              return addPositionInfo({
                type: 'AbstractDeclarator',
                Pointer: a
              });
            },
            peg$c45 = function(a) {
              return addPositionInfo({
                type: 'Initializer_expr',
                Expression: a
              });
            },
            peg$c46 = function(a) {
              return addPositionInfo({
                type: 'Initializer_array',
                Initializers: a
              });
            },
            peg$c47 = function(a, b) {
              return [a].concat(b);
            },
            peg$c48 = function(a) {
              return addPositionInfo({
                type: 'IdentifierExpression',
                Identifier: a
              });
            },
            peg$c49 = function(a) {
              return addPositionInfo({
                type: 'ConstantExpression',
                Expression: a
              });
            },
            peg$c50 = function(a) {
              return addPositionInfo({
                type: 'StringLiteralExpression',
                value: a
              });
            },
            peg$c51 = function(a) {
              return addPositionInfo({
                type: 'ParenthesesExpression',
                Expression: a
              });
            },
            peg$c52 = function(a, c) {
              return [0, c];
            },
            peg$c53 = function(a, c) {
              return [1, c ? c : []];
            },
            peg$c54 = function(a, c) {
              return [2, c];
            },
            peg$c55 = function(a, c) {
              return [3, c];
            },
            peg$c56 = function(a, c) {
              return [4];
            },
            peg$c57 = function(a, c) {
              return [5];
            },
            peg$c58 = function(a, b) {
              if (b.length > 0) {
                var ret = addPositionInfo({Expression: a});
                for (var i = 0; i < b.length; i++) {
                  var o = b[i][1];
                  switch (b[i][0]) {
                    case 0:
                      ret.type = 'PostfixExpression_ArrayAccess';
                      ret.index = o;
                      break;
                    case 1:
                      ret.type = 'PostfixExpression_MethodInvocation';
                      ret.args = o;
                      break;
                    case 2:
                      ret.type = 'PostfixExpression_MemberAccess';
                      ret.member = o;
                      break;
                    case 3:
                      ret.type = 'PostfixExpression_MemberPointerAccess';
                      ret.member = o;
                      break;
                    case 4:
                      ret.type = 'PostfixExpression_PostIncrement';
                      break;
                    case 5:
                      ret.type = 'PostfixExpression_PostDecrement';
                      break;
                  }
                  ret = addPositionInfo({Expression: ret});
                }
                return ret.Expression;
              } else
                return a;
            },
            peg$c59 = function(a, b) {
              var ret = [a];
              for (var i = 0; i < b.length; i++)
                ret.push(b[i][1]);
              return ret;
            },
            peg$c60 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_PreIncrement',
                Expression: a
              });
            },
            peg$c61 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_PreDecrement',
                Expression: a
              });
            },
            peg$c62 = function(a, b) {
              return addPositionInfo({
                type: 'UnaryExpression',
                op: a,
                Expression: b
              });
            },
            peg$c63 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_Sizeof_Expr',
                Expression: a
              });
            },
            peg$c64 = function(a) {
              return addPositionInfo({
                type: 'UnaryExpression_Sizeof_Type',
                TypeName: a
              });
            },
            peg$c65 = function(a, b) {
              return addPositionInfo({
                type: 'CastExpression',
                TypeName: a[1],
                Expression: b
              });
            },
            peg$c66 = function(a, b) {
              return buildRecursiveBinop(a, b);
            },
            peg$c67 = function(a, b) {
              var ret = a;
              for (var i = 0; i < b.length; i++) {
                ret = addPositionInfo({
                  type: 'ConditionalExpression',
                  cond: ret,
                  t: b[i][1],
                  f: b[i][3]
                });
              }
              return ret;
            },
            peg$c68 = function(a, b, c) {
              return addPositionInfo({
                type: 'BinOpExpression',
                op: b,
                left: a,
                right: c
              });
            },
            peg$c69 = function(a) {
              return a.join('');
            },
            peg$c70 = /^[ \n\r\t\x0B\f]/,
            peg$c71 = {
              type: "class",
              value: "[ \\n\\r\\t\\u000B\\u000C]",
              description: "[ \\n\\r\\t\\u000B\\u000C]"
            },
            peg$c72 = "/*",
            peg$c73 = {
              type: "literal",
              value: "/*",
              description: "\"/*\""
            },
            peg$c74 = "*/",
            peg$c75 = {
              type: "literal",
              value: "*/",
              description: "\"*/\""
            },
            peg$c76 = function(a) {
              return a.join('');
            },
            peg$c77 = "//",
            peg$c78 = {
              type: "literal",
              value: "//",
              description: "\"//\""
            },
            peg$c79 = "\n",
            peg$c80 = {
              type: "literal",
              value: "\n",
              description: "\"\\n\""
            },
            peg$c81 = "auto",
            peg$c82 = {
              type: "literal",
              value: "auto",
              description: "\"auto\""
            },
            peg$c83 = "break",
            peg$c84 = {
              type: "literal",
              value: "break",
              description: "\"break\""
            },
            peg$c85 = "case",
            peg$c86 = {
              type: "literal",
              value: "case",
              description: "\"case\""
            },
            peg$c87 = "char",
            peg$c88 = {
              type: "literal",
              value: "char",
              description: "\"char\""
            },
            peg$c89 = "const",
            peg$c90 = {
              type: "literal",
              value: "const",
              description: "\"const\""
            },
            peg$c91 = "continue",
            peg$c92 = {
              type: "literal",
              value: "continue",
              description: "\"continue\""
            },
            peg$c93 = "default",
            peg$c94 = {
              type: "literal",
              value: "default",
              description: "\"default\""
            },
            peg$c95 = "double",
            peg$c96 = {
              type: "literal",
              value: "double",
              description: "\"double\""
            },
            peg$c97 = "do",
            peg$c98 = {
              type: "literal",
              value: "do",
              description: "\"do\""
            },
            peg$c99 = "else",
            peg$c100 = {
              type: "literal",
              value: "else",
              description: "\"else\""
            },
            peg$c101 = "enum",
            peg$c102 = {
              type: "literal",
              value: "enum",
              description: "\"enum\""
            },
            peg$c103 = "extern",
            peg$c104 = {
              type: "literal",
              value: "extern",
              description: "\"extern\""
            },
            peg$c105 = "float",
            peg$c106 = {
              type: "literal",
              value: "float",
              description: "\"float\""
            },
            peg$c107 = "for",
            peg$c108 = {
              type: "literal",
              value: "for",
              description: "\"for\""
            },
            peg$c109 = "goto",
            peg$c110 = {
              type: "literal",
              value: "goto",
              description: "\"goto\""
            },
            peg$c111 = "if",
            peg$c112 = {
              type: "literal",
              value: "if",
              description: "\"if\""
            },
            peg$c113 = "int",
            peg$c114 = {
              type: "literal",
              value: "int",
              description: "\"int\""
            },
            peg$c115 = "inline",
            peg$c116 = {
              type: "literal",
              value: "inline",
              description: "\"inline\""
            },
            peg$c117 = "long",
            peg$c118 = {
              type: "literal",
              value: "long",
              description: "\"long\""
            },
            peg$c119 = "register",
            peg$c120 = {
              type: "literal",
              value: "register",
              description: "\"register\""
            },
            peg$c121 = "restrict",
            peg$c122 = {
              type: "literal",
              value: "restrict",
              description: "\"restrict\""
            },
            peg$c123 = "return",
            peg$c124 = {
              type: "literal",
              value: "return",
              description: "\"return\""
            },
            peg$c125 = "short",
            peg$c126 = {
              type: "literal",
              value: "short",
              description: "\"short\""
            },
            peg$c127 = "signed",
            peg$c128 = {
              type: "literal",
              value: "signed",
              description: "\"signed\""
            },
            peg$c129 = "sizeof",
            peg$c130 = {
              type: "literal",
              value: "sizeof",
              description: "\"sizeof\""
            },
            peg$c131 = "static",
            peg$c132 = {
              type: "literal",
              value: "static",
              description: "\"static\""
            },
            peg$c133 = "struct",
            peg$c134 = {
              type: "literal",
              value: "struct",
              description: "\"struct\""
            },
            peg$c135 = "switch",
            peg$c136 = {
              type: "literal",
              value: "switch",
              description: "\"switch\""
            },
            peg$c137 = "typedef",
            peg$c138 = {
              type: "literal",
              value: "typedef",
              description: "\"typedef\""
            },
            peg$c139 = "union",
            peg$c140 = {
              type: "literal",
              value: "union",
              description: "\"union\""
            },
            peg$c141 = "unsigned",
            peg$c142 = {
              type: "literal",
              value: "unsigned",
              description: "\"unsigned\""
            },
            peg$c143 = "void",
            peg$c144 = {
              type: "literal",
              value: "void",
              description: "\"void\""
            },
            peg$c145 = "volatile",
            peg$c146 = {
              type: "literal",
              value: "volatile",
              description: "\"volatile\""
            },
            peg$c147 = "while",
            peg$c148 = {
              type: "literal",
              value: "while",
              description: "\"while\""
            },
            peg$c149 = "_Bool",
            peg$c150 = {
              type: "literal",
              value: "_Bool",
              description: "\"_Bool\""
            },
            peg$c151 = "_Complex",
            peg$c152 = {
              type: "literal",
              value: "_Complex",
              description: "\"_Complex\""
            },
            peg$c153 = "_stdcall",
            peg$c154 = {
              type: "literal",
              value: "_stdcall",
              description: "\"_stdcall\""
            },
            peg$c155 = "__declspec",
            peg$c156 = {
              type: "literal",
              value: "__declspec",
              description: "\"__declspec\""
            },
            peg$c157 = "__attribute__",
            peg$c158 = {
              type: "literal",
              value: "__attribute__",
              description: "\"__attribute__\""
            },
            peg$c159 = "namespace",
            peg$c160 = {
              type: "literal",
              value: "namespace",
              description: "\"namespace\""
            },
            peg$c161 = "using",
            peg$c162 = {
              type: "literal",
              value: "using",
              description: "\"using\""
            },
            peg$c163 = "true",
            peg$c164 = {
              type: "literal",
              value: "true",
              description: "\"true\""
            },
            peg$c165 = "false",
            peg$c166 = {
              type: "literal",
              value: "false",
              description: "\"false\""
            },
            peg$c167 = "_Imaginary",
            peg$c168 = {
              type: "literal",
              value: "_Imaginary",
              description: "\"_Imaginary\""
            },
            peg$c169 = function(a, b, c) {
              var scope = a ? "global" : null;
              for (var i = 0; i < b.length; i++) {
                scope = addPositionInfo({
                  type: "ScopedIdentifier",
                  scope: scope,
                  Identifier: b[i]
                });
              }
              return addPositionInfo({
                type: "ScopedIdentifier",
                scope: scope,
                Identifier: c
              });
            },
            peg$c170 = function(a, b) {
              return a + b.join('');
            },
            peg$c171 = /^[a-z]/,
            peg$c172 = {
              type: "class",
              value: "[a-z]",
              description: "[a-z]"
            },
            peg$c173 = /^[A-Z]/,
            peg$c174 = {
              type: "class",
              value: "[A-Z]",
              description: "[A-Z]"
            },
            peg$c175 = /^[_]/,
            peg$c176 = {
              type: "class",
              value: "[_]",
              description: "[_]"
            },
            peg$c177 = /^[0-9]/,
            peg$c178 = {
              type: "class",
              value: "[0-9]",
              description: "[0-9]"
            },
            peg$c179 = "\\u",
            peg$c180 = {
              type: "literal",
              value: "\\u",
              description: "\"\\\\u\""
            },
            peg$c181 = "\\U",
            peg$c182 = {
              type: "literal",
              value: "\\U",
              description: "\"\\\\U\""
            },
            peg$c183 = function(a) {
              return addPositionInfo({
                type: 'BooleanConstant',
                value: a
              });
            },
            peg$c184 = /^[1-9]/,
            peg$c185 = {
              type: "class",
              value: "[1-9]",
              description: "[1-9]"
            },
            peg$c186 = function(a, b) {
              return addPositionInfo({
                type: 'DecimalConstant',
                value: a + b.join("")
              });
            },
            peg$c187 = "0",
            peg$c188 = {
              type: "literal",
              value: "0",
              description: "\"0\""
            },
            peg$c189 = /^[0-7]/,
            peg$c190 = {
              type: "class",
              value: "[0-7]",
              description: "[0-7]"
            },
            peg$c191 = function(a) {
              if (a.length > 0)
                return addPositionInfo({
                  type: 'OctalConstant',
                  value: a.join("")
                });
              else
                return addPositionInfo({
                  type: 'OctalConstant',
                  value: '0'
                });
            },
            peg$c192 = function(a) {
              return addPositionInfo({
                type: 'HexConstant',
                value: a.join("")
              });
            },
            peg$c193 = "0x",
            peg$c194 = {
              type: "literal",
              value: "0x",
              description: "\"0x\""
            },
            peg$c195 = "0X",
            peg$c196 = {
              type: "literal",
              value: "0X",
              description: "\"0X\""
            },
            peg$c197 = /^[a-f]/,
            peg$c198 = {
              type: "class",
              value: "[a-f]",
              description: "[a-f]"
            },
            peg$c199 = /^[A-F]/,
            peg$c200 = {
              type: "class",
              value: "[A-F]",
              description: "[A-F]"
            },
            peg$c201 = "0b",
            peg$c202 = {
              type: "literal",
              value: "0b",
              description: "\"0b\""
            },
            peg$c203 = /^[0-1]/,
            peg$c204 = {
              type: "class",
              value: "[0-1]",
              description: "[0-1]"
            },
            peg$c205 = function(a) {
              return addPositionInfo({
                type: 'BinaryConstant',
                value: a.join("")
              });
            },
            peg$c206 = /^[uU]/,
            peg$c207 = {
              type: "class",
              value: "[uU]",
              description: "[uU]"
            },
            peg$c208 = "ll",
            peg$c209 = {
              type: "literal",
              value: "ll",
              description: "\"ll\""
            },
            peg$c210 = "LL",
            peg$c211 = {
              type: "literal",
              value: "LL",
              description: "\"LL\""
            },
            peg$c212 = /^[lL]/,
            peg$c213 = {
              type: "class",
              value: "[lL]",
              description: "[lL]"
            },
            peg$c214 = function(a, b) {
              if (b)
                return addPositionInfo({
                  type: 'FloatConstant',
                  Expression: a
                });
              else
                return a;
            },
            peg$c215 = function(a, b) {
              return addPositionInfo({
                type: 'DecimalFloatConstant',
                value: a + b || ''
              });
            },
            peg$c216 = function(a, b) {
              return addPositionInfo({
                type: 'DecimalFloatConstant',
                value: a.join('') + b
              });
            },
            peg$c217 = function(a, b, c) {
              return addPositionInfo({
                type: 'HexFloatConstant',
                value: a + b + c || ''
              });
            },
            peg$c218 = function(a, b, c) {
              return addPositionInfo({
                type: 'HexFloatConstant',
                value: a + b.join('') + c
              });
            },
            peg$c219 = ".",
            peg$c220 = {
              type: "literal",
              value: ".",
              description: "\".\""
            },
            peg$c221 = function(a, b) {
              return a.join('') + '.' + b.join('');
            },
            peg$c222 = function(a) {
              return a.join('') + '.';
            },
            peg$c223 = /^[eE]/,
            peg$c224 = {
              type: "class",
              value: "[eE]",
              description: "[eE]"
            },
            peg$c225 = /^[+\-]/,
            peg$c226 = {
              type: "class",
              value: "[+\\-]",
              description: "[+\\-]"
            },
            peg$c227 = function(a, b, c) {
              return a + (b || "") + c.join('');
            },
            peg$c228 = /^[pP]/,
            peg$c229 = {
              type: "class",
              value: "[pP]",
              description: "[pP]"
            },
            peg$c230 = function(a, b) {
              return a + b.join('');
            },
            peg$c231 = /^[flFL]/,
            peg$c232 = {
              type: "class",
              value: "[flFL]",
              description: "[flFL]"
            },
            peg$c233 = function(a) {
              return addPositionInfo({
                type: 'EnumerationConstant',
                Identifier: a
              });
            },
            peg$c234 = "L",
            peg$c235 = {
              type: "literal",
              value: "L",
              description: "\"L\""
            },
            peg$c236 = "'",
            peg$c237 = {
              type: "literal",
              value: "'",
              description: "\"'\""
            },
            peg$c238 = function(a) {
              return addPositionInfo({
                type: 'CharacterConstant',
                Char: a
              });
            },
            peg$c239 = /^['\n\\]/,
            peg$c240 = {
              type: "class",
              value: "['\\n\\\\]",
              description: "['\\n\\\\]"
            },
            peg$c241 = "\\",
            peg$c242 = {
              type: "literal",
              value: "\\",
              description: "\"\\\\\""
            },
            peg$c243 = /^['"?\\abfnrtv]/,
            peg$c244 = {
              type: "class",
              value: "['\\\"?\\\\abfnrtv]",
              description: "['\\\"?\\\\abfnrtv]"
            },
            peg$c245 = function(a, b) {
              return eval('"' + a + b + '"');
            },
            peg$c246 = function(a, b, c, d) {
              var ret = "\"";
              ret += a;
              ret += b;
              if (c)
                ret += c;
              if (d)
                ret += d;
              ret += "\"";
              return eval(ret);
            },
            peg$c247 = "\\x",
            peg$c248 = {
              type: "literal",
              value: "\\x",
              description: "\"\\\\x\""
            },
            peg$c249 = function(a, b) {
              return eval('"' + a + b.join('') + '"');
            },
            peg$c250 = "u8",
            peg$c251 = {
              type: "literal",
              value: "u8",
              description: "\"u8\""
            },
            peg$c252 = "u",
            peg$c253 = {
              type: "literal",
              value: "u",
              description: "\"u\""
            },
            peg$c254 = "U",
            peg$c255 = {
              type: "literal",
              value: "U",
              description: "\"U\""
            },
            peg$c256 = function(a, b) {
              return addPositionInfo({
                type: 'StringLiteral',
                prefix: a,
                value: b
              });
            },
            peg$c257 = "R",
            peg$c258 = {
              type: "literal",
              value: "R",
              description: "\"R\""
            },
            peg$c259 = /^["]/,
            peg$c260 = {
              type: "class",
              value: "[\"]",
              description: "[\"]"
            },
            peg$c261 = function(a) {
              return a.join('');
            },
            peg$c262 = /^["\n]/,
            peg$c263 = {
              type: "class",
              value: "[\\\"\\n]",
              description: "[\\\"\\n]"
            },
            peg$c264 = /^["\n\\]/,
            peg$c265 = {
              type: "class",
              value: "[\\\"\\n\\\\]",
              description: "[\\\"\\n\\\\]"
            },
            peg$c266 = "[",
            peg$c267 = {
              type: "literal",
              value: "[",
              description: "\"[\""
            },
            peg$c268 = "]",
            peg$c269 = {
              type: "literal",
              value: "]",
              description: "\"]\""
            },
            peg$c270 = "(",
            peg$c271 = {
              type: "literal",
              value: "(",
              description: "\"(\""
            },
            peg$c272 = ")",
            peg$c273 = {
              type: "literal",
              value: ")",
              description: "\")\""
            },
            peg$c274 = "{",
            peg$c275 = {
              type: "literal",
              value: "{",
              description: "\"{\""
            },
            peg$c276 = "}",
            peg$c277 = {
              type: "literal",
              value: "}",
              description: "\"}\""
            },
            peg$c278 = "->",
            peg$c279 = {
              type: "literal",
              value: "->",
              description: "\"->\""
            },
            peg$c280 = "++",
            peg$c281 = {
              type: "literal",
              value: "++",
              description: "\"++\""
            },
            peg$c282 = "--",
            peg$c283 = {
              type: "literal",
              value: "--",
              description: "\"--\""
            },
            peg$c284 = "&",
            peg$c285 = {
              type: "literal",
              value: "&",
              description: "\"&\""
            },
            peg$c286 = /^[&]/,
            peg$c287 = {
              type: "class",
              value: "[&]",
              description: "[&]"
            },
            peg$c288 = "*",
            peg$c289 = {
              type: "literal",
              value: "*",
              description: "\"*\""
            },
            peg$c290 = /^[=]/,
            peg$c291 = {
              type: "class",
              value: "[=]",
              description: "[=]"
            },
            peg$c292 = "+",
            peg$c293 = {
              type: "literal",
              value: "+",
              description: "\"+\""
            },
            peg$c294 = /^[+=]/,
            peg$c295 = {
              type: "class",
              value: "[+=]",
              description: "[+=]"
            },
            peg$c296 = "-",
            peg$c297 = {
              type: "literal",
              value: "-",
              description: "\"-\""
            },
            peg$c298 = /^[\-=>]/,
            peg$c299 = {
              type: "class",
              value: "[\\-=>]",
              description: "[\\-=>]"
            },
            peg$c300 = "~",
            peg$c301 = {
              type: "literal",
              value: "~",
              description: "\"~\""
            },
            peg$c302 = "!",
            peg$c303 = {
              type: "literal",
              value: "!",
              description: "\"!\""
            },
            peg$c304 = "/",
            peg$c305 = {
              type: "literal",
              value: "/",
              description: "\"/\""
            },
            peg$c306 = "%",
            peg$c307 = {
              type: "literal",
              value: "%",
              description: "\"%\""
            },
            peg$c308 = /^[=>]/,
            peg$c309 = {
              type: "class",
              value: "[=>]",
              description: "[=>]"
            },
            peg$c310 = "<<",
            peg$c311 = {
              type: "literal",
              value: "<<",
              description: "\"<<\""
            },
            peg$c312 = ">>",
            peg$c313 = {
              type: "literal",
              value: ">>",
              description: "\">>\""
            },
            peg$c314 = "<",
            peg$c315 = {
              type: "literal",
              value: "<",
              description: "\"<\""
            },
            peg$c316 = ">",
            peg$c317 = {
              type: "literal",
              value: ">",
              description: "\">\""
            },
            peg$c318 = "<=",
            peg$c319 = {
              type: "literal",
              value: "<=",
              description: "\"<=\""
            },
            peg$c320 = ">=",
            peg$c321 = {
              type: "literal",
              value: ">=",
              description: "\">=\""
            },
            peg$c322 = "==",
            peg$c323 = {
              type: "literal",
              value: "==",
              description: "\"==\""
            },
            peg$c324 = "!=",
            peg$c325 = {
              type: "literal",
              value: "!=",
              description: "\"!=\""
            },
            peg$c326 = "^",
            peg$c327 = {
              type: "literal",
              value: "^",
              description: "\"^\""
            },
            peg$c328 = "|",
            peg$c329 = {
              type: "literal",
              value: "|",
              description: "\"|\""
            },
            peg$c330 = "&&",
            peg$c331 = {
              type: "literal",
              value: "&&",
              description: "\"&&\""
            },
            peg$c332 = "||",
            peg$c333 = {
              type: "literal",
              value: "||",
              description: "\"||\""
            },
            peg$c334 = "?",
            peg$c335 = {
              type: "literal",
              value: "?",
              description: "\"?\""
            },
            peg$c336 = ":",
            peg$c337 = {
              type: "literal",
              value: ":",
              description: "\":\""
            },
            peg$c338 = /^[>]/,
            peg$c339 = {
              type: "class",
              value: "[>]",
              description: "[>]"
            },
            peg$c340 = ";",
            peg$c341 = {
              type: "literal",
              value: ";",
              description: "\";\""
            },
            peg$c342 = "...",
            peg$c343 = {
              type: "literal",
              value: "...",
              description: "\"...\""
            },
            peg$c344 = "=",
            peg$c345 = {
              type: "literal",
              value: "=",
              description: "\"=\""
            },
            peg$c346 = "*=",
            peg$c347 = {
              type: "literal",
              value: "*=",
              description: "\"*=\""
            },
            peg$c348 = "/=",
            peg$c349 = {
              type: "literal",
              value: "/=",
              description: "\"/=\""
            },
            peg$c350 = "%=",
            peg$c351 = {
              type: "literal",
              value: "%=",
              description: "\"%=\""
            },
            peg$c352 = "+=",
            peg$c353 = {
              type: "literal",
              value: "+=",
              description: "\"+=\""
            },
            peg$c354 = "-=",
            peg$c355 = {
              type: "literal",
              value: "-=",
              description: "\"-=\""
            },
            peg$c356 = "<<=",
            peg$c357 = {
              type: "literal",
              value: "<<=",
              description: "\"<<=\""
            },
            peg$c358 = ">>=",
            peg$c359 = {
              type: "literal",
              value: ">>=",
              description: "\">>=\""
            },
            peg$c360 = "&=",
            peg$c361 = {
              type: "literal",
              value: "&=",
              description: "\"&=\""
            },
            peg$c362 = "^=",
            peg$c363 = {
              type: "literal",
              value: "^=",
              description: "\"^=\""
            },
            peg$c364 = "|=",
            peg$c365 = {
              type: "literal",
              value: "|=",
              description: "\"|=\""
            },
            peg$c366 = ",",
            peg$c367 = {
              type: "literal",
              value: ",",
              description: "\",\""
            },
            peg$c368 = "::",
            peg$c369 = {
              type: "literal",
              value: "::",
              description: "\"::\""
            },
            peg$c370 = {
              type: "any",
              description: "any character"
            },
            peg$currPos = 0,
            peg$savedPos = 0,
            peg$posDetailsCache = [{
              line: 1,
              column: 1,
              seenCR: false
            }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description) {
          throw peg$buildException(null, [{
            type: "other",
            description: description
          }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function error(message) {
          throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
              p,
              ch;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };
            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }
        function peg$buildException(message, expected, found, location) {
          function cleanupExpected(expected) {
            var i = 1;
            expected.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              }).replace(/[\u0100-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              }).replace(/[\u1000-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
            }
            var expectedDescs = new Array(expected.length),
                expectedDesc,
                foundDesc,
                i;
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          if (expected !== null) {
            cleanupExpected(expected);
          }
          return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
        }
        function peg$parseTranslationUnit() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSpacing();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseExternalDeclaration();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseExternalDeclaration();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEOT();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExternalDeclaration() {
          var s0;
          s0 = peg$parseNamespace();
          if (s0 === peg$FAILED) {
            s0 = peg$parseTypedefDeclaration();
            if (s0 === peg$FAILED) {
              s0 = peg$parseFunctionDefinition();
              if (s0 === peg$FAILED) {
                s0 = peg$parseDeclaration();
              }
            }
          }
          return s0;
        }
        function peg$parseNamespace() {
          var s0;
          s0 = peg$parseNamespaceDefinition();
          if (s0 === peg$FAILED) {
            s0 = peg$parseUsingDirective();
            if (s0 === peg$FAILED) {
              s0 = peg$parseUsingDeclaration();
              if (s0 === peg$FAILED) {
                s0 = peg$parseNamespaceAliasDefinition();
              }
            }
          }
          return s0;
        }
        function peg$parseNamespaceDefinition() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseNAMESPACE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLWING();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseExternalDeclaration();
                if (s5 !== peg$FAILED) {
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseExternalDeclaration();
                  }
                } else {
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseRWING();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c1(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUsingDirective() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseUSING();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseNAMESPACE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseScopedIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseSEMI();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c2(s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUsingDeclaration() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseUSING();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseScopedIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSCOPEOP();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseIdentifier();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c3(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNamespaceAliasDefinition() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseNAMESPACE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEQU();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseScopedIdentifier();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c4(s2, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypedefDeclaration() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          s1 = peg$parseTYPEDEF();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDeclarationSpecifiers();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$currPos;
                s6 = peg$parseCOMMA();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseDeclarator();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s5;
                    s6 = peg$c5(s7, s3);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$currPos;
                  s6 = peg$parseCOMMA();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseDeclarator();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c5(s7, s3);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSEMI();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s2, s3, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFunctionDefinition() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseFunctionDirectDeclarator();
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseSEMI();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c7(s1, s2);
              }
              s3 = s4;
              if (s3 === peg$FAILED) {
                s3 = peg$parseCompoundStatement();
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c8(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarationList() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseDeclaration();
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseDeclaration();
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStatementORDeclaration() {
          var s0;
          s0 = peg$parseStatement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseDeclaration();
          }
          return s0;
        }
        function peg$parseStatement() {
          var s0;
          s0 = peg$parseLabel();
          if (s0 === peg$FAILED) {
            s0 = peg$parseCompoundStatement();
            if (s0 === peg$FAILED) {
              s0 = peg$parseExpressionStatement();
              if (s0 === peg$FAILED) {
                s0 = peg$parseSelectionStatement();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseIterationStatement();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseJumpStatement();
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseLabel() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseCASE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseConditionalExpression();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseCOLON();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c10(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDEFAULT();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseCOLON();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c11();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseCompoundStatement() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseLWING();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseStatement();
            if (s3 === peg$FAILED) {
              s3 = peg$parseDeclaration();
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseStatement();
              if (s3 === peg$FAILED) {
                s3 = peg$parseDeclaration();
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseRWING();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExpressionStatement() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseExpression();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSEMI();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c13(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSelectionStatement() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$parseIF();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseStatement();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$currPos;
                    s7 = peg$parseELSE();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseStatement();
                      if (s8 !== peg$FAILED) {
                        s7 = [s7, s8];
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                    if (s6 === peg$FAILED) {
                      s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c14(s3, s5, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseSWITCH();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseLPAR();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseExpression();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRPAR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseStatement();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c15(s3, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseIterationStatement() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$parseWHILE();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseExpression();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseStatement();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c16(s3, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseDO();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseStatement();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseWHILE();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseLPAR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseExpression();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseRPAR();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseSEMI();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c17(s2, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseFOR();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseLPAR();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseDeclaration();
                  if (s3 === peg$FAILED) {
                    s3 = peg$parseExpressionStatement();
                  }
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parseExpression();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseSEMI();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseExpression();
                        if (s6 === peg$FAILED) {
                          s6 = null;
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseRPAR();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parseStatement();
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c18(s3, s4, s6, s8);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
          return s0;
        }
        function peg$parseJumpStatement() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseGOTO();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c19(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseCONTINUE();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseSEMI();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c20();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseBREAK();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseSEMI();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c21();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseRETURN();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseExpression();
                  if (s2 === peg$FAILED) {
                    s2 = null;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseSEMI();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c22(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          return s0;
        }
        function peg$parseDeclaration() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInitDeclaratorList();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c23(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarationSpecifiers() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = [];
          s3 = peg$parseStorageClassSpecifier();
          if (s3 === peg$FAILED) {
            s3 = peg$parseTypeQualifier();
            if (s3 === peg$FAILED) {
              s3 = peg$parseFunctionSpecifier();
            }
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseStorageClassSpecifier();
            if (s3 === peg$FAILED) {
              s3 = peg$parseTypeQualifier();
              if (s3 === peg$FAILED) {
                s3 = peg$parseFunctionSpecifier();
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseIdentifier();
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parseStorageClassSpecifier();
              if (s5 === peg$FAILED) {
                s5 = peg$parseTypeQualifier();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseFunctionSpecifier();
                }
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseStorageClassSpecifier();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseTypeQualifier();
                  if (s5 === peg$FAILED) {
                    s5 = peg$parseFunctionSpecifier();
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c24(s2, s3, s4);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c25(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$currPos;
            s3 = peg$parseStorageClassSpecifier();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c26(s3);
            }
            s2 = s3;
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseTypeSpecifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c26(s3);
              }
              s2 = s3;
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseTypeQualifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c26(s3);
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseFunctionSpecifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c26(s3);
                  }
                  s2 = s3;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$currPos;
                s3 = peg$parseStorageClassSpecifier();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c26(s3);
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  s3 = peg$parseTypeSpecifier();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c26(s3);
                  }
                  s2 = s3;
                  if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseTypeQualifier();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c26(s3);
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      s3 = peg$parseFunctionSpecifier();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c26(s3);
                      }
                      s2 = s3;
                    }
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseInitDeclaratorList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseInitDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInitDeclarator();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s1, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInitDeclarator();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c28(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInitDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseEQU();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseInitializer();
              if (s4 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c28(s1, s4);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c30(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStorageClassSpecifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$parseEXTERN();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSTATIC();
            if (s1 === peg$FAILED) {
              s1 = peg$parseAUTO();
              if (s1 === peg$FAILED) {
                s1 = peg$parseREGISTER();
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  s2 = peg$parseATTRIBUTE();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseLPAR();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$currPos;
                        s7 = peg$currPos;
                        peg$silentFails++;
                        s8 = peg$parseRPAR();
                        peg$silentFails--;
                        if (s8 === peg$FAILED) {
                          s7 = void 0;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$FAILED;
                        }
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                        while (s6 !== peg$FAILED) {
                          s5.push(s6);
                          s6 = peg$currPos;
                          s7 = peg$currPos;
                          peg$silentFails++;
                          s8 = peg$parseRPAR();
                          peg$silentFails--;
                          if (s8 === peg$FAILED) {
                            s7 = void 0;
                          } else {
                            peg$currPos = s7;
                            s7 = peg$FAILED;
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parse_();
                            if (s8 !== peg$FAILED) {
                              s7 = [s7, s8];
                              s6 = s7;
                            } else {
                              peg$currPos = s6;
                              s6 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parseRPAR();
                            if (s7 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseTypeSpecifier() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseVOID();
          if (s1 === peg$FAILED) {
            s1 = peg$parseCHAR();
            if (s1 === peg$FAILED) {
              s1 = peg$parseSHORT();
              if (s1 === peg$FAILED) {
                s1 = peg$parseINT();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseLONG();
                  if (s1 === peg$FAILED) {
                    s1 = peg$parseFLOAT();
                    if (s1 === peg$FAILED) {
                      s1 = peg$parseDOUBLE();
                      if (s1 === peg$FAILED) {
                        s1 = peg$parseSIGNED();
                        if (s1 === peg$FAILED) {
                          s1 = peg$parseUNSIGNED();
                          if (s1 === peg$FAILED) {
                            s1 = peg$parseBOOL();
                            if (s1 === peg$FAILED) {
                              s1 = peg$parseCOMPLEX();
                              if (s1 === peg$FAILED) {
                                s1 = peg$parseStructOrUnionSpecifier();
                                if (s1 === peg$FAILED) {
                                  s1 = peg$parseEnumSpecifier();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStructOrUnionSpecifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parseStructOrUnion();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseIdentifier();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseLWING();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseStructDeclaration();
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseStructDeclaration();
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRWING();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c27(s3);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseIdentifier();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStructOrUnion() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseSTRUCT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseUNION();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseStructDeclaration() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSpecifierQualifierList();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseStructDeclaratorList();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSEMI();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSpecifierQualifierList() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseTypeQualifier();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseTypeQualifier();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseTypeQualifier();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseTypeQualifier();
              }
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = [];
            s1 = peg$parseTypeSpecifier();
            if (s1 === peg$FAILED) {
              s1 = peg$parseTypeQualifier();
            }
            if (s1 !== peg$FAILED) {
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                s1 = peg$parseTypeSpecifier();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseTypeQualifier();
                }
              }
            } else {
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseStructDeclaratorList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseStructDeclarator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseStructDeclarator();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseStructDeclarator();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStructDeclarator() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseDeclarator();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseCOLON();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseConditionalExpression();
              if (s3 !== peg$FAILED) {
                s1 = [s1, s2, s3];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseDeclarator();
          }
          return s0;
        }
        function peg$parseEnumSpecifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          s1 = peg$parseENUM();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseIdentifier();
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseLWING();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEnumeratorList();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseCOMMA();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRWING();
                    if (s7 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6, s7];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$parseIdentifier();
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEnumeratorList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseEnumerator();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEnumerator();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEnumerator();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEnumerator() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseEnumerationConstant();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseEQU();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseConditionalExpression();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypeQualifier() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseCONST();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseFunctionSpecifier() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseINLINE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseSTDCALL();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c31(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseFunctionDirectDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c32(s2);
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseLPAR();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseParameterTypeList();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRPAR();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c33(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDeclarator() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parsePointer();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDirectDeclarator();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDirectDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseIdentifier();
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c32(s2);
          }
          s1 = s2;
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDeclarator();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseTypeQualifier();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseTypeQualifier();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseAssignmentExpression();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseRBRK();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c36(s5, s6);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSTATIC();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parseTypeQualifier();
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parseTypeQualifier();
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseAssignmentExpression();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseRBRK();
                      if (s8 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c37(s6, s7);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLBRK();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseTypeQualifier();
                  if (s6 !== peg$FAILED) {
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseTypeQualifier();
                    }
                  } else {
                    s5 = peg$FAILED;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSTATIC();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseAssignmentExpression();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseRBRK();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c37(s5, s7);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseLBRK();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseTypeQualifier();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseTypeQualifier();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseSTAR();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseRBRK();
                        if (s7 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c38(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseLPAR();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseParameterTypeList();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseRPAR();
                        if (s6 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c33(s5);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parseIdentifierList();
                        if (s5 === peg$FAILED) {
                          s5 = null;
                        }
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c39(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    }
                  }
                }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$parseTypeQualifier();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseTypeQualifier();
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseAssignmentExpression();
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseRBRK();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c36(s5, s6);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLBRK();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSTATIC();
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parseTypeQualifier();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parseTypeQualifier();
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseAssignmentExpression();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseRBRK();
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c37(s6, s7);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseLBRK();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseTypeQualifier();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseTypeQualifier();
                      }
                    } else {
                      s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseSTATIC();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseAssignmentExpression();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parseRBRK();
                          if (s8 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c37(s5, s7);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseLBRK();
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseTypeQualifier();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseTypeQualifier();
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parseSTAR();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parseRBRK();
                          if (s7 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c38(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseLPAR();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parseParameterTypeList();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parseRPAR();
                          if (s6 !== peg$FAILED) {
                            peg$savedPos = s3;
                            s4 = peg$c33(s5);
                            s3 = s4;
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseLPAR();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parseIdentifierList();
                          if (s5 === peg$FAILED) {
                            s5 = null;
                          }
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parseRPAR();
                            if (s6 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s4 = peg$c39(s5);
                              s3 = s4;
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s3;
                          s3 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c34(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePointer() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = [];
          s1 = peg$currPos;
          s2 = peg$parseSTAR();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parseTypeQualifier();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseTypeQualifier();
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s1;
              s2 = peg$c26(s3);
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            while (s1 !== peg$FAILED) {
              s0.push(s1);
              s1 = peg$currPos;
              s2 = peg$parseSTAR();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseTypeQualifier();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseTypeQualifier();
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c26(s3);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          } else {
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterTypeList() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseParameterList();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseCOMMA();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseELLIPSIS();
              if (s4 !== peg$FAILED) {
                s3 = [s3, s4];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c40(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseParameterDeclaration();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseParameterDeclaration();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseParameterDeclaration();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c41(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseParameterDeclaration() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseDeclarationSpecifiers();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDeclarator();
            if (s2 === peg$FAILED) {
              s2 = peg$parseAbstractDeclarator();
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c42(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifierList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseIdentifier();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c28(s1, s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseIdentifier();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c28(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c29(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTypeName() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseSpecifierQualifierList();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAbstractDeclarator();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c43(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAbstractDeclarator() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parsePointer();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDirectAbstractDeclarator();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c35(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePointer();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseDirectAbstractDeclarator() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseLPAR();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseAbstractDeclarator();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseRPAR();
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$parseLBRK();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAssignmentExpression();
              if (s3 === peg$FAILED) {
                s3 = peg$parseSTAR();
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRBRK();
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              s2 = peg$parseLPAR();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseParameterTypeList();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRPAR();
                  if (s4 !== peg$FAILED) {
                    s2 = [s2, s3, s4];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 === peg$FAILED) {
                s5 = peg$parseSTAR();
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRK();
                if (s6 !== peg$FAILED) {
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLPAR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseParameterTypeList();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRPAR();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseSTAR();
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRBRK();
                  if (s6 !== peg$FAILED) {
                    s4 = [s4, s5, s6];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseParameterTypeList();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRPAR();
                    if (s6 !== peg$FAILED) {
                      s4 = [s4, s5, s6];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInitializer() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c45(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLWING();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseInitializerList();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseCOMMA();
                if (s3 === peg$FAILED) {
                  s3 = null;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseRWING();
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c46(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseInitializerList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseInitializer();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInitializer();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s5);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInitializer();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrimaryExpression() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c48(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseConstant();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c49(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseStringLiteral();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseLPAR();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseExpression();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseRPAR();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c51(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
          return s0;
        }
        function peg$parsePostfixExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parsePrimaryExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLBRK();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseRBRK();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c52(s1, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseLPAR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseArgumentExpressionList();
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRPAR();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c53(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseDOT();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseIdentifier();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c54(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parsePTR();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseIdentifier();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c55(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseINC();
                    if (s4 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c56(s1, s4);
                    }
                    s3 = s4;
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseDEC();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c57(s1, s4);
                      }
                      s3 = s4;
                    }
                  }
                }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLBRK();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseRBRK();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c52(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseLPAR();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseArgumentExpressionList();
                  if (s5 === peg$FAILED) {
                    s5 = null;
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseRPAR();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c53(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parseDOT();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseIdentifier();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c54(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parsePTR();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parseIdentifier();
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c55(s1, s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                      s3 = peg$currPos;
                      s4 = peg$parseINC();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c56(s1, s4);
                      }
                      s3 = s4;
                      if (s3 === peg$FAILED) {
                        s3 = peg$currPos;
                        s4 = peg$parseDEC();
                        if (s4 !== peg$FAILED) {
                          peg$savedPos = s3;
                          s4 = peg$c57(s1, s4);
                        }
                        s3 = s4;
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c58(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseArgumentExpressionList() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUnaryExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$parsePostfixExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseINC();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseUnaryExpression();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c60(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseDEC();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseUnaryExpression();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseUnaryOperator();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseCastExpression();
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c62(s1, s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseSIZEOF();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$currPos;
                    s3 = peg$parseUnaryExpression();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c63(s3);
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      s3 = peg$parseLPAR();
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parseTypeName();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parseRPAR();
                          if (s5 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c64(s4);
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    }
                    if (s2 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c26(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUnaryOperator() {
          var s0;
          s0 = peg$parseAND();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSTAR();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePLUS();
              if (s0 === peg$FAILED) {
                s0 = peg$parseMINUS();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseTILDA();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseBANG();
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseCastExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$parseUnaryExpression();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseLPAR();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseTypeName();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  s2 = [s2, s3, s4];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseCastExpression();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c65(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseMultiplicativeExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseCastExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseSTAR();
            if (s4 === peg$FAILED) {
              s4 = peg$parseDIV();
              if (s4 === peg$FAILED) {
                s4 = peg$parseMOD();
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseCastExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseSTAR();
              if (s4 === peg$FAILED) {
                s4 = peg$parseDIV();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseMOD();
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseCastExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAdditiveExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseMultiplicativeExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parsePLUS();
            if (s4 === peg$FAILED) {
              s4 = peg$parseMINUS();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMultiplicativeExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parsePLUS();
              if (s4 === peg$FAILED) {
                s4 = peg$parseMINUS();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseMultiplicativeExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseShiftExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseAdditiveExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLEFT();
            if (s4 === peg$FAILED) {
              s4 = peg$parseRIGHT();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAdditiveExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLEFT();
              if (s4 === peg$FAILED) {
                s4 = peg$parseRIGHT();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAdditiveExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRelationalExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseShiftExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseLE();
            if (s4 === peg$FAILED) {
              s4 = peg$parseGE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseLT();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseGT();
                }
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseShiftExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseLE();
              if (s4 === peg$FAILED) {
                s4 = peg$parseGE();
                if (s4 === peg$FAILED) {
                  s4 = peg$parseLT();
                  if (s4 === peg$FAILED) {
                    s4 = peg$parseGT();
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseShiftExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEqualityExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseRelationalExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseEQUEQU();
            if (s4 === peg$FAILED) {
              s4 = peg$parseBANGEQU();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseRelationalExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseEQUEQU();
              if (s4 === peg$FAILED) {
                s4 = peg$parseBANGEQU();
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parseRelationalExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseEqualityExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseAND();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseEqualityExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseAND();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseEqualityExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseExclusiveORExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseANDExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseHAT();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseANDExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseHAT();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseANDExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInclusiveORExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseExclusiveORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseOR();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExclusiveORExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseOR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExclusiveORExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLogicalANDExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseInclusiveORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseANDAND();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInclusiveORExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseANDAND();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseInclusiveORExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLogicalORExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseLogicalANDExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseOROR();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseLogicalANDExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseOROR();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseLogicalANDExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseConditionalExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          s1 = peg$parseLogicalORExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseQUERY();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseExpression();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseCOLON();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseLogicalORExpression();
                  if (s7 !== peg$FAILED) {
                    s4 = [s4, s5, s6, s7];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseQUERY();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseExpression();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseCOLON();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseLogicalORExpression();
                    if (s7 !== peg$FAILED) {
                      s4 = [s4, s5, s6, s7];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c67(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAssignmentExpression() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseUnaryExpression();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseAssignmentOperator();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseAssignmentExpression();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c68(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseConditionalExpression();
          }
          return s0;
        }
        function peg$parseAssignmentOperator() {
          var s0;
          s0 = peg$parseEQU();
          if (s0 === peg$FAILED) {
            s0 = peg$parseSTAREQU();
            if (s0 === peg$FAILED) {
              s0 = peg$parseDIVEQU();
              if (s0 === peg$FAILED) {
                s0 = peg$parseMODEQU();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsePLUSEQU();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseMINUSEQU();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseLEFTEQU();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseRIGHTEQU();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseANDEQU();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseHATEQU();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseOREQU();
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseExpression() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseAssignmentExpression();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseCOMMA();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignmentExpression();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseCOMMA();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseAssignmentExpression();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c66(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSpacing() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c69(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseWhiteSpace() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c70.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c71);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseLongComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c72) {
            s1 = peg$c72;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c73);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c74) {
              s5 = peg$c74;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c75);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c74) {
                s5 = peg$c74;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c74) {
                s3 = peg$c74;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c75);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLineComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c79;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c80);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c79;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c80);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c76(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAUTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBREAK() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCASE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCHAR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c87) {
            s1 = peg$c87;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONST() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONTINUE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFAULT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c94);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENUM() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEXTERN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFLOAT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c105) {
            s1 = peg$c105;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFOR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c107) {
            s1 = peg$c107;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c108);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGOTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c109) {
            s1 = peg$c109;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c110);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c111) {
            s1 = peg$c111;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINLINE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLONG() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c117) {
            s1 = peg$c117;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c118);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseREGISTER() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c119) {
            s1 = peg$c119;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRESTRICT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRETURN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c123) {
            s1 = peg$c123;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHORT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c125) {
            s1 = peg$c125;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c127) {
            s1 = peg$c127;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c128);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIZEOF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c129) {
            s1 = peg$c129;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c130);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTATIC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c131) {
            s1 = peg$c131;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c132);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRUCT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c133) {
            s1 = peg$c133;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSWITCH() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c135) {
            s1 = peg$c135;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c136);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTYPEDEF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c137) {
            s1 = peg$c137;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c138);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNION() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c139) {
            s1 = peg$c139;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c140);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c141) {
            s1 = peg$c141;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c142);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOID() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c143) {
            s1 = peg$c143;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c144);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOLATILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c145) {
            s1 = peg$c145;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c146);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseWHILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c147) {
            s1 = peg$c147;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c148);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOOL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c149) {
            s1 = peg$c149;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c150);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMPLEX() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c151) {
            s1 = peg$c151;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c152);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTDCALL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c153) {
            s1 = peg$c153;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c154);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDECLSPEC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c155) {
            s1 = peg$c155;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c156);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseATTRIBUTE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 13) === peg$c157) {
            s1 = peg$c157;
            peg$currPos += 13;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNAMESPACE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 9) === peg$c159) {
            s1 = peg$c159;
            peg$currPos += 9;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c160);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUSING() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c161) {
            s1 = peg$c161;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c162);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTRUE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c163) {
            s1 = peg$c163;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c164);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFALSE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c165) {
            s1 = peg$c165;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c166);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseKeyword() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c83) {
              s1 = peg$c83;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c85) {
                s1 = peg$c85;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c86);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c87) {
                  s1 = peg$c87;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c88);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c89) {
                    s1 = peg$c89;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c90);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c91) {
                      s1 = peg$c91;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c92);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c93) {
                        s1 = peg$c93;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c94);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c95) {
                          s1 = peg$c95;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c96);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c97) {
                            s1 = peg$c97;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c98);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c99) {
                              s1 = peg$c99;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c100);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c101) {
                                s1 = peg$c101;
                                peg$currPos += 4;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c102);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c103) {
                                  s1 = peg$c103;
                                  peg$currPos += 6;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c104);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c105) {
                                    s1 = peg$c105;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c106);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c107) {
                                      s1 = peg$c107;
                                      peg$currPos += 3;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c108);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c109) {
                                        s1 = peg$c109;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c110);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c111) {
                                          s1 = peg$c111;
                                          peg$currPos += 2;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c112);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 3) === peg$c113) {
                                            s1 = peg$c113;
                                            peg$currPos += 3;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c114);
                                            }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c115) {
                                              s1 = peg$c115;
                                              peg$currPos += 6;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c116);
                                              }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4) === peg$c117) {
                                                s1 = peg$c117;
                                                peg$currPos += 4;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c118);
                                                }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c119) {
                                                  s1 = peg$c119;
                                                  peg$currPos += 8;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c120);
                                                  }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 8) === peg$c121) {
                                                    s1 = peg$c121;
                                                    peg$currPos += 8;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c122);
                                                    }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c123) {
                                                      s1 = peg$c123;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c124);
                                                      }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c125) {
                                                        s1 = peg$c125;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c126);
                                                        }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c127) {
                                                          s1 = peg$c127;
                                                          peg$currPos += 6;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c128);
                                                          }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 6) === peg$c129) {
                                                            s1 = peg$c129;
                                                            peg$currPos += 6;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c130);
                                                            }
                                                          }
                                                          if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 6) === peg$c131) {
                                                              s1 = peg$c131;
                                                              peg$currPos += 6;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c132);
                                                              }
                                                            }
                                                            if (s1 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 6) === peg$c133) {
                                                                s1 = peg$c133;
                                                                peg$currPos += 6;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c134);
                                                                }
                                                              }
                                                              if (s1 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 6) === peg$c135) {
                                                                  s1 = peg$c135;
                                                                  peg$currPos += 6;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c136);
                                                                  }
                                                                }
                                                                if (s1 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 7) === peg$c137) {
                                                                    s1 = peg$c137;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                      peg$fail(peg$c138);
                                                                    }
                                                                  }
                                                                  if (s1 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 5) === peg$c139) {
                                                                      s1 = peg$c139;
                                                                      peg$currPos += 5;
                                                                    } else {
                                                                      s1 = peg$FAILED;
                                                                      if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c140);
                                                                      }
                                                                    }
                                                                    if (s1 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 8) === peg$c141) {
                                                                        s1 = peg$c141;
                                                                        peg$currPos += 8;
                                                                      } else {
                                                                        s1 = peg$FAILED;
                                                                        if (peg$silentFails === 0) {
                                                                          peg$fail(peg$c142);
                                                                        }
                                                                      }
                                                                      if (s1 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c143) {
                                                                          s1 = peg$c143;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s1 = peg$FAILED;
                                                                          if (peg$silentFails === 0) {
                                                                            peg$fail(peg$c144);
                                                                          }
                                                                        }
                                                                        if (s1 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 8) === peg$c145) {
                                                                            s1 = peg$c145;
                                                                            peg$currPos += 8;
                                                                          } else {
                                                                            s1 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                              peg$fail(peg$c146);
                                                                            }
                                                                          }
                                                                          if (s1 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 5) === peg$c147) {
                                                                              s1 = peg$c147;
                                                                              peg$currPos += 5;
                                                                            } else {
                                                                              s1 = peg$FAILED;
                                                                              if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c148);
                                                                              }
                                                                            }
                                                                            if (s1 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 5) === peg$c149) {
                                                                                s1 = peg$c149;
                                                                                peg$currPos += 5;
                                                                              } else {
                                                                                s1 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                  peg$fail(peg$c150);
                                                                                }
                                                                              }
                                                                              if (s1 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 8) === peg$c151) {
                                                                                  s1 = peg$c151;
                                                                                  peg$currPos += 8;
                                                                                } else {
                                                                                  s1 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$c152);
                                                                                  }
                                                                                }
                                                                                if (s1 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 10) === peg$c167) {
                                                                                    s1 = peg$c167;
                                                                                    peg$currPos += 10;
                                                                                  } else {
                                                                                    s1 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) {
                                                                                      peg$fail(peg$c168);
                                                                                    }
                                                                                  }
                                                                                  if (s1 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 8) === peg$c153) {
                                                                                      s1 = peg$c153;
                                                                                      peg$currPos += 8;
                                                                                    } else {
                                                                                      s1 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) {
                                                                                        peg$fail(peg$c154);
                                                                                      }
                                                                                    }
                                                                                    if (s1 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 10) === peg$c155) {
                                                                                        s1 = peg$c155;
                                                                                        peg$currPos += 10;
                                                                                      } else {
                                                                                        s1 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) {
                                                                                          peg$fail(peg$c156);
                                                                                        }
                                                                                      }
                                                                                      if (s1 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 13) === peg$c157) {
                                                                                          s1 = peg$c157;
                                                                                          peg$currPos += 13;
                                                                                        } else {
                                                                                          s1 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) {
                                                                                            peg$fail(peg$c158);
                                                                                          }
                                                                                        }
                                                                                        if (s1 === peg$FAILED) {
                                                                                          if (input.substr(peg$currPos, 9) === peg$c159) {
                                                                                            s1 = peg$c159;
                                                                                            peg$currPos += 9;
                                                                                          } else {
                                                                                            s1 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) {
                                                                                              peg$fail(peg$c160);
                                                                                            }
                                                                                          }
                                                                                          if (s1 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 5) === peg$c161) {
                                                                                              s1 = peg$c161;
                                                                                              peg$currPos += 5;
                                                                                            } else {
                                                                                              s1 = peg$FAILED;
                                                                                              if (peg$silentFails === 0) {
                                                                                                peg$fail(peg$c162);
                                                                                              }
                                                                                            }
                                                                                            if (s1 === peg$FAILED) {
                                                                                              if (input.substr(peg$currPos, 4) === peg$c163) {
                                                                                                s1 = peg$c163;
                                                                                                peg$currPos += 4;
                                                                                              } else {
                                                                                                s1 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) {
                                                                                                  peg$fail(peg$c164);
                                                                                                }
                                                                                              }
                                                                                              if (s1 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 5) === peg$c165) {
                                                                                                  s1 = peg$c165;
                                                                                                  peg$currPos += 5;
                                                                                                } else {
                                                                                                  s1 = peg$FAILED;
                                                                                                  if (peg$silentFails === 0) {
                                                                                                    peg$fail(peg$c166);
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseScopedIdentifier() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSCOPEOP();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parseIdentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseSCOPEOP();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s3;
                s4 = peg$c26(s4);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$parseIdentifier();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSCOPEOP();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c26(s4);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c169(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifier() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseKeyword();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdNondigit();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIdChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIdChar();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseSpacing();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c170(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdNondigit() {
          var s0;
          if (peg$c171.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c173.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c175.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c176);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseUniversalCharacter();
              }
            }
          }
          return s0;
        }
        function peg$parseIdChar() {
          var s0;
          if (peg$c171.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c172);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c173.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s0 === peg$FAILED) {
                if (peg$c175.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c176);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseUniversalCharacter();
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUniversalCharacter() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c179) {
            s1 = peg$c179;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c180);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexQuad();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c181) {
              s1 = peg$c181;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c182);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseHexQuad();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseHexQuad();
                if (s3 !== peg$FAILED) {
                  s1 = [s1, s2, s3];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexQuad() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseHexDigit();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHexDigit();
                if (s4 !== peg$FAILED) {
                  s1 = [s1, s2, s3, s4];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseConstant() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseIntegerConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseEnumerationConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseCharacterConstant();
                if (s1 === peg$FAILED) {
                  s1 = peg$parseBooleanConstant();
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseBooleanConstant() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseTRUE();
          if (s1 === peg$FAILED) {
            s1 = peg$parseFALSE();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c183(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseIntegerConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseDecimalConstant();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexConstant();
              if (s1 === peg$FAILED) {
                s1 = peg$parseOctalConstant();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIntegerSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (peg$c184.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c185);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c186(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c187;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c188);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c189.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c190);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c189.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c190);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c191(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c192(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c193) {
            s0 = peg$c193;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c194);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c195) {
              s0 = peg$c195;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c196);
              }
            }
          }
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c197.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c198);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c199.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c200);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseBinaryPrefix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c201) {
            s0 = peg$c201;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c202);
            }
          }
          return s0;
        }
        function peg$parseBinaryDigit() {
          var s0;
          if (peg$c203.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c204);
            }
          }
          return s0;
        }
        function peg$parseBinaryConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseBinaryPrefix();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseBinaryDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseBinaryDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c205(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIntegerSuffix() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (peg$c206.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c207);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseLsuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseLsuffix();
            if (s1 !== peg$FAILED) {
              if (peg$c206.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c207);
                }
              }
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLsuffix() {
          var s0;
          if (input.substr(peg$currPos, 2) === peg$c208) {
            s0 = peg$c208;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c209);
            }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c210) {
              s0 = peg$c210;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c211);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c212.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c213);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseFloatConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseDecimalFloatConstant();
          if (s1 === peg$FAILED) {
            s1 = peg$parseHexFloatConstant();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseFloatSuffix();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c214(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDecimalFloatConstant() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseFraction();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseExponent();
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c215(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c177.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseExponent();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c216(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFloatConstant() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseHexPrefix();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexFraction();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseBinaryExponent();
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c217(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseHexPrefix();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseHexDigit();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseHexDigit();
                }
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseBinaryExponent();
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c218(s1, s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseFraction() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = [];
          if (peg$c177.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c178);
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c219;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c220);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c221(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            if (peg$c177.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c178);
              }
            }
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c177.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c219;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c220);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c76(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexFraction() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseHexDigit();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseHexDigit();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s2 = peg$c219;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c220);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseHexDigit();
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c221(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseHexDigit();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseHexDigit();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s2 = peg$c219;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c220);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c222(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseExponent() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          if (peg$c223.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c224);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c225.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c226);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c227(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBinaryExponent() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          if (peg$c228.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c229);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c225.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c226);
              }
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$c177.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c178);
                }
              }
              if (s4 !== peg$FAILED) {
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                }
              } else {
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c230(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFloatSuffix() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c231.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c232);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseEnumerationConstant() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseIdentifier();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c233(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseCharacterConstant() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c234;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c235);
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c236;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c237);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseChar();
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s4 = peg$c236;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c237);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c238(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseChar() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseEscape();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c239.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c240);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseEscape() {
          var s0,
              s1;
          s0 = peg$currPos;
          s1 = peg$parseSimpleEscape();
          if (s1 === peg$FAILED) {
            s1 = peg$parseOctalEscape();
            if (s1 === peg$FAILED) {
              s1 = peg$parseHexEscape();
              if (s1 === peg$FAILED) {
                s1 = peg$parseUniversalCharacter();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSimpleEscape() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c241;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c242);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c243.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c244);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c245(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOctalEscape() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c241;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c242);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c189.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c190);
              }
            }
            if (s2 !== peg$FAILED) {
              if (peg$c189.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c190);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              if (s3 !== peg$FAILED) {
                if (peg$c189.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c190);
                  }
                }
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c246(s1, s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHexEscape() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c247) {
            s1 = peg$c247;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c248);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseHexDigit();
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c249(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringLiteral() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 76) {
            s1 = peg$c234;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c235);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c250) {
              s1 = peg$c250;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c251);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 117) {
                s1 = peg$c252;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c253);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 85) {
                  s1 = peg$c254;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c255);
                  }
                }
              }
            }
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseRawStringLiteral();
            if (s2 === peg$FAILED) {
              s2 = peg$parseEscapedStringLiteral();
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c256(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRawStringLiteral() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 82) {
            s1 = peg$c257;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c258);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            if (peg$c259.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c260);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseRawStringChar();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseRawStringChar();
              }
              if (s5 !== peg$FAILED) {
                if (peg$c259.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseSpacing();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c76(s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                if (peg$c259.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c260);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseRawStringChar();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseRawStringChar();
                  }
                  if (s5 !== peg$FAILED) {
                    if (peg$c259.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c260);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseSpacing();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s3;
                        s4 = peg$c76(s5);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c261(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEscapedStringLiteral() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          if (peg$c259.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c260);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseStringChar();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseStringChar();
            }
            if (s4 !== peg$FAILED) {
              if (peg$c259.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c260);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseSpacing();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c76(s4);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              if (peg$c259.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c260);
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseStringChar();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseStringChar();
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c259.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c260);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseSpacing();
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s2;
                      s3 = peg$c76(s4);
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c261(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseRawStringChar() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (peg$c262.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c263);
            }
          }
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseStringChar() {
          var s0,
              s1,
              s2;
          s0 = peg$parseEscape();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (peg$c264.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c265);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = void 0;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseLBRK() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c266;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c267);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRBRK() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 93) {
            s1 = peg$c268;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c269);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c270;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c271);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 41) {
            s1 = peg$c272;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c273);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLWING() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c274;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c275);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRWING() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 125) {
            s1 = peg$c276;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c277);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOT() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s1 = peg$c219;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c220);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePTR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c278) {
            s1 = peg$c278;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c279);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINC() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c280) {
            s1 = peg$c280;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c281);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEC() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c282) {
            s1 = peg$c282;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c283);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAND() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c284;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c285);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c286.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c287);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTAR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c288;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c289);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLUS() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c292;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c293);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c294.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c295);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMINUS() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c296;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c297);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c298.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c299);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTILDA() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c300;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c301);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBANG() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s1 = peg$c302;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c303);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDIV() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c304;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c305);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMOD() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 37) {
            s1 = peg$c306;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c307);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c308.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c309);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLEFT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c310) {
            s1 = peg$c310;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c311);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRIGHT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c312) {
            s1 = peg$c312;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c313);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c314;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c315);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c316;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c317);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c318) {
            s1 = peg$c318;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c319);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c320) {
            s1 = peg$c320;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c321);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEQUEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c322) {
            s1 = peg$c322;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c323);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBANGEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c324) {
            s1 = peg$c324;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c325);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHAT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 94) {
            s1 = peg$c326;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c327);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 124) {
            s1 = peg$c328;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c329);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c290.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c291);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDAND() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c330) {
            s1 = peg$c330;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c331);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOROR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c332) {
            s1 = peg$c332;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c333);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseQUERY() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 63) {
            s1 = peg$c334;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c335);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOLON() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c336;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c337);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c338.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c339);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSEMI() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 59) {
            s1 = peg$c340;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c341);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELLIPSIS() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c342) {
            s1 = peg$c342;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c343);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEQU() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c344;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c345);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c344;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c345);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c26(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTAREQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c346) {
            s1 = peg$c346;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c347);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDIVEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c348) {
            s1 = peg$c348;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c349);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMODEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c350) {
            s1 = peg$c350;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c351);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLUSEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c352) {
            s1 = peg$c352;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c353);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseMINUSEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c354) {
            s1 = peg$c354;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c355);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLEFTEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c356) {
            s1 = peg$c356;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c357);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRIGHTEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c358) {
            s1 = peg$c358;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c359);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseANDEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c360) {
            s1 = peg$c360;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c361);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseHATEQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c362) {
            s1 = peg$c362;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c363);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseOREQU() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c364) {
            s1 = peg$c364;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c365);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMMA() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c366;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c367);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSCOPEOP() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c368) {
            s1 = peg$c368;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c369);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c26(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOT() {
          var s0,
              s1;
          s0 = peg$currPos;
          peg$silentFails++;
          s1 = peg$parse_();
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_() {
          var s0;
          if (input.length > peg$currPos) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c370);
            }
          }
          return s0;
        }
        function buildRecursiveBinop(a, b) {
          var ret = a;
          for (var i = 0; i < b.length; i++) {
            ret = addPositionInfo({
              type: 'BinOpExpression',
              left: ret,
              op: b[i][0],
              right: b[i][1]
            });
          }
          return ret;
        }
        ;
        function addPositionInfo(r) {
          var posDetails = peg$computePosDetails(peg$currPos);
          r.eLine = posDetails.line;
          r.eColumn = posDetails.column;
          r.eOffset = peg$currPos;
          posDetails = peg$computePosDetails(peg$savedPos);
          r.sLine = posDetails.line;
          r.sColumn = posDetails.column;
          r.sOffset = peg$savedPos;
          return r;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: "end",
              description: "end of input"
            });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    })();
  }, {}],
  2: [function(require, module, exports) {
    var Debugger,
        Runtime;
    Runtime = require("./rt");
    Debugger = function() {
      this.src = "";
      this.prevNode = null;
      this.done = false;
      this.conditions = {
        isStatement: function(prevNode, newStmt) {
          return newStmt != null ? newStmt.type.indexOf("Statement" >= 0) : void 0;
        },
        positionChanged: function(prevNode, newStmt) {
          return (prevNode != null ? prevNode.eOffset : void 0) !== newStmt.eOffset || (prevNode != null ? prevNode.sOffset : void 0) !== newStmt.sOffset;
        },
        lineChanged: function(prevNode, newStmt) {
          return (prevNode != null ? prevNode.sLine : void 0) !== newStmt.sLine;
        }
      };
      this.stopConditions = {
        isStatement: false,
        positionChanged: false,
        lineChanged: true
      };
      return this;
    };
    Debugger.prototype.start = function(rt, gen) {
      this.rt = rt;
      return this.gen = gen;
    };
    Debugger.prototype["continue"] = function() {
      var active,
          curStmt,
          done,
          name,
          ref;
      while (true) {
        done = this.next();
        if (done !== false) {
          return done;
        }
        curStmt = this.nextNode();
        ref = this.stopConditions;
        for (name in ref) {
          active = ref[name];
          if (active) {
            if (this.conditions[name](this.prevNode, curStmt)) {
              return false;
            }
          }
        }
      }
    };
    Debugger.prototype.next = function() {
      var ngen;
      this.prevNode = this.nextNode();
      ngen = this.gen.next();
      if (ngen.done) {
        this.done = true;
        return ngen.value;
      } else {
        return false;
      }
    };
    Debugger.prototype.nextLine = function() {
      var s;
      s = this.nextNode();
      return this.src.slice(s.sOffset, s.eOffset).trim();
    };
    Debugger.prototype.nextNode = function() {
      if (this.done) {
        return {
          sOffset: -1,
          sLine: -1,
          sColumn: -1,
          eOffset: -1,
          eLine: -1,
          eColumn: -1
        };
      } else {
        return this.rt.interp.currentNode;
      }
    };
    Debugger.prototype.variable = function(name) {
      var i,
          ref,
          ref1,
          ret,
          scopeIndex,
          usedName,
          v,
          val;
      if (name) {
        v = this.rt.readVar(name);
        return {
          type: this.rt.makeTypeString(v.t),
          value: v.v
        };
      } else {
        usedName = new Set();
        ret = [];
        for (scopeIndex = i = ref = this.rt.scope.length - 1; i >= 0; scopeIndex = i += -1) {
          ref1 = this.rt.scope[scopeIndex];
          for (name in ref1) {
            val = ref1[name];
            if ((typeof val === 'undefined' ? 'undefined' : $traceurRuntime.typeof(val)) === "object" && "t" in val && "v" in val) {
              if (!usedName.has(name)) {
                usedName.add(name);
                ret.push({
                  name: name,
                  type: this.rt.makeTypeString(val.t),
                  value: this.rt.makeValueString(val)
                });
              }
            }
          }
        }
        return ret;
      }
    };
    module.exports = Debugger;
  }, {"./rt": 17}],
  3: [function(require, module, exports) {
    var slice = [].slice;
    module.exports = function() {
      var defaultOpHandler,
          defaults;
      defaults = this;
      this.config = {
        specifiers: ["const", "inline", "_stdcall", "extern", "static", "auto", "register"],
        charTypes: ["char", "signed char", "unsigned char", "wchar_t", "unsigned wchar_t", "char16_t", "unsigned char16_t", "char32_t", "unsigned char32_t"],
        intTypes: ["short", "short int", "signed short", "signed short int", "unsigned short", "unsigned short int", "int", "signed int", "unsigned", "unsigned int", "long", "long int", "long int", "signed long", "signed long int", "unsigned long", "unsigned long int", "long long", "long long int", "long long int", "signed long long", "signed long long int", "unsigned long long", "unsigned long long int", "bool"],
        limits: {
          "char": {
            max: 0x7f,
            min: 0x00,
            bytes: 1
          },
          "signed char": {
            max: 0x7f,
            min: -0x80,
            bytes: 1
          },
          "unsigned char": {
            max: 0xff,
            min: 0x00,
            bytes: 1
          },
          "wchar_t": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned wchar_t": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "char16_t": {
            max: 0x7fff,
            min: -0x8000,
            bytes: 4
          },
          "unsigned char16_t": {
            max: 0xffff,
            min: 0x0000,
            bytes: 4
          },
          "char32_t": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned char32_t": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "short": {
            max: 0x7fff,
            min: -0x8000,
            bytes: 2
          },
          "unsigned short": {
            max: 0xffff,
            min: 0x0000,
            bytes: 2
          },
          "int": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "long": {
            max: 0x7fffffff,
            min: -0x80000000,
            bytes: 4
          },
          "unsigned long": {
            max: 0xffffffff,
            min: 0x00000000,
            bytes: 4
          },
          "long long": {
            max: 0x7fffffffffffffff,
            min: -0x8000000000000000,
            bytes: 8
          },
          "unsigned long long": {
            max: 0xffffffffffffffff,
            min: 0x0000000000000000,
            bytes: 8
          },
          "float": {
            max: 3.40282346638529e+038,
            min: -3.40282346638529e+038,
            bytes: 4
          },
          "double": {
            max: 1.79769313486232e+308,
            min: -1.79769313486232e+308,
            bytes: 8
          },
          "pointer": {
            max: void 0,
            min: void 0,
            bytes: 4
          },
          "bool": {
            max: 1,
            min: 0,
            bytes: 1
          }
        },
        loadedLibraries: []
      };
      this.config.limits["short int"] = this.config.limits["short"];
      this.config.limits["signed short"] = this.config.limits["short"];
      this.config.limits["signed short int"] = this.config.limits["short"];
      this.config.limits["unsigned short int"] = this.config.limits["unsigned short"];
      this.config.limits["signed int"] = this.config.limits["int"];
      this.config.limits["unsigned int"] = this.config.limits["unsigned"];
      this.config.limits["long int"] = this.config.limits["long"];
      this.config.limits["long int"] = this.config.limits["long"];
      this.config.limits["signed long"] = this.config.limits["long"];
      this.config.limits["signed long int"] = this.config.limits["long"];
      this.config.limits["unsigned long int"] = this.config.limits["unsigned long"];
      this.config.limits["long long int"] = this.config.limits["long long"];
      this.config.limits["long long int"] = this.config.limits["long long"];
      this.config.limits["signed long long"] = this.config.limits["long long"];
      this.config.limits["signed long long int"] = this.config.limits["long long"];
      this.config.limits["unsigned long long int"] = this.config.limits["unsigned long long"];
      this.numericTypeOrder = ["char", "signed char", "short", "short int", "signed short", "signed short int", "int", "signed int", "long", "long int", "long int", "signed long", "signed long int", "long long", "long long int", "long long int", "signed long long", "signed long long int", "float", "double"];
      defaultOpHandler = {
        "o(*)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support * on " + rt.makeTypeString(r.t));
            }
            ret = l.v * r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(/)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support / on " + rt.makeTypeString(r.t));
            }
            ret = l.v / r.v;
            if (rt.isIntegerType(l.t) && rt.isIntegerType(r.t)) {
              ret = Math.floor(ret);
            }
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(%)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support % on " + rt.makeTypeString(r.t));
            }
            ret = l.v % r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(+)": {"#default": function(rt, l, r) {
            var i,
                ret,
                rett;
            if (r === void 0) {
              return l;
            } else {
              if (!rt.isNumericType(r.t)) {
                rt.raiseException(rt.makeTypeString(l.t) + " does not support + on " + rt.makeTypeString(r.t));
              }
              if (rt.isArrayType(r.t)) {
                i = rt.cast(rt.intTypeLiteral, l).v;
                return rt.val(r.t, rt.makeArrayPointerValue(r.v.target, r.v.position + i));
              } else {
                ret = l.v + r.v;
                rett = rt.promoteNumeric(l.t, r.t);
                return rt.val(rett, ret);
              }
            }
          }},
        "o(-)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (r === void 0) {
              rett = l.v > 0 ? rt.getSignedType(l.t) : l.t;
              return rt.val(rett, -l.v);
            } else {
              if (!rt.isNumericType(r.t)) {
                rt.raiseException(rt.makeTypeString(l.t) + " does not support - on " + rt.makeTypeString(r.t));
              }
              ret = l.v - r.v;
              rett = rt.promoteNumeric(l.t, r.t);
              return rt.val(rett, ret);
            }
          }},
        "o(<<)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support << on " + rt.makeTypeString(r.t));
            }
            ret = l.v << r.v;
            rett = l.t;
            return rt.val(rett, ret);
          }},
        "o(>>)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support >> on " + rt.makeTypeString(r.t));
            }
            ret = l.v >> r.v;
            rett = l.t;
            return rt.val(rett, ret);
          }},
        "o(<)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support < on " + rt.makeTypeString(r.t));
            }
            ret = l.v < r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(<=)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support <= on " + rt.makeTypeString(r.t));
            }
            ret = l.v <= r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(>)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support > on " + rt.makeTypeString(r.t));
            }
            ret = l.v > r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(>=)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support >= on " + rt.makeTypeString(r.t));
            }
            ret = l.v >= r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(==)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support == on " + rt.makeTypeString(r.t));
            }
            ret = l.v === r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(!=)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support != on " + rt.makeTypeString(r.t));
            }
            ret = l.v !== r.v;
            rett = rt.boolTypeLiteral;
            return rt.val(rett, ret);
          }},
        "o(&)": {"#default": function(rt, l, r) {
            var ret,
                rett,
                t;
            if (r === void 0) {
              if (l.array) {
                return rt.val(rt.arrayPointerType(l.t, l.array.length), rt.makeArrayPointerValue(l.array, l.arrayIndex));
              } else {
                t = rt.normalPointerType(l.t);
                return rt.val(t, rt.makeNormalPointerValue(l));
              }
            } else {
              if (!rt.isIntegerType(l.t) || !rt.isNumericType(r.t) || !rt.isIntegerType(r.t)) {
                rt.raiseException(rt.makeTypeString(l.t) + " does not support & on " + rt.makeTypeString(r.t));
              }
              ret = l.v & r.v;
              rett = rt.promoteNumeric(l.t, r.t);
              return rt.val(rett, ret);
            }
          }},
        "o(^)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support ^ on " + rt.makeTypeString(r.t));
            }
            ret = l.v ^ r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(|)": {"#default": function(rt, l, r) {
            var ret,
                rett;
            if (!rt.isNumericType(r.t) || !rt.isIntegerType(l.t) || !rt.isIntegerType(r.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support | on " + rt.makeTypeString(r.t));
            }
            ret = l.v | r.v;
            rett = rt.promoteNumeric(l.t, r.t);
            return rt.val(rett, ret);
          }},
        "o(,)": {"#default": function(rt, l, r) {
            return r;
          }},
        "o(=)": {"#default": function(rt, l, r) {
            if (l.left) {
              l.v = rt.cast(l.t, r).v;
              return l;
            } else {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
          }},
        "o(+=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(+)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(-=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(-)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(*=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(*)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(/=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(/)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(%=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(%)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(<<=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(<<)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(>>=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(>>)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(&=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(&)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(^=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(^)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(|=)": {"#default": function(rt, l, r) {
            r = defaultOpHandler["o(|)"]["#default"](rt, l, r);
            return defaultOpHandler["o(=)"]["#default"](rt, l, r);
          }},
        "o(++)": {"#default": function(rt, l, dummy) {
            var b;
            if (!rt.isNumericType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support increment");
            }
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              b = l.v;
              l.v = l.v + 1;
              if (rt.inrange(l.t, l.v)) {
                return rt.val(l.t, b);
              }
              rt.raiseException("overflow during post-increment " + (rt.makeValString(l)));
            } else {
              l.v = l.v + 1;
              if (rt.inrange(l.t, l.v)) {
                return l;
              }
              rt.raiseException("overflow during pre-increment " + (rt.makeValString(l)));
            }
          }},
        "o(--)": {"#default": function(rt, l, dummy) {
            var b;
            if (!rt.isNumericType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support decrement");
            }
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              b = l.v;
              l.v = l.v - 1;
              if (rt.inrange(l.t, l.v)) {
                return rt.val(l.t, b);
              }
              rt.raiseException("overflow during post-decrement");
            } else {
              l.v = l.v - 1;
              b = l.v;
              if (rt.inrange(l.t, l.v)) {
                return l;
              }
              rt.raiseException("overflow during pre-decrement");
            }
          }},
        "o(~)": {"#default": function(rt, l, dummy) {
            var ret,
                rett;
            if (!rt.isIntegerType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support ~ on itself");
            }
            ret = ~l.v;
            rett = rt.promoteNumeric(l.t, rt.intTypeLiteral);
            return rt.val(rett, ret);
          }},
        "o(!)": {"#default": function(rt, l, dummy) {
            var ret,
                rett;
            if (!rt.isIntegerType(l.t)) {
              rt.raiseException(rt.makeTypeString(l.t) + " does not support ! on itself");
            }
            ret = l.v ? 0 : 1;
            rett = l.t;
            return rt.val(rett, ret);
          }}
      };
      this.types = {"global": {}};
      this.types["(char)"] = defaultOpHandler;
      this.types["(signed char)"] = defaultOpHandler;
      this.types["(unsigned char)"] = defaultOpHandler;
      this.types["(short)"] = defaultOpHandler;
      this.types["(short int)"] = defaultOpHandler;
      this.types["(signed short)"] = defaultOpHandler;
      this.types["(signed short int)"] = defaultOpHandler;
      this.types["(unsigned short)"] = defaultOpHandler;
      this.types["(unsigned short int)"] = defaultOpHandler;
      this.types["(int)"] = defaultOpHandler;
      this.types["(signed int)"] = defaultOpHandler;
      this.types["(unsigned)"] = defaultOpHandler;
      this.types["(unsigned int)"] = defaultOpHandler;
      this.types["(long)"] = defaultOpHandler;
      this.types["(long int)"] = defaultOpHandler;
      this.types["(long int)"] = defaultOpHandler;
      this.types["(signed long)"] = defaultOpHandler;
      this.types["(signed long int)"] = defaultOpHandler;
      this.types["(unsigned long)"] = defaultOpHandler;
      this.types["(unsigned long int)"] = defaultOpHandler;
      this.types["(long long)"] = defaultOpHandler;
      this.types["(long long int)"] = defaultOpHandler;
      this.types["(long long int)"] = defaultOpHandler;
      this.types["(signed long long)"] = defaultOpHandler;
      this.types["(signed long long int)"] = defaultOpHandler;
      this.types["(unsigned long long)"] = defaultOpHandler;
      this.types["(unsigned long long int)"] = defaultOpHandler;
      this.types["(float)"] = defaultOpHandler;
      this.types["(double)"] = defaultOpHandler;
      this.types["(bool)"] = defaultOpHandler;
      this.types["pointer"] = {
        "o(==)": {"#default": function(rt, l, r) {
            if (rt.isTypeEqualTo(l.t, r.t)) {
              if (l.t.ptrType === "array") {
                return l.v.target === r.v.target && (l.v.target === null || l.v.position === r.v.position);
              } else {
                return l.v.target === r.v.target;
              }
            }
            return false;
          }},
        "o(!=)": {"#default": function(rt, l, r) {
            return !rt.types["pointer"]["=="]["#default"](rt, l, r);
          }},
        "o(,)": {"#default": function(rt, l, r) {
            return r;
          }},
        "o(=)": {"#default": function(rt, l, r) {
            var t;
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            t = rt.cast(l.t, r);
            l.t = t.t;
            l.v = t.v;
            return l;
          }},
        "o(&)": {"#default": function(rt, l, r) {
            var t;
            if (r === void 0) {
              if (l.array) {
                return rt.val(rt.arrayPointerType(l.t, l.array.length), rt.makeArrayPointerValue(l.array, l.arrayIndex));
              } else {
                t = rt.normalPointerType(l.t);
                return rt.val(t, rt.makeNormalPointerValue(l));
              }
            } else {
              rt.raiseException("you cannot cast bitwise and on pointer");
            }
          }},
        "o(())": {"#default": function(rt, l, bindThis, args) {
            if (!rt.isFunctionType(l.v.target)) {
              rt.raiseException("pointer target(" + (rt.makeValueString(l.v.target)) + ") is not a function");
            }
            return rt.types["function"]["o(())"]["default"](rt, l.v.target, bindThis, args);
          }}
      };
      this.types["function"] = {
        "o(())": {"#default": function(rt, l, bindThis, args) {
            if (l.t.type === "pointer" && l.t.targetType.type === "function") {
              l = l.v.target;
            }
            if (l.v.target === null) {
              rt.raiseException("function " + l.v.name + " does not seem to be implemented");
            }
            return rt.getCompatibleFunc(l.v.defineType, l.v.name, args).apply(null, [rt, bindThis].concat(slice.call(args)));
          }},
        "o(&)": {"#default": function(rt, l, r) {
            var t;
            if (r === void 0) {
              t = rt.normalPointerType(l.t);
              return rt.val(t, rt.makeNormalPointerValue(l));
            } else {
              rt.raiseException("you cannot cast bitwise and on function");
            }
          }}
      };
      this.types["pointer_normal"] = {
        "o(*)": {"#default": function(rt, l, r) {
            if (r === void 0) {
              return l.v.target;
            } else {
              rt.raiseException("you cannot multiply a pointer");
            }
          }},
        "o(->)": {"#default": function(rt, l, r) {
            return rt.getMember(l.v.target, r);
          }}
      };
      this.types["pointer_array"] = {
        "o(*)": {"#default": function(rt, l, r) {
            var arr,
                ret;
            if (r === void 0) {
              arr = l.v.target;
              if (l.v.position >= arr.length) {
                rt.raiseException("index out of bound " + l.v.position + " >= " + arr.length);
              } else if (l.v.position < 0) {
                rt.raiseException("negative index " + l.v.position);
              }
              ret = arr[l.v.position];
              ret.array = arr;
              ret.arrayIndex = l.v.position;
              return ret;
            } else {
              rt.raiseException("you cannot multiply a pointer");
            }
          }},
        "o([])": {"#default": function(rt, l, r) {
            r = rt.types["pointer_array"]["o(+)"]["#default"](rt, l, r);
            return rt.types["pointer_array"]["o(*)"]["#default"](rt, r);
          }},
        "o(->)": {"#default": function(rt, l, r) {
            l = rt.types["pointer_array"]["o(*)"]["#default"](rt, l);
            return rt.getMember(l, r);
          }},
        "o(-)": {"#default": function(rt, l, r) {
            var i;
            if (rt.isNumericType(r.t)) {
              i = rt.cast(rt.intTypeLiteral, r).v;
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position - i));
            } else if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position - r.v.position;
              } else {
                rt.raiseException("you cannot perform minus on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(<)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position < r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(>)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position > r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(<=)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position <= r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(>=)": {"#default": function(rt, l, r) {
            if (rt.isArrayType(r.t)) {
              if (l.v.target === r.v.target) {
                return l.v.position >= r.v.position;
              } else {
                rt.raiseException("you cannot perform compare on pointers pointing to different arrays");
              }
            } else {
              rt.raiseException(rt.makeTypeString(r.t) + " is not an array pointer type");
            }
          }},
        "o(+)": {"#default": function(rt, l, r) {
            var i;
            if (rt.isNumericType(r.t)) {
              i = rt.cast(rt.intTypeLiteral, r).v;
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position + i));
            } else {
              rt.raiseException("cannot add non-numeric to a pointer");
            }
          }},
        "o(+=)": {"#default": function(rt, l, r) {
            r = rt.types["pointer_array"]["o(+)"]["#default"](rt, l, r);
            return rt.types["pointer"]["="]["#default"](rt, l, r);
          }},
        "o(-=)": {"#default": function(rt, l, r) {
            r = rt.types["pointer_array"]["o(-)"]["#default"](rt, l, r);
            return rt.types["pointer"]["="]["#default"](rt, l, r);
          }},
        "o(++)": {"#default": function(rt, l, dummy) {
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position++));
            } else {
              l.v.position++;
              return l;
            }
          }},
        "o(--)": {"#default": function(rt, l, dummy) {
            if (!l.left) {
              rt.raiseException(rt.makeValString(l) + " is not a left value");
            }
            if (dummy) {
              return rt.val(l.t, rt.makeArrayPointerValue(l.v.target, l.v.position--));
            } else {
              l.v.position--;
              return l;
            }
          }}
      };
      return this;
    };
  }, {}],
  4: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isdigit", [rt.intTypeLiteral])(rt, _this, x);
          if (!c.v) {
            return rt.getFunc("global", "isalpha", [rt.intTypeLiteral])(rt, _this, x);
          }
          return c;
        }), "global", "isalnum", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "0".charCodeAt(0) && x.v <= "9".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isdigit", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isupper", [rt.intTypeLiteral])(rt, _this, x);
          if (!c.v) {
            return rt.getFunc("global", "islower", [rt.intTypeLiteral])(rt, _this, x);
          }
          return c;
        }), "global", "isalpha", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var ref,
              v;
          v = (ref = x.v) === 0x20 || ref === 0x09 || ref === 0x0a || ref === 0x0b || ref === 0x0c || ref === 0x0d ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isspace", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= 0x00 && x.v <= 0x1f || x.v === 0x7f ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "iscntrl", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v > 0x1f && x.v !== 0x7f ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isprint", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isspace", [rt.intTypeLiteral])(rt, _this, x);
          if (!c.v) {
            c = rt.getFunc("global", "isgraph", [rt.intTypeLiteral])(rt, _this, x);
            if (!c.v) {
              return rt.val(rt.intTypeLiteral, 1);
            }
          }
          return rt.val(rt.intTypeLiteral, 0);
        }), "global", "isgraph", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "a".charCodeAt(0) && x.v <= "z".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "islower", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "A".charCodeAt(0) && x.v <= "Z".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isupper", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isgraph", [rt.intTypeLiteral])(rt, _this, x);
          if (c.v) {
            c = rt.getFunc("global", "isalnum", [rt.intTypeLiteral])(rt, _this, x);
            if (!c.v) {
              return rt.val(rt.intTypeLiteral, 1);
            }
          }
          return rt.val(rt.intTypeLiteral, 0);
        }), "global", "ispunct", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var v;
          v = x.v >= "A".charCodeAt(0) && x.v <= "F".charCodeAt(0) || x.v >= "a".charCodeAt(0) && x.v <= "f".charCodeAt(0) || x.v >= "0".charCodeAt(0) && x.v <= "9".charCodeAt(0) ? 1 : 0;
          return rt.val(rt.intTypeLiteral, v);
        }), "global", "isxdigit", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "isupper", [rt.intTypeLiteral])(rt, _this, x);
          if (c.v) {
            return rt.val(rt.intTypeLiteral, x.v + 32);
          }
          return x;
        }), "global", "tolower", [rt.intTypeLiteral], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, x) {
          var c;
          c = rt.getFunc("global", "islower", [rt.intTypeLiteral])(rt, _this, x);
          if (c.v) {
            return rt.val(rt.intTypeLiteral, x.v - 32);
          }
          return x;
        }), "global", "toupper", [rt.intTypeLiteral], rt.intTypeLiteral);
      }};
  }, {}],
  5: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var g,
            tDouble;
        tDouble = rt.doubleTypeLiteral;
        g = "global";
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.cos(x.v));
        }), g, "cos", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.sin(x.v));
        }), g, "sin", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.tan(x.v));
        }), g, "tan", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.acos(x.v));
        }), g, "acos", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.asin(x.v));
        }), g, "asin", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.atan(x.v));
        }), g, "atan", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, y, x) {
          return rt.val(tDouble, Math.atan(y.v / x.v));
        }), g, "atan2", [tDouble, tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.cosh(x.v));
        }), g, "cosh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.sinh(x.v));
        }), g, "sinh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.tanh(x.v));
        }), g, "tanh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.acosh(x.v));
        }), g, "acosh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.asinh(x.v));
        }), g, "asinh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.atanh(x.v));
        }), g, "atanh", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.exp(x.v));
        }), g, "exp", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.log(x.v));
        }), g, "log", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.log10(x.v));
        }), g, "log10", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x, y) {
          return Math.pow(x.v, y.v);
        }), g, "pow", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.sqrt(x.v));
        }), g, "sqrt", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.ceil(x.v));
        }), g, "ceil", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.floor(x.v));
        }), g, "floor", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.abs(x.v));
        }), g, "fabs", [tDouble], tDouble);
        rt.regFunc((function(rt, _this, x) {
          return rt.val(tDouble, Math.abs(x.v));
        }), g, "abs", [tDouble], tDouble);
      }};
  }, {}],
  6: [function(require, module, exports) {
    var format_type_map,
        printf,
        validate_format,
        slice = [].slice;
    printf = require("printf");
    format_type_map = function(rt, ctrl) {
      switch (ctrl) {
        case "d":
        case "i":
          return rt.intTypeLiteral;
        case "u":
        case "o":
        case "x":
        case "X":
          return rt.unsignedintTypeLiteral;
        case "f":
        case "F":
          return rt.floatTypeLiteral;
        case "e":
        case "E":
        case "g":
        case "G":
        case "a":
        case "A":
          return rt.doubleTypeLiteral;
        case "c":
          return rt.charTypeLiteral;
        case "s":
          return rt.normalPointerType(rt.charTypeLiteral);
        case "p":
          return rt.normalPointerType(rt.voidTypeLiteral);
        case "n":
          return rt.raiseException("%n is not supported");
      }
    };
    validate_format = function() {
      var casted,
          ctrl,
          format,
          i,
          params,
          results,
          target,
          type,
          val;
      format = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      i = 0;
      results = [];
      while ((ctrl = /(?:(?!%).)%([diuoxXfFeEgGaAcspn])/.exec(format)) != null) {
        type = format_type_map(ctrl[1]);
        if (params.length <= i) {
          rt.raiseException("insufficient arguments (at least " + (i + 1) + " is required)");
        }
        target = params[i++];
        casted = rt.cast(type, target);
        if (rt.isStringType(casted.t)) {
          results.push(val = rt.getStringFromCharArray(casted));
        } else {
          results.push(val = casted.v);
        }
      }
      return results;
    };
    module.exports = {load: function(rt) {
        var __printf,
            _printf,
            _sprintf,
            pchar,
            stdio;
        rt.include("cstring");
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        stdio = rt.config.stdio;
        __printf = function() {
          var format,
              params,
              parsed_params,
              retval;
          format = arguments[0], params = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (rt.isStringType(format.t)) {
            format = format.v.target;
            parsed_params = validate_format.apply(null, [format].concat(slice.call(params)));
            retval = printf.apply(null, [format].concat(slice.call(parsed_params)));
            return rt.makeCharArrayFromString(retval);
          } else {
            return rt.raiseException("format must be a string");
          }
        };
        _sprintf = function() {
          var _this,
              format,
              params,
              retval,
              rt,
              target;
          rt = arguments[0], _this = arguments[1], target = arguments[2], format = arguments[3], params = 5 <= arguments.length ? slice.call(arguments, 4) : [];
          retval = __printf.apply(null, [format].concat(slice.call(params)));
          rt.getFunc("global", "strcpy", [pchar, pchar])(rt, null, [target, retval]);
          return rt.val(rt.intTypeLiteral, retval.length);
        };
        rt.regFunc(_sprintf, "global", "sprintf", [pchar, pchar, "?"], rt.intTypeLiteral);
        _printf = function() {
          var _this,
              format,
              params,
              retval,
              rt;
          rt = arguments[0], _this = arguments[1], format = arguments[2], params = 4 <= arguments.length ? slice.call(arguments, 3) : [];
          retval = __printf.apply(null, [format].concat(slice.call(params)));
          stdio.write(retval);
          return rt.val(rt.intTypeLiteral, retval.length);
        };
        return rt.regFunc(_printf, "global", "printf", [pchar, "?"], rt.intTypeLiteral);
      }};
  }, {"printf": 46}],
  7: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _abs,
            _atof,
            _atoi,
            _atol,
            _bsearch,
            _div,
            _labs,
            _ldiv,
            _qsort,
            _rand,
            _srand,
            _system,
            binary_search,
            cmpType,
            div_t_t,
            ldiv_t_t,
            m_w,
            m_z,
            mask,
            pchar,
            random,
            seed;
        m_w = 123456789;
        m_z = 987654321;
        mask = 0xffffffff;
        seed = function(i) {
          return m_w = i;
        };
        random = function() {
          var result;
          m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
          m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;
          result = ((m_z << 16) + m_w) & mask;
          return result / 4294967296 + 0.5;
        };
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        _atof = function(rt, _this, str) {
          var val;
          if (rt.isStringType(str.t)) {
            str = rt.getStringFromCharArray(str);
            val = Number.parseFloat(str);
            return rt.val(rt.floatTypeLiteral, val);
          } else {
            return rt.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atof, "global", "atof", [pchar], rt.floatTypeLiteral);
        _atoi = function(rt, _this, str) {
          var val;
          if (rt.isStringType(str.t)) {
            str = rt.getStringFromCharArray(str);
            val = Number.parseInt(str);
            return rt.val(rt.intTypeLiteral, val);
          } else {
            return rt.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atoi, "global", "atoi", [pchar], rt.intTypeLiteral);
        _atol = function(rt, _this, str) {
          var val;
          if (rt.isStringType(str.t)) {
            str = rt.getStringFromCharArray(str);
            val = Number.parseInt(str);
            return rt.val(rt.longTypeLiteral, val);
          } else {
            return rt.raiseException("argument is not a string");
          }
        };
        rt.regFunc(_atol, "global", "atol", [pchar], rt.longTypeLiteral);
        if (rt.scope[0]["RAND_MAX"] == null) {
          rt.scope[0]["RAND_MAX"] = 0x7fffffff;
        }
        _rand = function(rt, _this) {
          var val;
          val = Math.floor(random() * (rt.scope[0]["RAND_MAX"] + 1));
          return rt.val(rt.intTypeLiteral, val);
        };
        rt.regFunc(_rand, "global", "rand", [], rt.intTypeLiteral);
        _srand = function(rt, _this, i) {
          return seed(i.v);
        };
        rt.regFunc(_srand, "global", "srand", [rt.unsignedintTypeLiteral], rt.voidTypeLiteral);
        _system = function(rt, _this, command) {
          var e,
              ret,
              str;
          if (command === rt.nullPointer) {
            return rt.val(rt.intTypeLiteral, 1);
          } else if (rt.isStringType(command.t)) {
            str = rt.getStringFromCharArray(str);
            try {
              ret = eval(str);
              if (ret != null) {
                console.log(ret);
              }
              return rt.val(rt.intTypeLiteral, 1);
            } catch (_error) {
              e = _error;
              return rt.val(rt.intTypeLiteral, 0);
            }
          } else {
            return rt.raiseException("command is not a string");
          }
        };
        rt.regFunc(_system, "global", "system", [pchar], rt.intTypeLiteral);
        rt.scope[0]["NULL"] = rt.nullPointer;
        binary_search = function(val, L, cmp) {
          var cmpResult,
              mid;
          if (L.length === 0) {
            return false;
          }
          mid = Math.floor(L.length / 2);
          cmpResult = cmp(val, L[mid], mid);
          if (cmpResult === 0) {
            return mid;
          } else if (cmpResult > 0) {
            return binary_search(val, L.slice(mid + 1, +L.length + 1 || 9e9));
          } else {
            return binary_search(val, L.slice(0, +(mid - 1) + 1 || 9e9));
          }
        };
        _bsearch = function(rt, _this, key, base, num, size, cmp) {
          var L,
              bsRet,
              val,
              wrapper;
          if (rt.isArrayType(base)) {
            L = base.v.target;
            val = key;
            wrapper = function(a, b, indexB) {
              var pbType,
                  pbVal,
                  pointerB;
              pbType = base.t;
              pbVal = rt.makeArrayPointerValue(L, indexB);
              pointerB = rt.val(pbType, pbVal);
              return cmp(rt, null, a, pointerB).v;
            };
            bsRet = binary_search(val, L, wrapper);
            if (bsRet === false) {
              return rt.nullPointer;
            } else {
              return rt.val(base.t, rt.makeArrayPointerValue(L, bsRet));
            }
          } else {
            return rt.raiseException("base must be an array");
          }
        };
        cmpType = rt.functionPointerType(rt.intTypeLiteral, [rt.voidPointerType, rt.voidPointerType]);
        rt.regFunc(_bsearch, "global", "bsearch", [rt.voidPointerType, rt.voidPointerType, rt.intTypeLiteral, rt.intTypeLiteral, cmpType], rt.voidPointerType);
        _qsort = function(rt, _this, base, num, size, cmp) {
          var L,
              ele,
              i,
              j,
              len,
              wrapper;
          if (rt.isArrayType(base)) {
            L = base.v.target;
            for (i = j = 0, len = L.length; j < len; i = ++j) {
              ele = L[i];
              ele.index = i;
            }
            wrapper = function(a, b) {
              var pType,
                  paVal,
                  pbVal,
                  pointerA,
                  pointerB;
              pType = base.t;
              pbVal = rt.makeArrayPointerValue(L, b.index);
              paVal = rt.makeArrayPointerValue(L, a.index);
              pointerB = rt.val(pType, pbVal);
              pointerA = rt.val(pType, pbVal);
              return cmp(rt, null, pointerA, pointerB).v;
            };
            L.sort(wrapper);
          } else {
            return rt.raiseException("base must be an array");
          }
        };
        rt.regFunc(_qsort, "global", "qsort", [rt.voidPointerType, rt.intTypeLiteral, rt.intTypeLiteral, cmpType], rt.voidTypeLiteral);
        _abs = function(rt, _this, n) {
          return rt.val(rt.intTypeLiteral, Math.abs(n.v));
        };
        rt.regFunc(_abs, "global", "abs", [rt.intTypeLiteral], rt.intTypeLiteral);
        _div = function(rt, _this, numer, denom) {
          var quot,
              rem;
          if (denom.v === 0) {
            rt.raiseException("divided by zero");
          }
          quot = rt.val(rt.intTypeLiteral, Math.floor(numer.v / denom.v));
          rem = rt.val(rt.intTypeLiteral, numer.v % denom.v);
          return {
            t: div_t_t,
            v: {members: {
                quot: quot,
                rem: rem
              }}
          };
        };
        div_t_t = rt.newClass("div_t", [{
          type: rt.intTypeLiteral,
          name: "quot"
        }, {
          type: rt.intTypeLiteral,
          name: "rem"
        }]);
        rt.regFunc(_div, "global", "div", [rt.intTypeLiteral, rt.intTypeLiteral], div_t_t);
        _labs = function(rt, _this, n) {
          return rt.val(rt.longTypeLiteral, Math.abs(n.v));
        };
        rt.regFunc(_labs, "global", "labs", [rt.longTypeLiteral], rt.longTypeLiteral);
        _ldiv = function(rt, _this, numer, denom) {
          var quot,
              rem;
          if (denom.v === 0) {
            rt.raiseException("divided by zero");
          }
          quot = rt.val(rt.longTypeLiteral, Math.floor(numer.v / denom.v));
          rem = rt.val(rt.longTypeLiteral, numer.v % denom.v);
          return {
            t: ldiv_t_t,
            v: {members: {
                quot: quot,
                rem: rem
              }}
          };
        };
        ldiv_t_t = rt.newClass("ldiv_t", [{
          type: rt.longTypeLiteral,
          name: "quot"
        }, {
          type: rt.longTypeLiteral,
          name: "rem"
        }]);
        return rt.regFunc(_ldiv, "global", "ldiv", [rt.longTypeLiteral, rt.longTypeLiteral], ldiv_t_t);
      }};
  }, {}],
  8: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var pchar,
            sizet;
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        sizet = rt.primitiveType("unsigned int");
        rt.regFunc((function(rt, _this, dest, src) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (i < srcarr.length && j < destarr.length && srcarr[i].v !== 0) {
              destarr[j] = rt.clone(srcarr[i]);
              i++;
              j++;
            }
            if (i === srcarr.length) {
              rt.raiseException("source string does not have a pending \"\\0\"");
            } else if (j === destarr.length - 1) {
              rt.raiseException("destination array is not big enough");
            } else {
              destarr[j] = rt.val(rt.charTypeLiteral, 0);
            }
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strcpy", [pchar, pchar], pchar);
        rt.regFunc((function(rt, _this, dest, src, num) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (num > 0 && i < srcarr.length && j < destarr.length - 1 && srcarr[i].v !== 0) {
              destarr[j] = rt.clone(srcarr[i]);
              num--;
              i++;
              j++;
            }
            if (srcarr[i].v === 0) {
              while (num > 0 && j < destarr.length) {
                destarr[j++] = rt.val(rt.charTypeLiteral, 0);
              }
            }
            if (i === srcarr.length) {
              rt.raiseException("source string does not have a pending \"\\0\"");
            } else if (j === destarr.length - 1) {
              rt.raiseException("destination array is not big enough");
            }
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strncpy", [pchar, pchar, sizet], pchar);
        rt.regFunc((function(rt, _this, dest, src) {
          var destarr,
              i,
              j,
              lendest,
              lensrc,
              newDest,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            destarr = dest.v.target;
            if (srcarr === destarr) {
              i = src.v.position;
              j = dest.v.position;
              if (i < j) {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                if (i + lensrc + 1 >= j) {
                  rt.raiseException("overlap is not allowed");
                }
              } else {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
                if (j + lensrc + lendest + 1 >= i) {
                  rt.raiseException("overlap is not allowed");
                }
              }
            }
            lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
            newDest = rt.val(pchar, rt.makeArrayPointerValue(dest.v.target, dest.v.position + lendest));
            return rt.getFunc("global", "strcpy", [pchar, pchar])(rt, null, [newDest, src]);
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strcat", [pchar, pchar], pchar);
        rt.regFunc((function(rt, _this, dest, src, num) {
          var destarr,
              i,
              j,
              lendest,
              lensrc,
              newDest,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            destarr = dest.v.target;
            if (srcarr === destarr) {
              i = src.v.position;
              j = dest.v.position;
              if (i < j) {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                if (lensrc > num) {
                  lensrc = num;
                }
                if (i + lensrc + 1 >= j) {
                  rt.raiseException("overlap is not allowed");
                }
              } else {
                lensrc = rt.getFunc("global", "strlen", [pchar])(rt, null, [src]).v;
                if (lensrc > num) {
                  lensrc = num;
                }
                lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
                if (j + lensrc + lendest + 1 >= i) {
                  rt.raiseException("overlap is not allowed");
                }
              }
            }
            lendest = rt.getFunc("global", "strlen", [pchar])(rt, null, [dest]).v;
            newDest = rt.val(pchar, rt.makeArrayPointerValue(dest.v.target, dest.v.position + lendest));
            return rt.getFunc("global", "strncpy", [pchar, pchar, sizet])(rt, null, [newDest, src, num]);
          } else {
            rt.raiseException("destination or source is not an array");
          }
          return dest;
        }), "global", "strncat", [pchar, pchar, sizet], pchar);
        rt.regFunc((function(rt, _this, str) {
          var arr,
              i;
          if (rt.isArrayType(str.t)) {
            arr = str.v.target;
            i = str.v.position;
            while (i < arr.length && arr[i].v !== 0) {
              i++;
            }
            if (i === arr.length) {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            } else {
              return rt.val(rt.intTypeLiteral, i - str.v.position);
            }
          } else {
            return rt.raiseException("target is not an array");
          }
        }), "global", "strlen", [pchar], sizet);
        rt.regFunc((function(rt, _this, dest, src) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (i < srcarr.length && j < destarr.length && srcarr[i].v === destarr[i].v) {
              i++;
              j++;
            }
            return rt.val(rt.intTypeLiteral, destarr[i].v - srcarr[i].v);
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strcmp", [pchar, pchar], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, dest, src, num) {
          var destarr,
              i,
              j,
              srcarr;
          if (rt.isArrayType(dest.t) && rt.isArrayType(src.t)) {
            srcarr = src.v.target;
            i = src.v.position;
            destarr = dest.v.target;
            j = dest.v.position;
            while (num > 0 && i < srcarr.length && j < destarr.length && srcarr[i].v === destarr[i].v) {
              i++;
              j++;
              num--;
            }
            return rt.val(rt.intTypeLiteral, destarr[i].v - srcarr[i].v);
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strncmp", [pchar, pchar, sizet], rt.intTypeLiteral);
        rt.regFunc((function(rt, _this, str, ch) {
          var arr,
              i;
          if (rt.isArrayType(str.t)) {
            arr = str.v.target;
            i = str.v.position;
            while (i < arr.length && arr[i].v !== 0 && arr[i].v !== ch.v) {
              i++;
            }
            if (arr[i].v === 0) {
              return rt.val(pchar, rt.nullPointerValue);
            } else if (arr[i].v === ch.v) {
              return rt.val(pchar, rt.makeArrayPointerValue(arr, i));
            } else {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            }
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strchr", [pchar, rt.charTypeLiteral], pchar);
        rt.regFunc((function(rt, _this, str, ch) {
          var arr,
              i,
              lastpos;
          if (rt.isArrayType(str.t)) {
            arr = str.v.target;
            i = str.v.position;
            lastpos = -1;
            while (i < arr.length && arr[i].v !== 0) {
              if (arr[i].v === ch.v) {
                lastpos = i;
              }
              i++;
            }
            if (arr[i].v === 0) {
              if (lastpos >= 0) {
                return rt.val(pchar, rt.makeArrayPointerValue(arr, lastpos));
              } else {
                return rt.val(pchar, rt.nullPointerValue);
              }
            } else {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            }
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strrchr", [pchar, rt.charTypeLiteral], pchar);
        return rt.regFunc((function(rt, _this, str1, str2) {
          var _i,
              arr,
              i,
              j,
              tar;
          if (rt.isArrayType(str1.t) && rt.isArrayType(str2.t)) {
            arr = str1.v.target;
            i = str1.v.position;
            tar = str2.v.target;
            while (i < arr.length && arr[i].v !== 0) {
              j = str2.v.position;
              _i = i;
              while (j < tar.length && str1[_i].v === str2[j]) {
                _i++;
                j++;
              }
              if (j === tar.length) {
                break;
              }
              i++;
            }
            if (arr[i].v === 0) {
              return rt.val(pchar, rt.nullPointerValue);
            } else if (i === arr.length) {
              return rt.raiseException("target string does not have a pending \"\\0\"");
            } else {
              return rt.val(pchar, rt.makeArrayPointerValue(arr, i));
            }
          } else {
            return rt.raiseException("str1 or str2 is not an array");
          }
        }), "global", "strstr", [pchar, rt.charTypeLiteral], pchar);
      }};
  }, {}],
  9: [function(require, module, exports) {
    module.exports = {load: function(rt) {
        var _addManipulator,
            _fixed,
            _setfill,
            _setprecesion,
            _setw,
            oType,
            type;
        type = rt.newClass("iomanipulator", []);
        oType = rt.simpleType("ostream", []);
        _setprecesion = function(rt, _this, x) {
          return {
            t: type,
            v: {members: {
                name: "setprecision",
                f: function(config) {
                  return config.setprecision = x.v;
                }
              }},
            left: false
          };
        };
        rt.regFunc(_setprecesion, "global", "setprecision", [rt.intTypeLiteral], type);
        _fixed = {
          t: type,
          v: {members: {
              name: "fixed",
              f: function(config) {
                return config.fixed = true;
              }
            }}
        };
        rt.scope[0]["fixed"] = _fixed;
        _setw = function(rt, _this, x) {
          return {
            t: type,
            v: {members: {
                name: "setw",
                f: function(config) {
                  return config.setw = x.v;
                }
              }}
          };
        };
        rt.regFunc(_setw, "global", "setw", [rt.intTypeLiteral], type);
        _setfill = function(rt, _this, x) {
          return {
            t: type,
            v: {members: {
                name: "setfill",
                f: function(config) {
                  return config.setfill = String.fromCharCode(x.v);
                }
              }}
          };
        };
        rt.regFunc(_setfill, "global", "setfill", [rt.charTypeLiteral], type);
        _addManipulator = function(rt, _cout, m) {
          _cout.manipulators || (_cout.manipulators = {
            config: {},
            active: {},
            use: function(o) {
              var fill,
                  i,
                  j,
                  prec,
                  ref,
                  tarStr;
              if (rt.isNumericType(o.t) && !rt.isIntegerType(o.t)) {
                if (this.active.fixed) {
                  prec = this.active.setprecision != null ? this.config.setprecision : 6;
                  tarStr = o.v.toFixed(prec);
                } else if (this.active.setprecision != null) {
                  tarStr = o.v.toPrecision(this.config.setprecision).replace(/0+$/, "");
                }
              }
              if (this.active.setw != null) {
                if (this.active.setfill != null) {
                  fill = this.config.setfill;
                } else {
                  fill = " ";
                }
                if (!(rt.isTypeEqualTo(o.t, rt.charTypeLiteral) && (o.v === 10 || o.v === 13))) {
                  tarStr || (tarStr = rt.isPrimitiveType(o.t) ? o.t.name.indexOf("char") >= 0 ? String.fromCharCode(o.v) : o.t.name === "bool" ? o.v ? "1" : "0" : o.v.toString() : rt.isStringType(o.t) ? rt.getStringFromCharArray(o) : rt.raiseException("<< operator in ostream cannot accept " + rt.makeTypeString(o.t)));
                  for (i = j = 0, ref = this.config.setw - tarStr.length; j < ref; i = j += 1) {
                    tarStr = fill + tarStr;
                  }
                  delete this.active.setw;
                }
              }
              if (tarStr != null) {
                return rt.makeCharArrayFromString(tarStr);
              } else {
                return o;
              }
            }
          });
          m.v.members.f(_cout.manipulators.config);
          _cout.manipulators.active[m.v.members.name] = m.v.members.f;
          return _cout;
        };
        rt.regOperator(_addManipulator, oType, "<<", [type], oType);
      }};
  }, {}],
  10: [function(require, module, exports) {
    var _read,
        _skipSpace;
    _skipSpace = function(s) {
      var r;
      r = /^\s*/.exec(s);
      if (r && r.length > 0) {
        return s.substring(r[0].length);
      } else {
        return s;
      }
    };
    _read = function(rt, reg, buf, type) {
      var r;
      r = reg.exec(buf);
      if ((r == null) || r.length === 0) {
        return rt.raiseException("input format mismatch " + rt.makeTypeString(type) + " with buffer=" + buf);
      } else {
        return r;
      }
    };
    module.exports = {load: function(rt) {
        var _bool,
            _cinString,
            _get,
            _getline,
            cin,
            cout,
            endl,
            pchar,
            stdio,
            type;
        stdio = rt.config.stdio;
        type = rt.newClass("istream", []);
        cin = {
          t: type,
          v: {
            buf: stdio.drain(),
            istream: stdio,
            members: {}
          },
          left: false
        };
        rt.scope[0]["cin"] = cin;
        pchar = rt.normalPointerType(rt.charTypeLiteral);
        rt.types[rt.getTypeSignature(type)] = {
          "#father": "object",
          "o(>>)": {"#default": function(rt, _cin, t) {
              var b,
                  len,
                  r,
                  v;
              if (!t.left) {
                rt.raiseException("only left value can be used as storage");
              }
              if (!rt.isPrimitiveType(t.t)) {
                rt.raiseException(">> operator in istream cannot accept " + rt.makeTypeString(t.t));
              }
              b = _cin.v.buf;
              _cin.v.eofbit = b.length === 0;
              switch (t.t.name) {
                case "char":
                case "signed char":
                case "unsigned char":
                  b = _skipSpace(b);
                  r = _read(rt, /^./, b, t.t);
                  v = r[0].charCodeAt(0);
                  break;
                case "short":
                case "short int":
                case "signed short":
                case "signed short int":
                case "unsigned short":
                case "unsigned short int":
                case "int":
                case "signed int":
                case "unsigned":
                case "unsigned int":
                case "long":
                case "long int":
                case "long int":
                case "signed long":
                case "signed long int":
                case "unsigned long":
                case "unsigned long int":
                case "long long":
                case "long long int":
                case "long long int":
                case "signed long long":
                case "signed long long int":
                case "unsigned long long":
                case "unsigned long long int":
                  b = _skipSpace(b);
                  r = _read(rt, /^[-+]?(?:([0-9]*)([eE]\+?[0-9]+)?)|0/, b, t.t);
                  v = parseInt(r[0]);
                  break;
                case "float":
                case "double":
                  b = _skipSpace(b);
                  r = _read(rt, /^[-+]?(?:[0-9]*\.[0-9]+([eE][-+]?[0-9]+)?)|(?:([1-9][0-9]*)([eE]\+?[0-9]+)?)/, b, t.t);
                  v = parseFloat(r[0]);
                  break;
                case "bool":
                  b = _skipSpace(b);
                  r = _read(rt, /^(true|false)/, b, t.t);
                  v = r[0] === "true";
                  break;
                default:
                  rt.raiseException(">> operator in istream cannot accept " + rt.makeTypeString(t.t));
              }
              len = r[0].length;
              _cin.v.failbit = len === 0;
              if (!_cin.v.failbit) {
                t.v = rt.val(t.t, v).v;
                _cin.v.buf = b.substring(len);
              }
              return _cin;
            }}
        };
        _cinString = function(rt, _cin, t) {
          var b,
              i,
              initialPos,
              j,
              r,
              ref,
              tar;
          if (!rt.isStringType(t.t)) {
            rt.raiseException("only a pointer to string can be used as storage");
          }
          b = _cin.v.buf;
          _cin.v.eofbit = b.length === 0;
          b = _skipSpace(b);
          r = _read(rt, /^\S*/, b, t.t)[0];
          _cin.v.failbit = r.length === 0;
          _cin.v.buf = b.substring(r.length);
          initialPos = t.v.position;
          tar = t.v.target;
          if (tar.length - initialPos <= r.length) {
            rt.raiseException("target string buffer is " + (r.length - (tar.length - initialPos)) + " too short");
          }
          for (i = j = 0, ref = r.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            tar[i + initialPos] = rt.val(rt.charTypeLiteral, r.charCodeAt(i));
          }
          tar[r.length + initialPos] = rt.val(rt.charTypeLiteral, 0);
          return _cin;
        };
        rt.regOperator(_cinString, cin.t, ">>", [pchar], cin.t);
        _getline = function(rt, _cin, t, limit, delim) {
          var b,
              i,
              initialPos,
              j,
              r,
              ref,
              removeDelim,
              tar;
          if (!rt.isStringType(t.t)) {
            rt.raiseException("only a pointer to string can be used as storage");
          }
          limit = limit.v;
          delim = delim != null ? delim.v : '\n';
          b = _cin.v.buf;
          _cin.v.eofbit = b.length === 0;
          r = _read(rt, new RegExp("^[^" + delim + "]*"), b, t.t)[0];
          if (r.length + 1 > limit) {
            r = r.substring(0, limit - 1);
          }
          if (b.charAt(r.length) === delim.charAt(0)) {
            removeDelim = true;
            _cin.v.failbit = false;
          } else {
            _cin.v.failbit = r.length === 0;
          }
          _cin.v.buf = b.substring(r.length + (removeDelim ? 1 : 0));
          initialPos = t.v.position;
          tar = t.v.target;
          if (tar.length - initialPos <= r.length) {
            rt.raiseException("target string buffer is " + (r.length - (tar.length - initialPos)) + " too short");
          }
          for (i = j = 0, ref = r.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            tar[i + initialPos] = rt.val(rt.charTypeLiteral, r.charCodeAt(i));
          }
          tar[r.length + initialPos] = rt.val(rt.charTypeLiteral, 0);
          return _cin;
        };
        rt.regFunc(_getline, cin.t, "getline", [pchar, rt.intTypeLiteral, rt.charTypeLiteral], cin.t);
        rt.regFunc(_getline, cin.t, "getline", [pchar, rt.intTypeLiteral], cin.t);
        _get = function(rt, _cin) {
          var b,
              r,
              v;
          b = _cin.v.buf;
          r = _read(rt, /^.|[\r\n]/, b, rt.charTypeLiteral);
          _cin.v.buf = b.substring(r.length);
          v = r[0].charCodeAt(0);
          return rt.val(rt.charTypeLiteral, v);
        };
        rt.regFunc(_get, cin.t, "get", [], cin.t);
        _bool = function(rt, _cin) {
          return rt.val(rt.boolTypeLiteral, !_cin.v.failbit);
        };
        rt.regOperator(_bool, cin.t, "bool", [], rt.boolTypeLiteral);
        type = rt.newClass("ostream", []);
        cout = {
          t: rt.simpleType("ostream"),
          v: {
            ostream: stdio,
            members: {}
          },
          left: false
        };
        rt.scope[0]["cout"] = cout;
        rt.types[rt.getTypeSignature(cout.t)] = {
          "#father": "object",
          "o(<<)": {"#default": function(rt, _cout, t) {
              var r;
              if (_cout.manipulators != null) {
                t = _cout.manipulators.use(t);
              }
              if (rt.isPrimitiveType(t.t)) {
                if (t.t.name.indexOf("char") >= 0) {
                  r = String.fromCharCode(t.v);
                } else if (t.t.name === "bool") {
                  r = t.v ? "1" : "0";
                } else {
                  r = t.v.toString();
                }
              } else if (rt.isStringType(t.t)) {
                r = rt.getStringFromCharArray(t);
              } else {
                rt.raiseException("<< operator in ostream cannot accept " + rt.makeTypeString(t.t));
              }
              _cout.v.ostream.write(r);
              return _cout;
            }}
        };
        endl = rt.val(rt.charTypeLiteral, "\n".charCodeAt(0));
        rt.scope[0]["endl"] = endl;
      }};
  }, {}],
  11: [function(require, module, exports) {
    JSCPP = require('./main');
  }, {"./main": 14}],
  12: [function(require, module, exports) {
    var Interpreter,
        isGenerator,
        isGeneratorFunction,
        sampleGenerator,
        sampleGeneratorFunction;
    sampleGeneratorFunction = $traceurRuntime.initGeneratorFunction(function $__2() {
      var $__3;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              $ctx.state = 2;
              return null;
            case 2:
              $__3 = $ctx.sent;
              $ctx.state = 4;
              break;
            case 4:
              $ctx.returnValue = $__3;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__2, this);
    });
    sampleGenerator = sampleGeneratorFunction();
    isGenerator = function(g) {
      return (g != null ? g.constructor : void 0) === sampleGenerator.constructor;
    };
    isGeneratorFunction = function(f) {
      return (f != null ? f.constructor : void 0) === sampleGeneratorFunction.constructor;
    };
    Interpreter = function(rt) {
      this.rt = rt;
      this.visitors = {
        TranslationUnit: $traceurRuntime.initGeneratorFunction(function $__4(interp, s, param) {
          var dec,
              i,
              $__5,
              $__6,
              $__7,
              $__8,
              $__9;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  i = 0;
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (i < s.ExternalDeclarations.length) ? 17 : -2;
                  break;
                case 17:
                  dec = s.ExternalDeclarations[i];
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = interp.visit;
                  $__6 = $__5.call(interp, interp, dec);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__8 = $ctx.wrapYieldStar($__6[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__9 = $__8[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__9.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__9.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__9.value;
                case 10:
                  $__7 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  i++;
                  $ctx.state = 23;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__4, this);
        }),
        DirectDeclarator: $traceurRuntime.initGeneratorFunction(function $__10(interp, s, param) {
          var _basetype,
              _param,
              _pointer,
              _type,
              argTypes,
              basetype,
              dim,
              dimensions,
              j,
              k,
              l,
              len,
              len1,
              len2,
              m,
              ptl,
              ref,
              ref1,
              ref2,
              ret,
              right,
              varargs,
              $__11,
              $__12,
              $__13,
              $__14,
              $__15,
              $__16,
              $__17,
              $__18,
              $__19,
              $__20,
              $__21,
              $__22,
              $__23,
              $__24,
              $__25,
              $__26,
              $__27,
              $__28,
              $__29,
              $__30,
              $__31,
              $__32,
              $__33,
              $__34,
              $__35,
              $__36;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  basetype = param.basetype;
                  basetype = interp.buildRecursivePointerType(s.Pointer, basetype, 0);
                  $ctx.state = 115;
                  break;
                case 115:
                  $ctx.state = (s.right.length === 1) ? 51 : 49;
                  break;
                case 51:
                  right = s.right[0];
                  ptl = null;
                  if (right.type === "DirectDeclarator_modifier_ParameterTypeList") {
                    ptl = right.ParameterTypeList;
                    varargs = ptl.varargs;
                  } else if (right.type === "DirectDeclarator_modifier_IdentifierList" && right.IdentifierList === null) {
                    ptl = right.ParameterTypeList;
                    varargs = false;
                  }
                  $ctx.state = 52;
                  break;
                case 52:
                  $ctx.state = (ptl != null) ? 46 : 49;
                  break;
                case 46:
                  argTypes = [];
                  ref = ptl.ParameterList;
                  $ctx.state = 47;
                  break;
                case 47:
                  k = 0, len = ref.length;
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = (k < len) ? 39 : 43;
                  break;
                case 42:
                  k++;
                  $ctx.state = 45;
                  break;
                case 39:
                  _param = ref[k];
                  _basetype = rt.simpleType(_param.DeclarationSpecifiers);
                  $ctx.state = 40;
                  break;
                case 40:
                  $ctx.state = (_param.Declarator != null) ? 34 : 36;
                  break;
                case 34:
                  _pointer = _param.Declarator.Pointer;
                  _type = interp.buildRecursivePointerType(_pointer, _basetype, 0);
                  $ctx.state = 35;
                  break;
                case 35:
                  $ctx.state = ((_param.Declarator.right != null) && _param.Declarator.right.length > 0) ? 29 : 32;
                  break;
                case 29:
                  dimensions = [];
                  ref1 = _param.Declarator.right;
                  $ctx.state = 30;
                  break;
                case 30:
                  j = l = 0, len1 = ref1.length;
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = (l < len1) ? 22 : 26;
                  break;
                case 25:
                  j = ++l;
                  $ctx.state = 28;
                  break;
                case 22:
                  dim = ref1[j];
                  dim = _param.Declarator.right[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization");
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (dim.Expression !== null) ? 15 : 19;
                  break;
                case 15:
                  $__11 = rt.cast;
                  $__12 = rt.intTypeLiteral;
                  $__13 = interp.visit;
                  $__14 = dim.Expression;
                  $__15 = $__13.call(interp, interp, $__14, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__19 = $ctx.wrapYieldStar($__15[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__20 = $__19[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__20.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__20.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__20.value;
                case 10:
                  $__16 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__17 = $__11.call(rt, $__12, $__16);
                  $__18 = $__17.v;
                  dim = $__18;
                  $ctx.state = 18;
                  break;
                case 19:
                  if (j > 0) {
                    rt.raiseException("multidimensional array must have bounds for all dimensions except the first");
                  } else {
                    dim = -1;
                  }
                  $ctx.state = 18;
                  break;
                case 18:
                  dimensions.push(dim);
                  $ctx.state = 25;
                  break;
                case 26:
                  _type = interp.arrayType(dimensions, 0, _type);
                  $ctx.state = 32;
                  break;
                case 36:
                  _type = _basetype;
                  $ctx.state = 32;
                  break;
                case 32:
                  argTypes.push(_type);
                  $ctx.state = 42;
                  break;
                case 43:
                  basetype = rt.functionType(basetype, argTypes);
                  $ctx.state = 49;
                  break;
                case 49:
                  $ctx.state = (s.right.length > 0 && s.right[0].type === "DirectDeclarator_modifier_array") ? 82 : 85;
                  break;
                case 82:
                  dimensions = [];
                  ref2 = s.right;
                  $ctx.state = 83;
                  break;
                case 83:
                  j = m = 0, len2 = ref2.length;
                  $ctx.state = 81;
                  break;
                case 81:
                  $ctx.state = (m < len2) ? 75 : 79;
                  break;
                case 78:
                  j = ++m;
                  $ctx.state = 81;
                  break;
                case 75:
                  dim = ref2[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization");
                  }
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization");
                  }
                  $ctx.state = 76;
                  break;
                case 76:
                  $ctx.state = (dim.Expression !== null) ? 68 : 72;
                  break;
                case 68:
                  $__21 = rt.cast;
                  $__22 = rt.intTypeLiteral;
                  $__23 = interp.visit;
                  $__24 = dim.Expression;
                  $__25 = $__23.call(interp, interp, $__24, param);
                  $ctx.state = 69;
                  break;
                case 69:
                  $__29 = $ctx.wrapYieldStar($__25[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 65;
                  break;
                case 65:
                  $__30 = $__29[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 62;
                  break;
                case 62:
                  $ctx.state = ($__30.done) ? 56 : 55;
                  break;
                case 56:
                  $ctx.sent = $__30.value;
                  $ctx.state = 63;
                  break;
                case 55:
                  $ctx.state = 65;
                  return $__30.value;
                case 63:
                  $__26 = $ctx.sentIgnoreThrow;
                  $ctx.state = 67;
                  break;
                case 67:
                  $__27 = $__21.call(rt, $__22, $__26);
                  $__28 = $__27.v;
                  dim = $__28;
                  $ctx.state = 71;
                  break;
                case 72:
                  if (j > 0) {
                    rt.raiseException("multidimensional array must have bounds for all dimensions except the first");
                  } else {
                    dim = -1;
                  }
                  $ctx.state = 71;
                  break;
                case 71:
                  dimensions.push(dim);
                  $ctx.state = 78;
                  break;
                case 79:
                  basetype = interp.arrayType(dimensions, 0, basetype);
                  $ctx.state = 85;
                  break;
                case 85:
                  $ctx.state = (s.left.type === "Identifier") ? 87 : 109;
                  break;
                case 87:
                  $ctx.returnValue = {
                    type: basetype,
                    name: s.left.Identifier
                  };
                  $ctx.state = -2;
                  break;
                case 109:
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  $ctx.state = 110;
                  break;
                case 110:
                  $__31 = interp.visit;
                  $__32 = s.left;
                  $__33 = $__31.call(interp, interp, $__32, param);
                  $ctx.state = 104;
                  break;
                case 104:
                  $__35 = $ctx.wrapYieldStar($__33[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 100;
                  break;
                case 100:
                  $__36 = $__35[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 97;
                  break;
                case 97:
                  $ctx.state = ($__36.done) ? 91 : 90;
                  break;
                case 91:
                  $ctx.sent = $__36.value;
                  $ctx.state = 98;
                  break;
                case 90:
                  $ctx.state = 100;
                  return $__36.value;
                case 98:
                  $__34 = $ctx.sentIgnoreThrow;
                  $ctx.state = 102;
                  break;
                case 102:
                  ret = $__34;
                  $ctx.state = 106;
                  break;
                case 106:
                  param.basetype = _basetype;
                  $ctx.state = 112;
                  break;
                case 112:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__10, this);
        }),
        TypedefDeclaration: $traceurRuntime.initGeneratorFunction(function $__37(interp, s, param) {
          var _basetype,
              basetype,
              declarator,
              k,
              len,
              name,
              ref,
              ref1,
              type,
              $__38,
              $__39,
              $__40,
              $__41,
              $__42,
              $__43,
              $__44;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  basetype = rt.simpleType(s.DeclarationSpecifiers);
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  ref = s.Declarators;
                  $ctx.state = 27;
                  break;
                case 27:
                  k = 0, len = ref.length;
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = (k < len) ? 19 : 23;
                  break;
                case 22:
                  k++;
                  $ctx.state = 25;
                  break;
                case 19:
                  declarator = ref[k];
                  $ctx.state = 20;
                  break;
                case 20:
                  $__38 = interp.visit;
                  $__39 = $__38.call(interp, interp, declarator, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__43 = $ctx.wrapYieldStar($__39[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__44 = $__43[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__44.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__44.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__44.value;
                case 10:
                  $__40 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ref1 = $__40;
                  $__41 = ref1.type;
                  type = $__41;
                  $__42 = ref1.name;
                  name = $__42;
                  $ctx.state = 18;
                  break;
                case 18:
                  rt.registerTypedef(type, name);
                  $ctx.state = 22;
                  break;
                case 23:
                  param.basetype = _basetype;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__37, this);
        }),
        FunctionDefinition: $traceurRuntime.initGeneratorFunction(function $__45(interp, s, param) {
          var _basetype,
              _name,
              _param,
              _pointer,
              _type,
              argNames,
              argTypes,
              basetype,
              dim,
              dimensions,
              i,
              j,
              name,
              pointer,
              ptl,
              scope,
              stat,
              varargs,
              $__46,
              $__47,
              $__48,
              $__49,
              $__50,
              $__51,
              $__52,
              $__53,
              $__54,
              $__55;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope = param.scope;
                  name = s.Declarator.left.Identifier;
                  basetype = rt.simpleType(s.DeclarationSpecifiers);
                  pointer = s.Declarator.Pointer;
                  basetype = interp.buildRecursivePointerType(pointer, basetype, 0);
                  argTypes = [];
                  argNames = [];
                  ptl = void 0;
                  varargs = void 0;
                  if (s.Declarator.right.type === "DirectDeclarator_modifier_ParameterTypeList") {
                    ptl = s.Declarator.right.ParameterTypeList;
                    varargs = ptl.varargs;
                  } else if (s.Declarator.right.type === "DirectDeclarator_modifier_IdentifierList" && s.Declarator.right.IdentifierList === null) {
                    ptl = {ParameterList: []};
                    varargs = false;
                  } else {
                    rt.raiseException("unacceptable argument list");
                  }
                  i = 0;
                  $ctx.state = 38;
                  break;
                case 38:
                  $ctx.state = (i < ptl.ParameterList.length) ? 32 : 36;
                  break;
                case 32:
                  _param = ptl.ParameterList[i];
                  _pointer = _param.Declarator.Pointer;
                  _basetype = rt.simpleType(_param.DeclarationSpecifiers);
                  _type = interp.buildRecursivePointerType(_pointer, _basetype, 0);
                  _name = _param.Declarator.left.Identifier;
                  $ctx.state = 33;
                  break;
                case 33:
                  $ctx.state = (_param.Declarator.right.length > 0) ? 27 : 30;
                  break;
                case 27:
                  dimensions = [];
                  j = 0;
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = (j < _param.Declarator.right.length) ? 22 : 26;
                  break;
                case 22:
                  dim = _param.Declarator.right[j];
                  if (dim.type !== "DirectDeclarator_modifier_array") {
                    rt.raiseException("unacceptable array initialization");
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (dim.Expression !== null) ? 15 : 19;
                  break;
                case 15:
                  $__46 = rt.cast;
                  $__47 = rt.intTypeLiteral;
                  $__48 = interp.visit;
                  $__49 = dim.Expression;
                  $__50 = $__48.call(interp, interp, $__49, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__54 = $ctx.wrapYieldStar($__50[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__55 = $__54[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__55.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__55.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__55.value;
                case 10:
                  $__51 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__52 = $__46.call(rt, $__47, $__51);
                  $__53 = $__52.v;
                  dim = $__53;
                  $ctx.state = 18;
                  break;
                case 19:
                  if (j > 0) {
                    rt.raiseException("multidimensional array must have bounds for all dimensions except the first");
                  } else {
                    dim = -1;
                  }
                  $ctx.state = 18;
                  break;
                case 18:
                  dimensions.push(dim);
                  j++;
                  $ctx.state = 28;
                  break;
                case 26:
                  _type = interp.arrayType(dimensions, 0, _type);
                  $ctx.state = 30;
                  break;
                case 30:
                  argTypes.push(_type);
                  argNames.push(_name);
                  i++;
                  $ctx.state = 38;
                  break;
                case 36:
                  stat = s.CompoundStatement;
                  rt.defFunc(scope, name, basetype, argTypes, argNames, stat, interp);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__45, this);
        }),
        Declaration: $traceurRuntime.initGeneratorFunction(function $__56(interp, s, param) {
          var _basetype,
              basetype,
              dec,
              dim,
              dimensions,
              i,
              init,
              initializer,
              j,
              k,
              l,
              len,
              len1,
              name,
              ref,
              ref1,
              ref2,
              ref3,
              type,
              $__57,
              $__58,
              $__59,
              $__60,
              $__61,
              $__62,
              $__63,
              $__64,
              $__65,
              $__66,
              $__67,
              $__68,
              $__69,
              $__70,
              $__71,
              $__72,
              $__73,
              $__74,
              $__75,
              $__76,
              $__77,
              $__78,
              $__79,
              $__80,
              $__81,
              $__82,
              $__83,
              $__84,
              $__85,
              $__86,
              $__87,
              $__88,
              $__89,
              $__90,
              $__91,
              $__92,
              $__93,
              $__94,
              $__95,
              $__96,
              $__97,
              $__98;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  basetype = rt.simpleType(s.DeclarationSpecifiers);
                  ref = s.InitDeclaratorList;
                  $ctx.state = 147;
                  break;
                case 147:
                  i = k = 0, len = ref.length;
                  $ctx.state = 145;
                  break;
                case 145:
                  $ctx.state = (k < len) ? 141 : -2;
                  break;
                case 94:
                  i = ++k;
                  $ctx.state = 145;
                  break;
                case 141:
                  dec = ref[i];
                  init = dec.Initializers;
                  $ctx.state = 142;
                  break;
                case 142:
                  $ctx.state = (dec.Declarator.right.length > 0 && dec.Declarator.right[0].type === "DirectDeclarator_modifier_array") ? 89 : 134;
                  break;
                case 89:
                  dimensions = [];
                  ref1 = dec.Declarator.right;
                  $ctx.state = 90;
                  break;
                case 90:
                  j = l = 0, len1 = ref1.length;
                  $ctx.state = 52;
                  break;
                case 52:
                  $ctx.state = (l < len1) ? 46 : 50;
                  break;
                case 49:
                  j = ++l;
                  $ctx.state = 52;
                  break;
                case 46:
                  dim = ref1[j];
                  $ctx.state = 47;
                  break;
                case 47:
                  $ctx.state = (dim.Expression !== null) ? 15 : 44;
                  break;
                case 15:
                  $__57 = rt.cast;
                  $__58 = rt.intTypeLiteral;
                  $__59 = interp.visit;
                  $__60 = dim.Expression;
                  $__61 = $__59.call(interp, interp, $__60, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__65 = $ctx.wrapYieldStar($__61[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__66 = $__65[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__66.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__66.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__66.value;
                case 10:
                  $__62 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__63 = $__57.call(rt, $__58, $__62);
                  $__64 = $__63.v;
                  dim = $__64;
                  $ctx.state = 18;
                  break;
                case 44:
                  $ctx.state = (j > 0) ? 42 : 41;
                  break;
                case 42:
                  rt.raiseException("multidimensional array must have bounds for all dimensions except the first");
                  $ctx.state = 18;
                  break;
                case 41:
                  $ctx.state = (init.type === "Initializer_expr") ? 33 : 39;
                  break;
                case 33:
                  $__67 = interp.visit;
                  $__68 = $__67.call(interp, interp, init, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__70 = $ctx.wrapYieldStar($__68[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__71 = $__70[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__71.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__71.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__71.value;
                case 28:
                  $__69 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  initializer = $__69;
                  $ctx.state = 36;
                  break;
                case 36:
                  if (rt.isCharType(basetype) && rt.isArrayType(initializer.t) && rt.isCharType(initializer.t.eleType)) {
                    dim = initializer.v.target.length;
                    init = {
                      type: "Initializer_array",
                      Initializers: initializer.v.target.map(function(e) {
                        return {
                          type: "Initializer_expr",
                          shorthand: e
                        };
                      })
                    };
                  } else {
                    rt.raiseException("cannot initialize an array to " + rt.makeValString(initializer));
                  }
                  $ctx.state = 18;
                  break;
                case 39:
                  dim = init.Initializers.length;
                  $ctx.state = 18;
                  break;
                case 18:
                  dimensions.push(dim);
                  $ctx.state = 49;
                  break;
                case 50:
                  $__72 = interp.arrayInit;
                  $__73 = $__72.call(interp, dimensions, init, 0, basetype, param);
                  $ctx.state = 68;
                  break;
                case 68:
                  $__75 = $ctx.wrapYieldStar($__73[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 64;
                  break;
                case 64:
                  $__76 = $__75[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = ($__76.done) ? 55 : 54;
                  break;
                case 55:
                  $ctx.sent = $__76.value;
                  $ctx.state = 62;
                  break;
                case 54:
                  $ctx.state = 64;
                  return $__76.value;
                case 62:
                  $__74 = $ctx.sentIgnoreThrow;
                  $ctx.state = 66;
                  break;
                case 66:
                  init = $__74;
                  $ctx.state = 70;
                  break;
                case 70:
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  $ctx.state = 92;
                  break;
                case 92:
                  $__77 = interp.visit;
                  $__78 = dec.Declarator;
                  $__79 = $__77.call(interp, interp, $__78, param);
                  $ctx.state = 86;
                  break;
                case 86:
                  $__83 = $ctx.wrapYieldStar($__79[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 82;
                  break;
                case 82:
                  $__84 = $__83[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 79;
                  break;
                case 79:
                  $ctx.state = ($__84.done) ? 73 : 72;
                  break;
                case 73:
                  $ctx.sent = $__84.value;
                  $ctx.state = 80;
                  break;
                case 72:
                  $ctx.state = 82;
                  return $__84.value;
                case 80:
                  $__80 = $ctx.sentIgnoreThrow;
                  $ctx.state = 84;
                  break;
                case 84:
                  ref2 = $__80;
                  $__81 = ref2.name;
                  name = $__81;
                  $__82 = ref2.type;
                  type = $__82;
                  $ctx.state = 88;
                  break;
                case 88:
                  param.basetype = _basetype;
                  rt.defVar(name, init.t, init);
                  $ctx.state = 94;
                  break;
                case 134:
                  _basetype = param.basetype;
                  param.basetype = basetype;
                  $ctx.state = 135;
                  break;
                case 135:
                  $__85 = interp.visit;
                  $__86 = dec.Declarator;
                  $__87 = $__85.call(interp, interp, $__86, param);
                  $ctx.state = 110;
                  break;
                case 110:
                  $__91 = $ctx.wrapYieldStar($__87[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 106;
                  break;
                case 106:
                  $__92 = $__91[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 103;
                  break;
                case 103:
                  $ctx.state = ($__92.done) ? 97 : 96;
                  break;
                case 97:
                  $ctx.sent = $__92.value;
                  $ctx.state = 104;
                  break;
                case 96:
                  $ctx.state = 106;
                  return $__92.value;
                case 104:
                  $__88 = $ctx.sentIgnoreThrow;
                  $ctx.state = 108;
                  break;
                case 108:
                  ref3 = $__88;
                  $__89 = ref3.name;
                  name = $__89;
                  $__90 = ref3.type;
                  type = $__90;
                  $ctx.state = 112;
                  break;
                case 112:
                  param.basetype = _basetype;
                  $ctx.state = 137;
                  break;
                case 137:
                  $ctx.state = (init == null) ? 131 : 127;
                  break;
                case 131:
                  init = rt.defaultValue(type, true);
                  $ctx.state = 132;
                  break;
                case 127:
                  $__93 = interp.visit;
                  $__94 = init.Expression;
                  $__95 = $__93.call(interp, interp, $__94);
                  $ctx.state = 128;
                  break;
                case 128:
                  $__97 = $ctx.wrapYieldStar($__95[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 124;
                  break;
                case 124:
                  $__98 = $__97[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 121;
                  break;
                case 121:
                  $ctx.state = ($__98.done) ? 115 : 114;
                  break;
                case 115:
                  $ctx.sent = $__98.value;
                  $ctx.state = 122;
                  break;
                case 114:
                  $ctx.state = 124;
                  return $__98.value;
                case 122:
                  $__96 = $ctx.sentIgnoreThrow;
                  $ctx.state = 126;
                  break;
                case 126:
                  init = $__96;
                  $ctx.state = 132;
                  break;
                case 132:
                  rt.defVar(name, type, init);
                  $ctx.state = 94;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__56, this);
        }),
        Initializer_expr: $traceurRuntime.initGeneratorFunction(function $__99(interp, s, param) {
          var $__100,
              $__101,
              $__102,
              $__103,
              $__104,
              $__105;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 20;
                  break;
                case 20:
                  $__100 = interp.visit;
                  $__101 = s.Expression;
                  $__102 = $__100.call(interp, interp, $__101, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__104 = $ctx.wrapYieldStar($__102[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__105 = $__104[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__105.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__105.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__105.value;
                case 10:
                  $__103 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__103;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__99, this);
        }),
        Label_case: $traceurRuntime.initGeneratorFunction(function $__106(interp, s, param) {
          var ce,
              $__107,
              $__108,
              $__109,
              $__110,
              $__111,
              $__112;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 25;
                  break;
                case 25:
                  $__107 = interp.visit;
                  $__108 = s.ConstantExpression;
                  $__109 = $__107.call(interp, interp, $__108);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__111 = $ctx.wrapYieldStar($__109[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__112 = $__111[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__112.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__112.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__112.value;
                case 10:
                  $__110 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ce = $__110;
                  $ctx.state = 18;
                  break;
                case 18:
                  if (param["switch"] === void 0) {
                    rt.raiseException("you cannot use case outside switch block");
                  }
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = (param.scope === "SelectionStatement_switch_cs") ? 19 : 21;
                  break;
                case 19:
                  $ctx.returnValue = ["switch", rt.cast(ce.t, param["switch"]).v === ce.v];
                  $ctx.state = -2;
                  break;
                case 21:
                  rt.raiseException("you can only use case directly in a switch block");
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__106, this);
        }),
        Label_default: function(interp, s, param) {
          rt = interp.rt;
          if (param["switch"] === void 0) {
            rt.raiseException("you cannot use default outside switch block");
          }
          if (param.scope === "SelectionStatement_switch_cs") {
            return ["switch", true];
          } else {
            rt.raiseException("you can only use default directly in a switch block");
          }
        },
        CompoundStatement: $traceurRuntime.initGeneratorFunction(function $__113(interp, s, param) {
          var _scope,
              i,
              k,
              len,
              r,
              stmt,
              stmts,
              switchon,
              $__114,
              $__115,
              $__116,
              $__117,
              $__118,
              $__119,
              $__120,
              $__121,
              $__122,
              $__123,
              $__124,
              $__125,
              $__126,
              $__127,
              $__128;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  stmts = s.Statements;
                  r = void 0;
                  i = void 0;
                  _scope = param.scope;
                  $ctx.state = 87;
                  break;
                case 87:
                  $ctx.state = (param.scope === "SelectionStatement_switch") ? 49 : 81;
                  break;
                case 49:
                  param.scope = "SelectionStatement_switch_cs";
                  rt.enterScope(param.scope);
                  switchon = false;
                  i = 0;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.state = (i < stmts.length) ? 44 : 48;
                  break;
                case 44:
                  stmt = stmts[i];
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = (stmt.type === "Label_case" || stmt.type === "Label_default") ? 15 : 42;
                  break;
                case 15:
                  $__114 = interp.visit;
                  $__115 = $__114.call(interp, interp, stmt, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__117 = $ctx.wrapYieldStar($__115[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__118 = $__117[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__118.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__118.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__118.value;
                case 10:
                  $__116 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  r = $__116;
                  $ctx.state = 18;
                  break;
                case 18:
                  if (r[1]) {
                    switchon = true;
                  }
                  $ctx.state = 20;
                  break;
                case 42:
                  $ctx.state = (switchon) ? 35 : 20;
                  break;
                case 35:
                  $__119 = interp.visit;
                  $__120 = $__119.call(interp, interp, stmt, param);
                  $ctx.state = 36;
                  break;
                case 36:
                  $__122 = $ctx.wrapYieldStar($__120[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 32;
                  break;
                case 32:
                  $__123 = $__122[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.state = ($__123.done) ? 23 : 22;
                  break;
                case 23:
                  $ctx.sent = $__123.value;
                  $ctx.state = 30;
                  break;
                case 22:
                  $ctx.state = 32;
                  return $__123.value;
                case 30:
                  $__121 = $ctx.sentIgnoreThrow;
                  $ctx.state = 34;
                  break;
                case 34:
                  r = $__121;
                  $ctx.state = 38;
                  break;
                case 38:
                  $ctx.state = (r instanceof Array) ? 39 : 20;
                  break;
                case 39:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 20:
                  i++;
                  $ctx.state = 50;
                  break;
                case 48:
                  rt.exitScope(param.scope);
                  param.scope = _scope;
                  $ctx.state = -2;
                  break;
                case 81:
                  param.scope = "CompoundStatement";
                  rt.enterScope(param.scope);
                  $ctx.state = 82;
                  break;
                case 82:
                  k = 0, len = stmts.length;
                  $ctx.state = 78;
                  break;
                case 78:
                  $ctx.state = (k < len) ? 74 : 76;
                  break;
                case 72:
                  k++;
                  $ctx.state = 78;
                  break;
                case 74:
                  stmt = stmts[k];
                  $ctx.state = 75;
                  break;
                case 75:
                  $__124 = interp.visit;
                  $__125 = $__124.call(interp, interp, stmt, param);
                  $ctx.state = 68;
                  break;
                case 68:
                  $__127 = $ctx.wrapYieldStar($__125[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 64;
                  break;
                case 64:
                  $__128 = $__127[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = ($__128.done) ? 55 : 54;
                  break;
                case 55:
                  $ctx.sent = $__128.value;
                  $ctx.state = 62;
                  break;
                case 54:
                  $ctx.state = 64;
                  return $__128.value;
                case 62:
                  $__126 = $ctx.sentIgnoreThrow;
                  $ctx.state = 66;
                  break;
                case 66:
                  r = $__126;
                  $ctx.state = 70;
                  break;
                case 70:
                  $ctx.state = (r instanceof Array) ? 76 : 72;
                  break;
                case 76:
                  rt.exitScope(param.scope);
                  param.scope = _scope;
                  $ctx.state = 84;
                  break;
                case 84:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__113, this);
        }),
        ExpressionStatement: $traceurRuntime.initGeneratorFunction(function $__129(interp, s, param) {
          var $__130,
              $__131,
              $__132,
              $__133,
              $__134,
              $__135;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 19;
                  break;
                case 19:
                  $ctx.state = (s.Expression != null) ? 15 : -2;
                  break;
                case 15:
                  $__130 = interp.visit;
                  $__131 = s.Expression;
                  $__132 = $__130.call(interp, interp, $__131, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__134 = $ctx.wrapYieldStar($__132[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__135 = $__134[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__135.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__135.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__135.value;
                case 10:
                  $__133 = $ctx.sentIgnoreThrow;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__129, this);
        }),
        SelectionStatement_if: $traceurRuntime.initGeneratorFunction(function $__136(interp, s, param) {
          var e,
              ret,
              scope_bak,
              $__137,
              $__138,
              $__139,
              $__140,
              $__141,
              $__142,
              $__143,
              $__144,
              $__145,
              $__146,
              $__147,
              $__148,
              $__149,
              $__150,
              $__151,
              $__152,
              $__153,
              $__154;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "SelectionStatement_if";
                  rt.enterScope(param.scope);
                  $ctx.state = 60;
                  break;
                case 60:
                  $__137 = interp.visit;
                  $__138 = s.Expression;
                  $__139 = $__137.call(interp, interp, $__138, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__141 = $ctx.wrapYieldStar($__139[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__142 = $__141[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__142.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__142.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__142.value;
                case 10:
                  $__140 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  e = $__140;
                  $ctx.state = 18;
                  break;
                case 18:
                  ret = void 0;
                  $ctx.state = 62;
                  break;
                case 62:
                  $ctx.state = (rt.cast(rt.boolTypeLiteral, e).v) ? 33 : 55;
                  break;
                case 33:
                  $__143 = interp.visit;
                  $__144 = s.Statement;
                  $__145 = $__143.call(interp, interp, $__144, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__147 = $ctx.wrapYieldStar($__145[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__148 = $__147[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__148.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__148.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__148.value;
                case 28:
                  $__146 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  ret = $__146;
                  $ctx.state = 36;
                  break;
                case 55:
                  $ctx.state = (s.ElseStatement) ? 51 : 36;
                  break;
                case 51:
                  $__149 = interp.visit;
                  $__150 = s.ElseStatement;
                  $__151 = $__149.call(interp, interp, $__150, param);
                  $ctx.state = 52;
                  break;
                case 52:
                  $__153 = $ctx.wrapYieldStar($__151[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__154 = $__153[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__154.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__154.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__154.value;
                case 46:
                  $__152 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  ret = $__152;
                  $ctx.state = 36;
                  break;
                case 36:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 64;
                  break;
                case 64:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__136, this);
        }),
        SelectionStatement_switch: $traceurRuntime.initGeneratorFunction(function $__155(interp, s, param) {
          var e,
              r,
              ret,
              scope_bak,
              switch_bak,
              $__156,
              $__157,
              $__158,
              $__159,
              $__160,
              $__161,
              $__162,
              $__163,
              $__164,
              $__165,
              $__166,
              $__167;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "SelectionStatement_switch";
                  rt.enterScope(param.scope);
                  $ctx.state = 40;
                  break;
                case 40:
                  $__156 = interp.visit;
                  $__157 = s.Expression;
                  $__158 = $__156.call(interp, interp, $__157, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__160 = $ctx.wrapYieldStar($__158[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__161 = $__160[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__161.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__161.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__161.value;
                case 10:
                  $__159 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  e = $__159;
                  $ctx.state = 18;
                  break;
                case 18:
                  switch_bak = param["switch"];
                  param["switch"] = e;
                  $ctx.state = 42;
                  break;
                case 42:
                  $__162 = interp.visit;
                  $__163 = s.Statement;
                  $__164 = $__162.call(interp, interp, $__163, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__166 = $ctx.wrapYieldStar($__164[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__167 = $__166[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__167.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__167.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__167.value;
                case 28:
                  $__165 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  r = $__165;
                  $ctx.state = 36;
                  break;
                case 36:
                  param["switch"] = switch_bak;
                  ret = void 0;
                  if (r instanceof Array) {
                    if (r[0] !== "break") {
                      ret = r;
                    }
                  }
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 44;
                  break;
                case 44:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__155, this);
        }),
        IterationStatement_while: $traceurRuntime.initGeneratorFunction(function $__168(interp, s, param) {
          var cond,
              end_loop,
              r,
              return_val,
              scope_bak,
              $__169,
              $__170,
              $__171,
              $__172,
              $__173,
              $__174,
              $__175,
              $__176,
              $__177,
              $__178,
              $__179,
              $__180;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "IterationStatement_while";
                  rt.enterScope(param.scope);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = (true) ? 24 : 57;
                  break;
                case 24:
                  $ctx.state = (s.Expression != null) ? 15 : 20;
                  break;
                case 15:
                  $__169 = interp.visit;
                  $__170 = s.Expression;
                  $__171 = $__169.call(interp, interp, $__170, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__173 = $ctx.wrapYieldStar($__171[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__174 = $__173[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__174.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__174.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__174.value;
                case 10:
                  $__172 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  cond = $__172;
                  $ctx.state = 18;
                  break;
                case 18:
                  cond = rt.cast(rt.boolTypeLiteral, cond).v;
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (!cond) ? 57 : 20;
                  break;
                case 20:
                  $__175 = interp.visit;
                  $__176 = s.Statement;
                  $__177 = $__175.call(interp, interp, $__176, param);
                  $ctx.state = 40;
                  break;
                case 40:
                  $__179 = $ctx.wrapYieldStar($__177[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 36;
                  break;
                case 36:
                  $__180 = $__179[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 33;
                  break;
                case 33:
                  $ctx.state = ($__180.done) ? 27 : 26;
                  break;
                case 27:
                  $ctx.sent = $__180.value;
                  $ctx.state = 34;
                  break;
                case 26:
                  $ctx.state = 36;
                  return $__180.value;
                case 34:
                  $__178 = $ctx.sentIgnoreThrow;
                  $ctx.state = 38;
                  break;
                case 38:
                  r = $__178;
                  $ctx.state = 42;
                  break;
                case 42:
                  $ctx.state = (r instanceof Array) ? 49 : 61;
                  break;
                case 49:
                  switch (r[0]) {
                    default:
                      $ctx.state = 50;
                      break;
                    case "continue":
                      $ctx.state = 50;
                      break;
                    case "break":
                      $ctx.state = 47;
                      break;
                    case "return":
                      $ctx.state = 51;
                      break;
                  }
                  break;
                case 47:
                  end_loop = true;
                  $ctx.state = 50;
                  break;
                case 51:
                  return_val = r;
                  end_loop = true;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.state = (end_loop) ? 57 : 61;
                  break;
                case 57:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 63;
                  break;
                case 63:
                  $ctx.returnValue = return_val;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__168, this);
        }),
        IterationStatement_do: $traceurRuntime.initGeneratorFunction(function $__181(interp, s, param) {
          var cond,
              end_loop,
              r,
              return_val,
              scope_bak,
              $__182,
              $__183,
              $__184,
              $__185,
              $__186,
              $__187,
              $__188,
              $__189,
              $__190,
              $__191,
              $__192,
              $__193;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "IterationStatement_do";
                  rt.enterScope(param.scope);
                  $ctx.state = 61;
                  break;
                case 61:
                  $ctx.state = (true) ? 15 : 57;
                  break;
                case 15:
                  $__182 = interp.visit;
                  $__183 = s.Statement;
                  $__184 = $__182.call(interp, interp, $__183, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__186 = $ctx.wrapYieldStar($__184[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__187 = $__186[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__187.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__187.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__187.value;
                case 10:
                  $__185 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  r = $__185;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.state = (r instanceof Array) ? 25 : 30;
                  break;
                case 25:
                  switch (r[0]) {
                    default:
                      $ctx.state = 26;
                      break;
                    case "continue":
                      $ctx.state = 26;
                      break;
                    case "break":
                      $ctx.state = 23;
                      break;
                    case "return":
                      $ctx.state = 27;
                      break;
                  }
                  break;
                case 23:
                  end_loop = true;
                  $ctx.state = 26;
                  break;
                case 27:
                  return_val = r;
                  end_loop = true;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = (end_loop) ? 57 : 30;
                  break;
                case 30:
                  $ctx.state = (s.Expression != null) ? 47 : 61;
                  break;
                case 47:
                  $__188 = interp.visit;
                  $__189 = s.Expression;
                  $__190 = $__188.call(interp, interp, $__189, param);
                  $ctx.state = 48;
                  break;
                case 48:
                  $__192 = $ctx.wrapYieldStar($__190[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 44;
                  break;
                case 44:
                  $__193 = $__192[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = ($__193.done) ? 35 : 34;
                  break;
                case 35:
                  $ctx.sent = $__193.value;
                  $ctx.state = 42;
                  break;
                case 34:
                  $ctx.state = 44;
                  return $__193.value;
                case 42:
                  $__191 = $ctx.sentIgnoreThrow;
                  $ctx.state = 46;
                  break;
                case 46:
                  cond = $__191;
                  $ctx.state = 50;
                  break;
                case 50:
                  cond = rt.cast(rt.boolTypeLiteral, cond).v;
                  $ctx.state = 55;
                  break;
                case 55:
                  $ctx.state = (!cond) ? 57 : 61;
                  break;
                case 57:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 63;
                  break;
                case 63:
                  $ctx.returnValue = return_val;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__181, this);
        }),
        IterationStatement_for: $traceurRuntime.initGeneratorFunction(function $__194(interp, s, param) {
          var cond,
              end_loop,
              r,
              return_val,
              scope_bak,
              $__195,
              $__196,
              $__197,
              $__198,
              $__199,
              $__200,
              $__201,
              $__202,
              $__203,
              $__204,
              $__205,
              $__206,
              $__207,
              $__208,
              $__209,
              $__210,
              $__211,
              $__212,
              $__213,
              $__214,
              $__215,
              $__216,
              $__217,
              $__218,
              $__219,
              $__220,
              $__221,
              $__222,
              $__223,
              $__224;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  scope_bak = param.scope;
                  param.scope = "IterationStatement_for";
                  rt.enterScope(param.scope);
                  $ctx.state = 112;
                  break;
                case 112:
                  $ctx.state = (s.Initializer) ? 33 : 14;
                  break;
                case 33:
                  $ctx.state = (s.Initializer.type === "Declaration") ? 15 : 31;
                  break;
                case 15:
                  $__195 = interp.visit;
                  $__196 = s.Initializer;
                  $__197 = $__195.call(interp, interp, $__196, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__199 = $ctx.wrapYieldStar($__197[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__200 = $__199[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__200.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__200.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__200.value;
                case 10:
                  $__198 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 31:
                  $__201 = interp.visit;
                  $__202 = s.Initializer;
                  $__203 = $__201.call(interp, interp, $__202, param);
                  $ctx.state = 32;
                  break;
                case 32:
                  $__205 = $ctx.wrapYieldStar($__203[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 28;
                  break;
                case 28:
                  $__206 = $__205[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = ($__206.done) ? 19 : 18;
                  break;
                case 19:
                  $ctx.sent = $__206.value;
                  $ctx.state = 26;
                  break;
                case 18:
                  $ctx.state = 28;
                  return $__206.value;
                case 26:
                  $__204 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (true) ? 58 : 108;
                  break;
                case 58:
                  $ctx.state = (s.Expression != null) ? 49 : 54;
                  break;
                case 49:
                  $__207 = interp.visit;
                  $__208 = s.Expression;
                  $__209 = $__207.call(interp, interp, $__208, param);
                  $ctx.state = 50;
                  break;
                case 50:
                  $__211 = $ctx.wrapYieldStar($__209[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 46;
                  break;
                case 46:
                  $__212 = $__211[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 43;
                  break;
                case 43:
                  $ctx.state = ($__212.done) ? 37 : 36;
                  break;
                case 37:
                  $ctx.sent = $__212.value;
                  $ctx.state = 44;
                  break;
                case 36:
                  $ctx.state = 46;
                  return $__212.value;
                case 44:
                  $__210 = $ctx.sentIgnoreThrow;
                  $ctx.state = 48;
                  break;
                case 48:
                  cond = $__210;
                  $ctx.state = 52;
                  break;
                case 52:
                  cond = rt.cast(rt.boolTypeLiteral, cond).v;
                  $ctx.state = 57;
                  break;
                case 57:
                  $ctx.state = (!cond) ? 108 : 54;
                  break;
                case 54:
                  $__213 = interp.visit;
                  $__214 = s.Statement;
                  $__215 = $__213.call(interp, interp, $__214, param);
                  $ctx.state = 74;
                  break;
                case 74:
                  $__217 = $ctx.wrapYieldStar($__215[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 70;
                  break;
                case 70:
                  $__218 = $__217[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 67;
                  break;
                case 67:
                  $ctx.state = ($__218.done) ? 61 : 60;
                  break;
                case 61:
                  $ctx.sent = $__218.value;
                  $ctx.state = 68;
                  break;
                case 60:
                  $ctx.state = 70;
                  return $__218.value;
                case 68:
                  $__216 = $ctx.sentIgnoreThrow;
                  $ctx.state = 72;
                  break;
                case 72:
                  r = $__216;
                  $ctx.state = 76;
                  break;
                case 76:
                  $ctx.state = (r instanceof Array) ? 83 : 88;
                  break;
                case 83:
                  switch (r[0]) {
                    default:
                      $ctx.state = 84;
                      break;
                    case "continue":
                      $ctx.state = 84;
                      break;
                    case "break":
                      $ctx.state = 81;
                      break;
                    case "return":
                      $ctx.state = 85;
                      break;
                  }
                  break;
                case 81:
                  end_loop = true;
                  $ctx.state = 84;
                  break;
                case 85:
                  return_val = r;
                  end_loop = true;
                  $ctx.state = 84;
                  break;
                case 84:
                  $ctx.state = (end_loop) ? 108 : 88;
                  break;
                case 88:
                  $ctx.state = (s.Loop) ? 105 : 14;
                  break;
                case 105:
                  $__219 = interp.visit;
                  $__220 = s.Loop;
                  $__221 = $__219.call(interp, interp, $__220, param);
                  $ctx.state = 106;
                  break;
                case 106:
                  $__223 = $ctx.wrapYieldStar($__221[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 102;
                  break;
                case 102:
                  $__224 = $__223[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 99;
                  break;
                case 99:
                  $ctx.state = ($__224.done) ? 93 : 92;
                  break;
                case 93:
                  $ctx.sent = $__224.value;
                  $ctx.state = 100;
                  break;
                case 92:
                  $ctx.state = 102;
                  return $__224.value;
                case 100:
                  $__222 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 108:
                  rt.exitScope(param.scope);
                  param.scope = scope_bak;
                  $ctx.state = 114;
                  break;
                case 114:
                  $ctx.returnValue = return_val;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__194, this);
        }),
        JumpStatement_goto: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        JumpStatement_continue: function(interp, s, param) {
          rt = interp.rt;
          return ["continue"];
        },
        JumpStatement_break: function(interp, s, param) {
          rt = interp.rt;
          return ["break"];
        },
        JumpStatement_return: $traceurRuntime.initGeneratorFunction(function $__225(interp, s, param) {
          var ret,
              $__226,
              $__227,
              $__228,
              $__229,
              $__230,
              $__231;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = (s.Expression) ? 15 : 20;
                  break;
                case 15:
                  $__226 = interp.visit;
                  $__227 = s.Expression;
                  $__228 = $__226.call(interp, interp, $__227, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__230 = $ctx.wrapYieldStar($__228[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__231 = $__230[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__231.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__231.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__231.value;
                case 10:
                  $__229 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__229;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = ["return", ret];
                  $ctx.state = -2;
                  break;
                case 20:
                  $ctx.returnValue = ["return"];
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__225, this);
        }),
        IdentifierExpression: function(interp, s, param) {
          rt = interp.rt;
          return rt.readVar(s.Identifier);
        },
        ParenthesesExpression: $traceurRuntime.initGeneratorFunction(function $__232(interp, s, param) {
          var $__233,
              $__234,
              $__235,
              $__236,
              $__237,
              $__238;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 20;
                  break;
                case 20:
                  $__233 = interp.visit;
                  $__234 = s.Expression;
                  $__235 = $__233.call(interp, interp, $__234, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__237 = $ctx.wrapYieldStar($__235[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__238 = $__237[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__238.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__238.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__238.value;
                case 10:
                  $__236 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__236;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__232, this);
        }),
        PostfixExpression_ArrayAccess: $traceurRuntime.initGeneratorFunction(function $__239(interp, s, param) {
          var index,
              r,
              ret,
              $__240,
              $__241,
              $__242,
              $__243,
              $__244,
              $__245,
              $__246,
              $__247,
              $__248,
              $__249,
              $__250,
              $__251,
              $__252,
              $__253,
              $__254;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 57;
                  break;
                case 57:
                  $__240 = interp.visit;
                  $__241 = s.Expression;
                  $__242 = $__240.call(interp, interp, $__241, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__244 = $ctx.wrapYieldStar($__242[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__245 = $__244[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__245.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__245.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__245.value;
                case 10:
                  $__243 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__243;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__246 = interp.visit;
                  $__247 = s.index;
                  $__248 = $__246.call(interp, interp, $__247, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__250 = $ctx.wrapYieldStar($__248[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__251 = $__250[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__251.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__251.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__251.value;
                case 28:
                  $__249 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  index = $__249;
                  $ctx.state = 36;
                  break;
                case 36:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("[]"), [index.t])(rt, ret, index);
                  $ctx.state = 59;
                  break;
                case 59:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__253 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__254 = $__253[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__254.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__254.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__254.value;
                case 46:
                  $__252 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__252;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__239, this);
        }),
        PostfixExpression_MethodInvocation: $traceurRuntime.initGeneratorFunction(function $__255(interp, s, param) {
          var args,
              bindThis,
              e,
              r,
              ret,
              thisArg,
              $__262,
              $__263,
              $__264,
              $__265,
              $__266,
              $__267,
              $__268,
              $__269,
              $__270,
              $__271,
              $__272,
              $__273,
              $__274,
              $__275,
              $__276,
              $__277;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 57;
                  break;
                case 57:
                  $__262 = interp.visit;
                  $__263 = s.Expression;
                  $__264 = $__262.call(interp, interp, $__263, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__266 = $ctx.wrapYieldStar($__264[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__267 = $__266[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__267.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__267.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__267.value;
                case 10:
                  $__265 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__265;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__268 = $traceurRuntime.initGeneratorFunction;
                  $__269 = function $__256() {
                    var k,
                        len,
                        ref,
                        results,
                        $__257,
                        $__258,
                        $__259,
                        $__260,
                        $__261;
                    return $traceurRuntime.createGeneratorInstance(function($ctx) {
                      while (true)
                        switch ($ctx.state) {
                          case 0:
                            ref = s.args;
                            results = [];
                            $ctx.state = 29;
                            break;
                          case 29:
                            k = 0, len = ref.length;
                            $ctx.state = 25;
                            break;
                          case 25:
                            $ctx.state = (k < len) ? 19 : 23;
                            break;
                          case 22:
                            k++;
                            $ctx.state = 25;
                            break;
                          case 19:
                            e = ref[k];
                            $ctx.state = 20;
                            break;
                          case 20:
                            $__257 = interp.visit;
                            $__258 = $__257.call(interp, interp, e, param);
                            $ctx.state = 16;
                            break;
                          case 16:
                            $__260 = $ctx.wrapYieldStar($__258[Symbol.iterator]());
                            $ctx.sent = void 0;
                            $ctx.action = 'next';
                            $ctx.state = 12;
                            break;
                          case 12:
                            $__261 = $__260[$ctx.action]($ctx.sentIgnoreThrow);
                            $ctx.state = 9;
                            break;
                          case 9:
                            $ctx.state = ($__261.done) ? 3 : 2;
                            break;
                          case 3:
                            $ctx.sent = $__261.value;
                            $ctx.state = 10;
                            break;
                          case 2:
                            $ctx.state = 12;
                            return $__261.value;
                          case 10:
                            $__259 = $ctx.sentIgnoreThrow;
                            $ctx.state = 14;
                            break;
                          case 14:
                            thisArg = $__259;
                            $ctx.state = 18;
                            break;
                          case 18:
                            results.push(thisArg);
                            $ctx.state = 22;
                            break;
                          case 23:
                            $ctx.returnValue = results;
                            $ctx.state = -2;
                            break;
                          default:
                            return $ctx.end();
                        }
                    }, $__256, this);
                  };
                  $__270 = $__268.call($traceurRuntime, $__269);
                  $__271 = $__270();
                  $ctx.state = 34;
                  break;
                case 34:
                  $__273 = $ctx.wrapYieldStar($__271[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__274 = $__273[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__274.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__274.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__274.value;
                case 28:
                  $__272 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  args = $__272;
                  $ctx.state = 36;
                  break;
                case 36:
                  if (ret.v.bindThis != null) {
                    bindThis = ret.v.bindThis;
                  } else {
                    bindThis = ret;
                  }
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("()"), args.map(function(e) {
                    return e.t;
                  }))(rt, ret, bindThis, args);
                  $ctx.state = 59;
                  break;
                case 59:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__276 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__277 = $__276[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__277.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__277.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__277.value;
                case 46:
                  $__275 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__275;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__255, this);
        }),
        PostfixExpression_MemberAccess: $traceurRuntime.initGeneratorFunction(function $__256(interp, s, param) {
          var ret,
              $__278,
              $__279,
              $__280,
              $__281,
              $__282,
              $__283;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__278 = interp.visit;
                  $__279 = s.Expression;
                  $__280 = $__278.call(interp, interp, $__279, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__282 = $ctx.wrapYieldStar($__280[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__283 = $__282[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__283.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__283.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__283.value;
                case 10:
                  $__281 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__281;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.getMember(ret, s.member);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__256, this);
        }),
        PostfixExpression_MemberPointerAccess: $traceurRuntime.initGeneratorFunction(function $__284(interp, s, param) {
          var member,
              r,
              ret,
              $__285,
              $__286,
              $__287,
              $__288,
              $__289,
              $__290,
              $__291,
              $__292,
              $__293,
              $__294,
              $__295,
              $__296,
              $__297,
              $__298,
              $__299,
              $__300,
              $__301,
              $__302,
              $__303;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 81;
                  break;
                case 81:
                  $__285 = interp.visit;
                  $__286 = s.Expression;
                  $__287 = $__285.call(interp, interp, $__286, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__289 = $ctx.wrapYieldStar($__287[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__290 = $__289[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__290.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__290.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__290.value;
                case 10:
                  $__288 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__288;
                  $ctx.state = 18;
                  break;
                case 18:
                  member = void 0;
                  $ctx.state = 83;
                  break;
                case 83:
                  $ctx.state = (rt.isPointerType(ret.t) && !rt.isFunctionType(ret.t)) ? 38 : 54;
                  break;
                case 38:
                  member = s.member;
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("->"), [])(rt, ret, member);
                  $ctx.state = 39;
                  break;
                case 39:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__292 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__293 = $__292[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__293.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__293.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__293.value;
                case 28:
                  $__291 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__291;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 54:
                  $__294 = interp.visit;
                  $__295 = s.member;
                  $__296 = {
                    type: "IdentifierExpression",
                    Identifier: $__295
                  };
                  $__297 = $__294.call(interp, interp, $__296, param);
                  $ctx.state = 55;
                  break;
                case 55:
                  $__299 = $ctx.wrapYieldStar($__297[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 51;
                  break;
                case 51:
                  $__300 = $__299[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 48;
                  break;
                case 48:
                  $ctx.state = ($__300.done) ? 42 : 41;
                  break;
                case 42:
                  $ctx.sent = $__300.value;
                  $ctx.state = 49;
                  break;
                case 41:
                  $ctx.state = 51;
                  return $__300.value;
                case 49:
                  $__298 = $ctx.sentIgnoreThrow;
                  $ctx.state = 53;
                  break;
                case 53:
                  member = $__298;
                  $ctx.state = 57;
                  break;
                case 57:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("->"), [member.t])(rt, ret, member);
                  $ctx.state = 78;
                  break;
                case 78:
                  $ctx.state = (isGenerator(r)) ? 68 : 74;
                  break;
                case 68:
                  $__302 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 69;
                  break;
                case 69:
                  $__303 = $__302[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 66;
                  break;
                case 66:
                  $ctx.state = ($__303.done) ? 60 : 59;
                  break;
                case 60:
                  $ctx.sent = $__303.value;
                  $ctx.state = 67;
                  break;
                case 59:
                  $ctx.state = 69;
                  return $__303.value;
                case 67:
                  $__301 = $ctx.sentIgnoreThrow;
                  $ctx.state = 71;
                  break;
                case 71:
                  $ctx.returnValue = $__301;
                  $ctx.state = -2;
                  break;
                case 74:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__284, this);
        }),
        PostfixExpression_PostIncrement: $traceurRuntime.initGeneratorFunction(function $__304(interp, s, param) {
          var r,
              ret,
              $__305,
              $__306,
              $__307,
              $__308,
              $__309,
              $__310,
              $__311,
              $__312,
              $__313;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__305 = interp.visit;
                  $__306 = s.Expression;
                  $__307 = $__305.call(interp, interp, $__306, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__309 = $ctx.wrapYieldStar($__307[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__310 = $__309[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__310.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__310.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__310.value;
                case 10:
                  $__308 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__308;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("++"), ["dummy"])(rt, ret, {
                    t: "dummy",
                    v: null
                  });
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__312 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__313 = $__312[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__313.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__313.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__313.value;
                case 28:
                  $__311 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__311;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__304, this);
        }),
        PostfixExpression_PostDecrement: $traceurRuntime.initGeneratorFunction(function $__314(interp, s, param) {
          var r,
              ret,
              $__315,
              $__316,
              $__317,
              $__318,
              $__319,
              $__320,
              $__321,
              $__322,
              $__323;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__315 = interp.visit;
                  $__316 = s.Expression;
                  $__317 = $__315.call(interp, interp, $__316, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__319 = $ctx.wrapYieldStar($__317[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__320 = $__319[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__320.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__320.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__320.value;
                case 10:
                  $__318 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__318;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("--"), ["dummy"])(rt, ret, {
                    t: "dummy",
                    v: null
                  });
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__322 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__323 = $__322[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__323.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__323.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__323.value;
                case 28:
                  $__321 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__321;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__314, this);
        }),
        UnaryExpression_PreIncrement: $traceurRuntime.initGeneratorFunction(function $__324(interp, s, param) {
          var r,
              ret,
              $__325,
              $__326,
              $__327,
              $__328,
              $__329,
              $__330,
              $__331,
              $__332,
              $__333;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__325 = interp.visit;
                  $__326 = s.Expression;
                  $__327 = $__325.call(interp, interp, $__326, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__329 = $ctx.wrapYieldStar($__327[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__330 = $__329[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__330.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__330.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__330.value;
                case 10:
                  $__328 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__328;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("++"), [])(rt, ret);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__332 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__333 = $__332[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__333.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__333.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__333.value;
                case 28:
                  $__331 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__331;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__324, this);
        }),
        UnaryExpression_PreDecrement: $traceurRuntime.initGeneratorFunction(function $__334(interp, s, param) {
          var r,
              ret,
              $__335,
              $__336,
              $__337,
              $__338,
              $__339,
              $__340,
              $__341,
              $__342,
              $__343;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__335 = interp.visit;
                  $__336 = s.Expression;
                  $__337 = $__335.call(interp, interp, $__336, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__339 = $ctx.wrapYieldStar($__337[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__340 = $__339[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__340.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__340.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__340.value;
                case 10:
                  $__338 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__338;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName("--"), [])(rt, ret);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__342 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__343 = $__342[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__343.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__343.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__343.value;
                case 28:
                  $__341 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__341;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__334, this);
        }),
        UnaryExpression: $traceurRuntime.initGeneratorFunction(function $__344(interp, s, param) {
          var r,
              ret,
              $__345,
              $__346,
              $__347,
              $__348,
              $__349,
              $__350,
              $__351,
              $__352,
              $__353;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 39;
                  break;
                case 39:
                  $__345 = interp.visit;
                  $__346 = s.Expression;
                  $__347 = $__345.call(interp, interp, $__346, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__349 = $ctx.wrapYieldStar($__347[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__350 = $__349[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__350.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__350.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__350.value;
                case 10:
                  $__348 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__348;
                  $ctx.state = 18;
                  break;
                case 18:
                  r = rt.getFunc(ret.t, rt.makeOperatorFuncName(s.op), [])(rt, ret);
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.state = (isGenerator(r)) ? 29 : 35;
                  break;
                case 29:
                  $__352 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__353 = $__352[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__353.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__353.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__353.value;
                case 28:
                  $__351 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__351;
                  $ctx.state = -2;
                  break;
                case 35:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__344, this);
        }),
        UnaryExpression_Sizeof_Expr: $traceurRuntime.initGeneratorFunction(function $__354(interp, s, param) {
          var ret,
              $__355,
              $__356,
              $__357,
              $__358,
              $__359,
              $__360;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__355 = interp.visit;
                  $__356 = s.Expression;
                  $__357 = $__355.call(interp, interp, $__356, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__359 = $ctx.wrapYieldStar($__357[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__360 = $__359[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__360.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__360.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__360.value;
                case 10:
                  $__358 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__358;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.val(rt.intTypeLiteral, rt.getSize(ret));
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__354, this);
        }),
        UnaryExpression_Sizeof_Type: $traceurRuntime.initGeneratorFunction(function $__361(interp, s, param) {
          var type,
              $__362,
              $__363,
              $__364,
              $__365,
              $__366,
              $__367;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__362 = interp.visit;
                  $__363 = s.TypeName;
                  $__364 = $__362.call(interp, interp, $__363, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__366 = $ctx.wrapYieldStar($__364[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__367 = $__366[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__367.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__367.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__367.value;
                case 10:
                  $__365 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  type = $__365;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.val(rt.intTypeLiteral, rt.getSizeByType(type));
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__361, this);
        }),
        CastExpression: $traceurRuntime.initGeneratorFunction(function $__368(interp, s, param) {
          var ret,
              type,
              $__369,
              $__370,
              $__371,
              $__372,
              $__373,
              $__374,
              $__375,
              $__376,
              $__377,
              $__378,
              $__379,
              $__380;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 40;
                  break;
                case 40:
                  $__369 = interp.visit;
                  $__370 = s.Expression;
                  $__371 = $__369.call(interp, interp, $__370, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__373 = $ctx.wrapYieldStar($__371[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__374 = $__373[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__374.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__374.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__374.value;
                case 10:
                  $__372 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__372;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__375 = interp.visit;
                  $__376 = s.TypeName;
                  $__377 = $__375.call(interp, interp, $__376, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__379 = $ctx.wrapYieldStar($__377[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__380 = $__379[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__380.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__380.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__380.value;
                case 28:
                  $__378 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  type = $__378;
                  $ctx.state = 36;
                  break;
                case 36:
                  $ctx.returnValue = rt.cast(type, ret);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__368, this);
        }),
        TypeName: function(interp, s, param) {
          var baseType,
              k,
              len,
              ref,
              typename;
          rt = interp.rt;
          typename = [];
          ref = s.base;
          for (k = 0, len = ref.length; k < len; k++) {
            baseType = ref[k];
            if (baseType !== "const") {
              typename.push(baseType);
            }
          }
          return rt.simpleType(typename);
        },
        BinOpExpression: $traceurRuntime.initGeneratorFunction(function $__381(interp, s, param) {
          var left,
              op,
              r,
              right,
              $__382,
              $__383,
              $__384,
              $__385,
              $__386,
              $__387,
              $__388,
              $__389,
              $__390,
              $__391,
              $__392,
              $__393,
              $__394,
              $__395,
              $__396,
              $__397,
              $__398,
              $__399,
              $__400,
              $__401,
              $__402,
              $__403,
              $__404,
              $__405,
              $__406;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  op = s.op;
                  $ctx.state = 101;
                  break;
                case 101:
                  $ctx.state = (op === "&&") ? 19 : 98;
                  break;
                case 19:
                  s.type = "LogicalANDExpression";
                  $ctx.state = 20;
                  break;
                case 20:
                  $__382 = interp.visit;
                  $__383 = $__382.call(interp, interp, s, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__385 = $ctx.wrapYieldStar($__383[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__386 = $__385[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__386.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__386.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__386.value;
                case 10:
                  $__384 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__384;
                  $ctx.state = -2;
                  break;
                case 98:
                  $ctx.state = (op === "||") ? 39 : 55;
                  break;
                case 39:
                  s.type = "LogicalORExpression";
                  $ctx.state = 40;
                  break;
                case 40:
                  $__387 = interp.visit;
                  $__388 = $__387.call(interp, interp, s, param);
                  $ctx.state = 36;
                  break;
                case 36:
                  $__390 = $ctx.wrapYieldStar($__388[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 32;
                  break;
                case 32:
                  $__391 = $__390[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.state = ($__391.done) ? 23 : 22;
                  break;
                case 23:
                  $ctx.sent = $__391.value;
                  $ctx.state = 30;
                  break;
                case 22:
                  $ctx.state = 32;
                  return $__391.value;
                case 30:
                  $__389 = $ctx.sentIgnoreThrow;
                  $ctx.state = 34;
                  break;
                case 34:
                  $ctx.returnValue = $__389;
                  $ctx.state = -2;
                  break;
                case 55:
                  $__392 = interp.visit;
                  $__393 = s.left;
                  $__394 = $__392.call(interp, interp, $__393, param);
                  $ctx.state = 56;
                  break;
                case 56:
                  $__396 = $ctx.wrapYieldStar($__394[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 52;
                  break;
                case 52:
                  $__397 = $__396[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 49;
                  break;
                case 49:
                  $ctx.state = ($__397.done) ? 43 : 42;
                  break;
                case 43:
                  $ctx.sent = $__397.value;
                  $ctx.state = 50;
                  break;
                case 42:
                  $ctx.state = 52;
                  return $__397.value;
                case 50:
                  $__395 = $ctx.sentIgnoreThrow;
                  $ctx.state = 54;
                  break;
                case 54:
                  left = $__395;
                  $ctx.state = 58;
                  break;
                case 58:
                  $__398 = interp.visit;
                  $__399 = s.right;
                  $__400 = $__398.call(interp, interp, $__399, param);
                  $ctx.state = 74;
                  break;
                case 74:
                  $__402 = $ctx.wrapYieldStar($__400[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 70;
                  break;
                case 70:
                  $__403 = $__402[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 67;
                  break;
                case 67:
                  $ctx.state = ($__403.done) ? 61 : 60;
                  break;
                case 61:
                  $ctx.sent = $__403.value;
                  $ctx.state = 68;
                  break;
                case 60:
                  $ctx.state = 70;
                  return $__403.value;
                case 68:
                  $__401 = $ctx.sentIgnoreThrow;
                  $ctx.state = 72;
                  break;
                case 72:
                  right = $__401;
                  $ctx.state = 76;
                  break;
                case 76:
                  r = rt.getFunc(left.t, rt.makeOperatorFuncName(op), [right.t])(rt, left, right);
                  $ctx.state = 97;
                  break;
                case 97:
                  $ctx.state = (isGenerator(r)) ? 87 : 93;
                  break;
                case 87:
                  $__405 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 88;
                  break;
                case 88:
                  $__406 = $__405[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 85;
                  break;
                case 85:
                  $ctx.state = ($__406.done) ? 79 : 78;
                  break;
                case 79:
                  $ctx.sent = $__406.value;
                  $ctx.state = 86;
                  break;
                case 78:
                  $ctx.state = 88;
                  return $__406.value;
                case 86:
                  $__404 = $ctx.sentIgnoreThrow;
                  $ctx.state = 90;
                  break;
                case 90:
                  $ctx.returnValue = $__404;
                  $ctx.state = -2;
                  break;
                case 93:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__381, this);
        }),
        LogicalANDExpression: $traceurRuntime.initGeneratorFunction(function $__407(interp, s, param) {
          var left,
              lt,
              r,
              right,
              $__408,
              $__409,
              $__410,
              $__411,
              $__412,
              $__413,
              $__414,
              $__415,
              $__416,
              $__417,
              $__418,
              $__419,
              $__420,
              $__421,
              $__422,
              $__423,
              $__424,
              $__425,
              $__426,
              $__427,
              $__428;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 81;
                  break;
                case 81:
                  $__408 = interp.visit;
                  $__409 = s.left;
                  $__410 = $__408.call(interp, interp, $__409, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__412 = $ctx.wrapYieldStar($__410[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__413 = $__412[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__413.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__413.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__413.value;
                case 10:
                  $__411 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  left = $__411;
                  $ctx.state = 18;
                  break;
                case 18:
                  lt = rt.types[rt.getTypeSignature(left.t)];
                  $ctx.state = 83;
                  break;
                case 83:
                  $ctx.state = ("&&" in lt) ? 33 : 78;
                  break;
                case 33:
                  $__414 = interp.visit;
                  $__415 = s.right;
                  $__416 = $__414.call(interp, interp, $__415, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__418 = $ctx.wrapYieldStar($__416[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__419 = $__418[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__419.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__419.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__419.value;
                case 28:
                  $__417 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  right = $__417;
                  $ctx.state = 36;
                  break;
                case 36:
                  r = rt.getFunc(left.t, rt.makeOperatorFuncName("&&"), [right.t])(rt, left, right);
                  $ctx.state = 57;
                  break;
                case 57:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__421 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__422 = $__421[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__422.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__422.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__422.value;
                case 46:
                  $__420 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__420;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 78:
                  $ctx.state = (rt.cast(rt.boolTypeLiteral, left).v) ? 72 : 76;
                  break;
                case 72:
                  $__423 = interp.visit;
                  $__424 = s.right;
                  $__425 = $__423.call(interp, interp, $__424, param);
                  $ctx.state = 73;
                  break;
                case 73:
                  $__427 = $ctx.wrapYieldStar($__425[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 69;
                  break;
                case 69:
                  $__428 = $__427[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 66;
                  break;
                case 66:
                  $ctx.state = ($__428.done) ? 60 : 59;
                  break;
                case 60:
                  $ctx.sent = $__428.value;
                  $ctx.state = 67;
                  break;
                case 59:
                  $ctx.state = 69;
                  return $__428.value;
                case 67:
                  $__426 = $ctx.sentIgnoreThrow;
                  $ctx.state = 71;
                  break;
                case 71:
                  $ctx.returnValue = $__426;
                  $ctx.state = -2;
                  break;
                case 76:
                  $ctx.returnValue = left;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__407, this);
        }),
        LogicalORExpression: $traceurRuntime.initGeneratorFunction(function $__429(interp, s, param) {
          var left,
              lt,
              r,
              right,
              $__430,
              $__431,
              $__432,
              $__433,
              $__434,
              $__435,
              $__436,
              $__437,
              $__438,
              $__439,
              $__440,
              $__441,
              $__442,
              $__443,
              $__444,
              $__445,
              $__446,
              $__447,
              $__448,
              $__449,
              $__450;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 81;
                  break;
                case 81:
                  $__430 = interp.visit;
                  $__431 = s.left;
                  $__432 = $__430.call(interp, interp, $__431, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__434 = $ctx.wrapYieldStar($__432[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__435 = $__434[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__435.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__435.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__435.value;
                case 10:
                  $__433 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  left = $__433;
                  $ctx.state = 18;
                  break;
                case 18:
                  lt = rt.types[rt.getTypeSignature(left.t)];
                  $ctx.state = 83;
                  break;
                case 83:
                  $ctx.state = ("||" in lt) ? 33 : 78;
                  break;
                case 33:
                  $__436 = interp.visit;
                  $__437 = s.right;
                  $__438 = $__436.call(interp, interp, $__437, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__440 = $ctx.wrapYieldStar($__438[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__441 = $__440[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__441.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__441.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__441.value;
                case 28:
                  $__439 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  right = $__439;
                  $ctx.state = 36;
                  break;
                case 36:
                  r = rt.getFunc(left.t, rt.makeOperatorFuncName("||"), [right.t])(rt, left, right);
                  $ctx.state = 57;
                  break;
                case 57:
                  $ctx.state = (isGenerator(r)) ? 47 : 53;
                  break;
                case 47:
                  $__443 = $ctx.wrapYieldStar(r[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__444 = $__443[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__444.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__444.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__444.value;
                case 46:
                  $__442 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__442;
                  $ctx.state = -2;
                  break;
                case 53:
                  $ctx.returnValue = r;
                  $ctx.state = -2;
                  break;
                case 78:
                  $ctx.state = (rt.cast(rt.boolTypeLiteral, left).v) ? 58 : 74;
                  break;
                case 58:
                  $ctx.returnValue = left;
                  $ctx.state = -2;
                  break;
                case 74:
                  $__445 = interp.visit;
                  $__446 = s.right;
                  $__447 = $__445.call(interp, interp, $__446, param);
                  $ctx.state = 75;
                  break;
                case 75:
                  $__449 = $ctx.wrapYieldStar($__447[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 71;
                  break;
                case 71:
                  $__450 = $__449[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 68;
                  break;
                case 68:
                  $ctx.state = ($__450.done) ? 62 : 61;
                  break;
                case 62:
                  $ctx.sent = $__450.value;
                  $ctx.state = 69;
                  break;
                case 61:
                  $ctx.state = 71;
                  return $__450.value;
                case 69:
                  $__448 = $ctx.sentIgnoreThrow;
                  $ctx.state = 73;
                  break;
                case 73:
                  $ctx.returnValue = $__448;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__429, this);
        }),
        ConditionalExpression: $traceurRuntime.initGeneratorFunction(function $__451(interp, s, param) {
          var cond,
              $__452,
              $__453,
              $__454,
              $__455,
              $__456,
              $__457,
              $__458,
              $__459,
              $__460,
              $__461,
              $__462,
              $__463,
              $__464,
              $__465,
              $__466,
              $__467,
              $__468,
              $__469,
              $__470,
              $__471,
              $__472,
              $__473;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 57;
                  break;
                case 57:
                  $__452 = rt.cast;
                  $__453 = rt.boolTypeLiteral;
                  $__454 = interp.visit;
                  $__455 = s.cond;
                  $__456 = $__454.call(interp, interp, $__455, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__460 = $ctx.wrapYieldStar($__456[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__461 = $__460[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__461.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__461.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__461.value;
                case 10:
                  $__457 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__458 = $__452.call(rt, $__453, $__457);
                  $__459 = $__458.v;
                  cond = $__459;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.state = (cond) ? 33 : 51;
                  break;
                case 33:
                  $__462 = interp.visit;
                  $__463 = s.t;
                  $__464 = $__462.call(interp, interp, $__463, param);
                  $ctx.state = 34;
                  break;
                case 34:
                  $__466 = $ctx.wrapYieldStar($__464[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 30;
                  break;
                case 30:
                  $__467 = $__466[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.state = ($__467.done) ? 21 : 20;
                  break;
                case 21:
                  $ctx.sent = $__467.value;
                  $ctx.state = 28;
                  break;
                case 20:
                  $ctx.state = 30;
                  return $__467.value;
                case 28:
                  $__465 = $ctx.sentIgnoreThrow;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.returnValue = $__465;
                  $ctx.state = -2;
                  break;
                case 51:
                  $__468 = interp.visit;
                  $__469 = s.f;
                  $__470 = $__468.call(interp, interp, $__469, param);
                  $ctx.state = 52;
                  break;
                case 52:
                  $__472 = $ctx.wrapYieldStar($__470[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 48;
                  break;
                case 48:
                  $__473 = $__472[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 45;
                  break;
                case 45:
                  $ctx.state = ($__473.done) ? 39 : 38;
                  break;
                case 39:
                  $ctx.sent = $__473.value;
                  $ctx.state = 46;
                  break;
                case 38:
                  $ctx.state = 48;
                  return $__473.value;
                case 46:
                  $__471 = $ctx.sentIgnoreThrow;
                  $ctx.state = 50;
                  break;
                case 50:
                  $ctx.returnValue = $__471;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__451, this);
        }),
        ConstantExpression: $traceurRuntime.initGeneratorFunction(function $__474(interp, s, param) {
          var $__475,
              $__476,
              $__477,
              $__478,
              $__479,
              $__480;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 20;
                  break;
                case 20:
                  $__475 = interp.visit;
                  $__476 = s.Expression;
                  $__477 = $__475.call(interp, interp, $__476, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__479 = $ctx.wrapYieldStar($__477[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__480 = $__479[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__480.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__480.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__480.value;
                case 10:
                  $__478 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__478;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__474, this);
        }),
        StringLiteralExpression: $traceurRuntime.initGeneratorFunction(function $__481(interp, s, param) {
          var $__482,
              $__483,
              $__484,
              $__485,
              $__486,
              $__487;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__482 = interp.visit;
                  $__483 = s.value;
                  $__484 = $__482.call(interp, interp, $__483, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__486 = $ctx.wrapYieldStar($__484[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__487 = $__486[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__487.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__487.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__487.value;
                case 10:
                  $__485 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.returnValue = $__485;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__481, this);
        }),
        StringLiteral: function(interp, s, param) {
          var code,
              i,
              k,
              len,
              limits,
              maxCode,
              minCode,
              ref,
              typeName;
          rt = interp.rt;
          switch (s.prefix) {
            case null:
              maxCode = -1;
              minCode = 1;
              ref = s.value;
              for (k = 0, len = ref.length; k < len; k++) {
                i = ref[k];
                code = i.charCodeAt(0);
                if (maxCode < code) {
                  maxCode = code;
                }
                if (minCode > code) {
                  minCode = code;
                }
              }
              limits = rt.config.limits;
              typeName = maxCode <= limits["char"].max && minCode >= limits["char"].min ? "char" : "wchar_t";
              return rt.makeCharArrayFromString(s.value, typeName);
            case "L":
              return rt.makeCharArrayFromString(s.value, "wchar_t");
            case "u8":
              return rt.makeCharArrayFromString(s.value, "char");
            case "u":
              return rt.makeCharArrayFromString(s.value, "char16_t");
            case "U":
              return rt.makeCharArrayFromString(s.value, "char32_t");
          }
        },
        BooleanConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.boolTypeLiteral, s.value === "true" ? 1 : 0);
        },
        CharacterConstant: function(interp, s, param) {
          var a;
          rt = interp.rt;
          a = s.Char;
          if (a.length !== 1) {
            rt.raiseException("a character constant must have and only have one character.");
          }
          return rt.val(rt.charTypeLiteral, a[0].charCodeAt(0));
        },
        FloatConstant: $traceurRuntime.initGeneratorFunction(function $__488(interp, s, param) {
          var val,
              $__489,
              $__490,
              $__491,
              $__492,
              $__493,
              $__494;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = interp.rt;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__489 = interp.visit;
                  $__490 = s.Expression;
                  $__491 = $__489.call(interp, interp, $__490, param);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__493 = $ctx.wrapYieldStar($__491[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__494 = $__493[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__494.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__494.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__494.value;
                case 10:
                  $__492 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  val = $__492;
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.returnValue = rt.val(rt.floatTypeLiteral, val.v);
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__488, this);
        }),
        DecimalConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 10));
        },
        HexConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 16));
        },
        BinaryConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 2));
        },
        DecimalFloatConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.doubleTypeLiteral, parseFloat(s.value));
        },
        HexFloatConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.doubleTypeLiteral, parseFloat(s.value, 16));
        },
        OctalConstant: function(interp, s, param) {
          rt = interp.rt;
          return rt.val(rt.unsignedintTypeLiteral, parseInt(s.value, 8));
        },
        NamespaceDefinition: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        UsingDirective: function(interp, s, param) {
          var id;
          rt = interp.rt;
          id = s.Identifier;
        },
        UsingDeclaration: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        NamespaceAliasDefinition: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("not implemented");
        },
        unknown: function(interp, s, param) {
          rt = interp.rt;
          rt.raiseException("unhandled syntax " + s.type);
        }
      };
    };
    Interpreter.prototype.visit = $traceurRuntime.initGeneratorFunction(function $__4(interp, s, param) {
      var _node,
          f,
          ret,
          rt,
          $__495,
          $__496,
          $__497,
          $__498,
          $__499,
          $__500;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              rt = interp.rt;
              $ctx.state = 41;
              break;
            case 41:
              $ctx.state = ("type" in s) ? 31 : 35;
              break;
            case 31:
              if (param === void 0) {
                param = {scope: "global"};
              }
              _node = this.currentNode;
              this.currentNode = s;
              $ctx.state = 32;
              break;
            case 32:
              $ctx.state = (s.type in this.visitors) ? 26 : 28;
              break;
            case 26:
              f = this.visitors[s.type];
              $ctx.state = 27;
              break;
            case 27:
              $ctx.state = (isGeneratorFunction(f)) ? 15 : 23;
              break;
            case 15:
              $__495 = f(interp, s, param);
              $ctx.state = 16;
              break;
            case 16:
              $__497 = $ctx.wrapYieldStar($__495[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__498 = $__497[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__498.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__498.value;
              $ctx.state = 10;
              break;
            case 2:
              $ctx.state = 12;
              return $__498.value;
            case 10:
              $__496 = $ctx.sentIgnoreThrow;
              $ctx.state = 14;
              break;
            case 14:
              ret = $__496;
              $ctx.state = 18;
              break;
            case 23:
              $__499 = f(interp, s, param);
              ret = $__499;
              $ctx.state = 24;
              break;
            case 24:
              $ctx.state = 20;
              return $__499;
            case 20:
              $__500 = $ctx.sent;
              $ctx.state = 18;
              break;
            case 28:
              ret = this.visitors["unknown"](interp, s, param);
              $ctx.state = 18;
              break;
            case 18:
              this.currentNode = _node;
              $ctx.state = 34;
              break;
            case 35:
              this.currentNode = s;
              this.rt.raiseException("untyped syntax structure");
              $ctx.state = 34;
              break;
            case 34:
              $ctx.returnValue = ret;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__4, this);
    });
    Interpreter.prototype.run = $traceurRuntime.initGeneratorFunction(function $__10(tree) {
      var $__501,
          $__502,
          $__503,
          $__504,
          $__505;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              this.rt.interp = this;
              $ctx.state = 20;
              break;
            case 20:
              $__501 = this.visit;
              $__502 = $__501.call(this, this, tree);
              $ctx.state = 16;
              break;
            case 16:
              $__504 = $ctx.wrapYieldStar($__502[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__505 = $__504[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__505.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__505.value;
              $ctx.state = 10;
              break;
            case 2:
              $ctx.state = 12;
              return $__505.value;
            case 10:
              $__503 = $ctx.sentIgnoreThrow;
              $ctx.state = 14;
              break;
            case 14:
              $ctx.returnValue = $__503;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__10, this);
    });
    Interpreter.prototype.arrayInit = $traceurRuntime.initGeneratorFunction(function $__37(dimensions, init, level, type, param) {
      var _init,
          arr,
          curDim,
          i,
          initializer,
          initval,
          ret,
          val,
          $__506,
          $__507,
          $__508,
          $__509,
          $__510,
          $__511,
          $__512,
          $__513,
          $__514,
          $__515,
          $__516,
          $__517,
          $__518,
          $__519,
          $__520,
          $__521,
          $__522,
          $__523,
          $__524,
          $__525,
          $__526,
          $__527,
          $__528,
          $__529,
          $__530,
          $__531,
          $__532,
          $__533,
          $__534,
          $__535,
          $__536,
          $__537,
          $__538,
          $__539,
          $__540,
          $__541,
          $__542,
          $__543,
          $__544,
          $__545,
          $__546;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              arr = void 0;
              i = void 0;
              ret = void 0;
              initval = void 0;
              $ctx.state = 163;
              break;
            case 163:
              $ctx.state = (dimensions.length > level) ? 127 : 157;
              break;
            case 127:
              curDim = dimensions[level];
              $ctx.state = 128;
              break;
            case 128:
              $ctx.state = (init) ? 83 : 53;
              break;
            case 83:
              $ctx.state = (init.type === "Initializer_array" && curDim >= init.Initializers.length && (init.Initializers.length === 0 || init.Initializers[0].type === "Initializer_expr")) ? 54 : 82;
              break;
            case 54:
              $ctx.state = (init.Initializers.length === 0) ? 52 : 51;
              break;
            case 52:
              arr = new Array(curDim);
              i = 0;
              while (i < curDim) {
                arr[i] = {
                  type: "Initializer_expr",
                  shorthand: this.rt.defaultValue(type)
                };
                i++;
              }
              init.Initializers = arr;
              $ctx.state = 53;
              break;
            case 51:
              $ctx.state = (init.Initializers.length === 1 && this.rt.isIntegerType(type)) ? 15 : 47;
              break;
            case 15:
              $__506 = this.rt;
              $__507 = $__506.cast;
              $__508 = this.visit;
              $__509 = init.Initializers;
              $__510 = $__509[0];
              $__511 = $__510.Expression;
              $__512 = $__508.call(this, this, $__511, param);
              $ctx.state = 16;
              break;
            case 16:
              $__515 = $ctx.wrapYieldStar($__512[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 12;
              break;
            case 12:
              $__516 = $__515[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 9;
              break;
            case 9:
              $ctx.state = ($__516.done) ? 3 : 2;
              break;
            case 3:
              $ctx.sent = $__516.value;
              $ctx.state = 10;
              break;
            case 2:
              $ctx.state = 12;
              return $__516.value;
            case 10:
              $__513 = $ctx.sentIgnoreThrow;
              $ctx.state = 14;
              break;
            case 14:
              $__514 = $__507.call($__506, type, $__513);
              val = $__514;
              $ctx.state = 18;
              break;
            case 18:
              if (val.v === -1 || val.v === 0) {
                arr = new Array(curDim);
                i = 0;
                while (i < curDim) {
                  arr[i] = {
                    type: "Initializer_expr",
                    shorthand: this.rt.val(type, val.v)
                  };
                  i++;
                }
                init.Initializers = arr;
              } else {
                arr = new Array(curDim);
                arr[0] = this.rt.val(type, -1);
                i = 1;
                while (i < curDim) {
                  arr[i] = {
                    type: "Initializer_expr",
                    shorthand: this.rt.defaultValue(type)
                  };
                  i++;
                }
                init.Initializers = arr;
              }
              $ctx.state = 53;
              break;
            case 47:
              arr = new Array(curDim);
              i = 0;
              $ctx.state = 48;
              break;
            case 48:
              $ctx.state = (i < init.Initializers.length) ? 42 : 46;
              break;
            case 42:
              _init = init.Initializers[i];
              $ctx.state = 43;
              break;
            case 43:
              $ctx.state = ("shorthand" in _init) ? 39 : 35;
              break;
            case 39:
              initval = _init;
              $ctx.state = 40;
              break;
            case 35:
              $__517 = this.visit;
              $__518 = _init.Expression;
              $__519 = $__517.call(this, this, $__518, param);
              $ctx.state = 36;
              break;
            case 36:
              $__522 = $ctx.wrapYieldStar($__519[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 32;
              break;
            case 32:
              $__523 = $__522[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 29;
              break;
            case 29:
              $ctx.state = ($__523.done) ? 23 : 22;
              break;
            case 23:
              $ctx.sent = $__523.value;
              $ctx.state = 30;
              break;
            case 22:
              $ctx.state = 32;
              return $__523.value;
            case 30:
              $__520 = $ctx.sentIgnoreThrow;
              $ctx.state = 34;
              break;
            case 34:
              $__521 = {
                type: "Initializer_expr",
                shorthand: $__520
              };
              initval = $__521;
              $ctx.state = 40;
              break;
            case 40:
              arr[i] = initval;
              i++;
              $ctx.state = 48;
              break;
            case 46:
              i = init.Initializers.length;
              while (i < curDim) {
                arr[i] = {
                  type: "Initializer_expr",
                  shorthand: this.rt.defaultValue(type)
                };
                i++;
              }
              init.Initializers = arr;
              $ctx.state = 53;
              break;
            case 82:
              $ctx.state = (init.type === "Initializer_expr") ? 76 : 80;
              break;
            case 76:
              initializer = void 0;
              $ctx.state = 77;
              break;
            case 77:
              $ctx.state = ("shorthand" in init) ? 73 : 69;
              break;
            case 73:
              initializer = init.shorthand;
              $ctx.state = 74;
              break;
            case 69:
              $__524 = this.visit;
              $__525 = $__524.call(this, this, init, param);
              $ctx.state = 70;
              break;
            case 70:
              $__527 = $ctx.wrapYieldStar($__525[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 66;
              break;
            case 66:
              $__528 = $__527[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 63;
              break;
            case 63:
              $ctx.state = ($__528.done) ? 57 : 56;
              break;
            case 57:
              $ctx.sent = $__528.value;
              $ctx.state = 64;
              break;
            case 56:
              $ctx.state = 66;
              return $__528.value;
            case 64:
              $__526 = $ctx.sentIgnoreThrow;
              $ctx.state = 68;
              break;
            case 68:
              initializer = $__526;
              $ctx.state = 74;
              break;
            case 74:
              if (this.rt.isCharType(type) && this.rt.isArrayType(initializer.t) && this.rt.isCharType(initializer.t.eleType)) {
                init = {
                  type: "Initializer_array",
                  Initializers: initializer.v.target.map(function(e) {
                    return {
                      type: "Initializer_expr",
                      shorthand: e
                    };
                  })
                };
              } else {
                this.rt.raiseException("cannot initialize an array to " + this.rt.makeValString(initializer));
              }
              $ctx.state = 53;
              break;
            case 80:
              this.rt.raiseException("dimensions do not agree, " + curDim + " != " + init.Initializers.length);
              $ctx.state = 53;
              break;
            case 53:
              arr = [];
              ret = this.rt.val(this.arrayType(dimensions, level, type), this.rt.makeArrayPointerValue(arr, 0), true);
              i = 0;
              $ctx.state = 130;
              break;
            case 130:
              $ctx.state = (i < curDim) ? 121 : 124;
              break;
            case 121:
              $ctx.state = (init && i < init.Initializers.length) ? 99 : 117;
              break;
            case 99:
              $__529 = this.arrayInit;
              $__530 = init.Initializers;
              $__531 = $__530[i];
              $__532 = $__529.call(this, dimensions, $__531, level + 1, type, param);
              $ctx.state = 100;
              break;
            case 100:
              $__534 = $ctx.wrapYieldStar($__532[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 96;
              break;
            case 96:
              $__535 = $__534[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 93;
              break;
            case 93:
              $ctx.state = ($__535.done) ? 87 : 86;
              break;
            case 87:
              $ctx.sent = $__535.value;
              $ctx.state = 94;
              break;
            case 86:
              $ctx.state = 96;
              return $__535.value;
            case 94:
              $__533 = $ctx.sentIgnoreThrow;
              $ctx.state = 98;
              break;
            case 98:
              arr[i] = $__533;
              $ctx.state = 102;
              break;
            case 117:
              $__536 = this.arrayInit;
              $__537 = $__536.call(this, dimensions, null, level + 1, type, param);
              $ctx.state = 118;
              break;
            case 118:
              $__539 = $ctx.wrapYieldStar($__537[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 114;
              break;
            case 114:
              $__540 = $__539[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 111;
              break;
            case 111:
              $ctx.state = ($__540.done) ? 105 : 104;
              break;
            case 105:
              $ctx.sent = $__540.value;
              $ctx.state = 112;
              break;
            case 104:
              $ctx.state = 114;
              return $__540.value;
            case 112:
              $__538 = $ctx.sentIgnoreThrow;
              $ctx.state = 116;
              break;
            case 116:
              arr[i] = $__538;
              $ctx.state = 102;
              break;
            case 102:
              i++;
              $ctx.state = 130;
              break;
            case 124:
              $ctx.returnValue = ret;
              $ctx.state = -2;
              break;
            case 157:
              if (init && init.type !== "Initializer_expr") {
                this.rt.raiseException("dimensions do not agree, too few initializers");
              }
              $ctx.state = 158;
              break;
            case 158:
              $ctx.state = (init) ? 151 : 152;
              break;
            case 151:
              $ctx.state = ("shorthand" in init) ? 149 : 145;
              break;
            case 149:
              initval = init.shorthand;
              $ctx.state = 150;
              break;
            case 145:
              $__541 = this.visit;
              $__542 = init.Expression;
              $__543 = $__541.call(this, this, $__542, param);
              $ctx.state = 146;
              break;
            case 146:
              $__545 = $ctx.wrapYieldStar($__543[Symbol.iterator]());
              $ctx.sent = void 0;
              $ctx.action = 'next';
              $ctx.state = 142;
              break;
            case 142:
              $__546 = $__545[$ctx.action]($ctx.sentIgnoreThrow);
              $ctx.state = 139;
              break;
            case 139:
              $ctx.state = ($__546.done) ? 133 : 132;
              break;
            case 133:
              $ctx.sent = $__546.value;
              $ctx.state = 140;
              break;
            case 132:
              $ctx.state = 142;
              return $__546.value;
            case 140:
              $__544 = $ctx.sentIgnoreThrow;
              $ctx.state = 144;
              break;
            case 144:
              initval = $__544;
              $ctx.state = 150;
              break;
            case 152:
              initval = this.rt.defaultValue(type);
              $ctx.state = 150;
              break;
            case 150:
              ret = this.rt.cast(type, initval);
              ret.left = true;
              $ctx.state = 160;
              break;
            case 160:
              $ctx.returnValue = ret;
              $ctx.state = -2;
              break;
            default:
              return $ctx.end();
          }
      }, $__37, this);
    });
    Interpreter.prototype.arrayType = function(dimensions, level, type) {
      if (dimensions.length > level) {
        return this.rt.arrayPointerType(this.arrayType(dimensions, level + 1, type), dimensions[level]);
      } else {
        return type;
      }
    };
    Interpreter.prototype.buildRecursivePointerType = function(pointer, basetype, level) {
      var type;
      if (pointer && pointer.length > level) {
        type = this.rt.normalPointerType(basetype);
        return this.buildRecursivePointerType(pointer, type, level + 1);
      } else {
        return basetype;
      }
    };
    module.exports = Interpreter;
  }, {}],
  13: [function(require, module, exports) {
    (function(process) {
      var CRuntime,
          Debugger,
          Interpreter,
          PEGUtil,
          alias,
          ast,
          headerAlias,
          includes,
          mergeConfig,
          preprocessor,
          realName;
      CRuntime = require("./rt");
      Interpreter = require("./interpreter");
      ast = require("./ast");
      preprocessor = require("./preprocessor");
      Debugger = require("./debugger");
      PEGUtil = require("pegjs-util");
      mergeConfig = function(a, b) {
        var o;
        for (o in b) {
          if (o in a && $traceurRuntime.typeof(b[o]) === "object") {
            mergeConfig(a[o], b[o]);
          } else {
            a[o] = b[o];
          }
        }
      };
      includes = {
        iostream: require("./includes/iostream"),
        cctype: require("./includes/cctype"),
        cstring: require("./includes/cstring"),
        cmath: require("./includes/cmath"),
        cstdio: require("./includes/cstdio"),
        cstdlib: require("./includes/cstdlib"),
        iomanip: require("./includes/iomanip")
      };
      headerAlias = {
        "ctype.h": "cctype",
        "string.h": "cstring",
        "math.h": "cmath",
        "stdio.h": "cstdio",
        "stdlib.h": "cstdlib"
      };
      for (alias in headerAlias) {
        realName = headerAlias[alias];
        includes[alias] = includes[realName];
      }
      module.exports = {
        includes: includes,
        run: function(code, input, config) {
          var _config,
              defGen,
              inputbuffer,
              interpreter,
              mainGen,
              mydebugger,
              result,
              rt,
              self,
              step;
          inputbuffer = input.toString();
          self = this;
          _config = {
            stdio: {
              drain: function() {
                var x;
                x = inputbuffer;
                inputbuffer = null;
                return x;
              },
              write: function(s) {
                process.stdout.write(s);
              }
            },
            includes: self.includes
          };
          mergeConfig(_config, config);
          rt = new CRuntime(_config);
          code = code.toString();
          code = preprocessor.parse(rt, code);
          mydebugger = new Debugger();
          if (_config.debug) {
            mydebugger.src = code;
          }
          result = PEGUtil.parse(ast, code);
          if (result.error != null) {
            throw "ERROR: Parsing Failure:\n" + PEGUtil.errorMessage(result.error, true);
          }
          interpreter = new Interpreter(rt);
          defGen = interpreter.run(result.ast);
          while (true) {
            step = defGen.next();
            if (step.done) {
              break;
            }
          }
          mainGen = rt.getFunc("global", "main", [])(rt, null, []);
          if (_config.debug) {
            mydebugger.start(rt, mainGen);
            return mydebugger;
          } else {
            while (true) {
              step = mainGen.next();
              if (step.done) {
                break;
              }
            }
            return step.value.v;
          }
        }
      };
    }).call(this, require('_process'));
  }, {
    "./ast": 1,
    "./debugger": 2,
    "./includes/cctype": 4,
    "./includes/cmath": 5,
    "./includes/cstdio": 6,
    "./includes/cstdlib": 7,
    "./includes/cstring": 8,
    "./includes/iomanip": 9,
    "./includes/iostream": 10,
    "./interpreter": 12,
    "./preprocessor": 16,
    "./rt": 17,
    "_process": 27,
    "pegjs-util": 45
  }],
  14: [function(require, module, exports) {
    module.exports = require("./launcher");
  }, {"./launcher": 13}],
  15: [function(require, module, exports) {
    module.exports = (function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      function peg$parse(input) {
        var options = arguments.length > 1 ? arguments[1] : {},
            parser = this,
            peg$FAILED = {},
            peg$startRuleFunctions = {TranslationUnit: peg$parseTranslationUnit},
            peg$startRuleFunction = peg$parseTranslationUnit,
            peg$c0 = function(a, b) {
              return addPositionInfo({
                type: 'Code',
                val: a,
                space: b
              });
            },
            peg$c1 = function(a) {
              return addPositionInfo({
                type: 'TranslationUnit',
                lines: a
              });
            },
            peg$c2 = function(a, b) {
              a.space = b;
              return a;
            },
            peg$c3 = function(a) {
              return addPositionInfo({
                type: 'PrepUndef',
                Identifier: a
              });
            },
            peg$c4 = function(a, b) {
              return addPositionInfo({
                type: 'PrepSimpleMacro',
                Identifier: a,
                Replacement: b
              });
            },
            peg$c5 = function(a, b, c) {
              return addPositionInfo({
                type: 'PrepFunctionMacro',
                Identifier: a,
                Args: b,
                Replacement: c
              });
            },
            peg$c6 = function(a) {
              return a;
            },
            peg$c7 = function(a, b) {
              return [a].concat(b);
            },
            peg$c8 = function(a, b, c) {
              return {
                type: 'PrepFunctionMacroCall',
                Identifier: a,
                Args: b,
                space: c
              };
            },
            peg$c9 = function(a) {
              var ret = [];
              var lastString = null;
              for (var i = 0; i < a.length; i++) {
                if (a[i].type === 'Seperator') {
                  if (lastString === null) {
                    lastString = a[i];
                  } else {
                    lastString.val += lastString.space + a[i].val;
                    lastString.space = a[i].space;
                  }
                } else {
                  if (lastString !== null) {
                    ret.push(lastString);
                    lastString = null;
                  }
                  ret.push(a[i]);
                }
              }
              if (lastString !== null)
                ret.push(lastString);
              return ret;
            },
            peg$c10 = function(a) {
              return addPositionInfo({
                type: 'PrepIncludeLib',
                name: a
              });
            },
            peg$c11 = function(a) {
              return addPositionInfo({
                type: 'PrepIncludeLocal',
                name: a
              });
            },
            peg$c12 = /^[\/\\.]/,
            peg$c13 = {
              type: "class",
              value: "[/\\\\.]",
              description: "[/\\\\.]"
            },
            peg$c14 = function(a) {
              return a.join('');
            },
            peg$c15 = function(a) {
              return addPositionInfo({
                type: 'PrepIfdef',
                Identifier: a
              });
            },
            peg$c16 = function(a) {
              return addPositionInfo({
                type: 'PrepIfndef',
                Identifier: a
              });
            },
            peg$c17 = function() {
              return addPositionInfo({type: 'PrepEndif'});
            },
            peg$c18 = function() {
              return addPositionInfo({type: 'PrepElse'});
            },
            peg$c19 = "#",
            peg$c20 = {
              type: "literal",
              value: "#",
              description: "\"#\""
            },
            peg$c21 = "define",
            peg$c22 = {
              type: "literal",
              value: "define",
              description: "\"define\""
            },
            peg$c23 = "undef",
            peg$c24 = {
              type: "literal",
              value: "undef",
              description: "\"undef\""
            },
            peg$c25 = "include",
            peg$c26 = {
              type: "literal",
              value: "include",
              description: "\"include\""
            },
            peg$c27 = "ifdef",
            peg$c28 = {
              type: "literal",
              value: "ifdef",
              description: "\"ifdef\""
            },
            peg$c29 = "ifndef",
            peg$c30 = {
              type: "literal",
              value: "ifndef",
              description: "\"ifndef\""
            },
            peg$c31 = "endif",
            peg$c32 = {
              type: "literal",
              value: "endif",
              description: "\"endif\""
            },
            peg$c33 = "else",
            peg$c34 = {
              type: "literal",
              value: "else",
              description: "\"else\""
            },
            peg$c35 = function(a) {
              return a.join('');
            },
            peg$c36 = /^[ \t\x0B\f]/,
            peg$c37 = {
              type: "class",
              value: "[ \\t\\u000B\\u000C]",
              description: "[ \\t\\u000B\\u000C]"
            },
            peg$c38 = /^[ \n\r\t\x0B\f]/,
            peg$c39 = {
              type: "class",
              value: "[ \\n\\r\\t\\u000B\\u000C]",
              description: "[ \\n\\r\\t\\u000B\\u000C]"
            },
            peg$c40 = "/*",
            peg$c41 = {
              type: "literal",
              value: "/*",
              description: "\"/*\""
            },
            peg$c42 = "*/",
            peg$c43 = {
              type: "literal",
              value: "*/",
              description: "\"*/\""
            },
            peg$c44 = function(a) {
              return '';
            },
            peg$c45 = "//",
            peg$c46 = {
              type: "literal",
              value: "//",
              description: "\"//\""
            },
            peg$c47 = "\n",
            peg$c48 = {
              type: "literal",
              value: "\n",
              description: "\"\\n\""
            },
            peg$c49 = "auto",
            peg$c50 = {
              type: "literal",
              value: "auto",
              description: "\"auto\""
            },
            peg$c51 = "break",
            peg$c52 = {
              type: "literal",
              value: "break",
              description: "\"break\""
            },
            peg$c53 = "case",
            peg$c54 = {
              type: "literal",
              value: "case",
              description: "\"case\""
            },
            peg$c55 = "char",
            peg$c56 = {
              type: "literal",
              value: "char",
              description: "\"char\""
            },
            peg$c57 = "const",
            peg$c58 = {
              type: "literal",
              value: "const",
              description: "\"const\""
            },
            peg$c59 = "continue",
            peg$c60 = {
              type: "literal",
              value: "continue",
              description: "\"continue\""
            },
            peg$c61 = "default",
            peg$c62 = {
              type: "literal",
              value: "default",
              description: "\"default\""
            },
            peg$c63 = "double",
            peg$c64 = {
              type: "literal",
              value: "double",
              description: "\"double\""
            },
            peg$c65 = "do",
            peg$c66 = {
              type: "literal",
              value: "do",
              description: "\"do\""
            },
            peg$c67 = "enum",
            peg$c68 = {
              type: "literal",
              value: "enum",
              description: "\"enum\""
            },
            peg$c69 = "extern",
            peg$c70 = {
              type: "literal",
              value: "extern",
              description: "\"extern\""
            },
            peg$c71 = "float",
            peg$c72 = {
              type: "literal",
              value: "float",
              description: "\"float\""
            },
            peg$c73 = "for",
            peg$c74 = {
              type: "literal",
              value: "for",
              description: "\"for\""
            },
            peg$c75 = "goto",
            peg$c76 = {
              type: "literal",
              value: "goto",
              description: "\"goto\""
            },
            peg$c77 = "if",
            peg$c78 = {
              type: "literal",
              value: "if",
              description: "\"if\""
            },
            peg$c79 = "int",
            peg$c80 = {
              type: "literal",
              value: "int",
              description: "\"int\""
            },
            peg$c81 = "inline",
            peg$c82 = {
              type: "literal",
              value: "inline",
              description: "\"inline\""
            },
            peg$c83 = "long",
            peg$c84 = {
              type: "literal",
              value: "long",
              description: "\"long\""
            },
            peg$c85 = "register",
            peg$c86 = {
              type: "literal",
              value: "register",
              description: "\"register\""
            },
            peg$c87 = "restrict",
            peg$c88 = {
              type: "literal",
              value: "restrict",
              description: "\"restrict\""
            },
            peg$c89 = "return",
            peg$c90 = {
              type: "literal",
              value: "return",
              description: "\"return\""
            },
            peg$c91 = "short",
            peg$c92 = {
              type: "literal",
              value: "short",
              description: "\"short\""
            },
            peg$c93 = "signed",
            peg$c94 = {
              type: "literal",
              value: "signed",
              description: "\"signed\""
            },
            peg$c95 = "sizeof",
            peg$c96 = {
              type: "literal",
              value: "sizeof",
              description: "\"sizeof\""
            },
            peg$c97 = "static",
            peg$c98 = {
              type: "literal",
              value: "static",
              description: "\"static\""
            },
            peg$c99 = "struct",
            peg$c100 = {
              type: "literal",
              value: "struct",
              description: "\"struct\""
            },
            peg$c101 = "switch",
            peg$c102 = {
              type: "literal",
              value: "switch",
              description: "\"switch\""
            },
            peg$c103 = "typedef",
            peg$c104 = {
              type: "literal",
              value: "typedef",
              description: "\"typedef\""
            },
            peg$c105 = "union",
            peg$c106 = {
              type: "literal",
              value: "union",
              description: "\"union\""
            },
            peg$c107 = "unsigned",
            peg$c108 = {
              type: "literal",
              value: "unsigned",
              description: "\"unsigned\""
            },
            peg$c109 = "void",
            peg$c110 = {
              type: "literal",
              value: "void",
              description: "\"void\""
            },
            peg$c111 = "volatile",
            peg$c112 = {
              type: "literal",
              value: "volatile",
              description: "\"volatile\""
            },
            peg$c113 = "while",
            peg$c114 = {
              type: "literal",
              value: "while",
              description: "\"while\""
            },
            peg$c115 = "_Bool",
            peg$c116 = {
              type: "literal",
              value: "_Bool",
              description: "\"_Bool\""
            },
            peg$c117 = "_Complex",
            peg$c118 = {
              type: "literal",
              value: "_Complex",
              description: "\"_Complex\""
            },
            peg$c119 = "_stdcall",
            peg$c120 = {
              type: "literal",
              value: "_stdcall",
              description: "\"_stdcall\""
            },
            peg$c121 = "__declspec",
            peg$c122 = {
              type: "literal",
              value: "__declspec",
              description: "\"__declspec\""
            },
            peg$c123 = "__attribute__",
            peg$c124 = {
              type: "literal",
              value: "__attribute__",
              description: "\"__attribute__\""
            },
            peg$c125 = "_Imaginary",
            peg$c126 = {
              type: "literal",
              value: "_Imaginary",
              description: "\"_Imaginary\""
            },
            peg$c127 = function(a, b, c) {
              return {
                type: 'Identifier',
                val: a + b.join(''),
                space: c
              };
            },
            peg$c128 = /^[\r\n,)]/,
            peg$c129 = {
              type: "class",
              value: "[\\r\\n,)]",
              description: "[\\r\\n,)]"
            },
            peg$c130 = function(a, b) {
              return {
                type: 'Seperator',
                val: a,
                space: b
              };
            },
            peg$c131 = /^[\r\n]/,
            peg$c132 = {
              type: "class",
              value: "[\\r\\n]",
              description: "[\\r\\n]"
            },
            peg$c133 = /^[a-z]/,
            peg$c134 = {
              type: "class",
              value: "[a-z]",
              description: "[a-z]"
            },
            peg$c135 = /^[A-Z]/,
            peg$c136 = {
              type: "class",
              value: "[A-Z]",
              description: "[A-Z]"
            },
            peg$c137 = /^[_]/,
            peg$c138 = {
              type: "class",
              value: "[_]",
              description: "[_]"
            },
            peg$c139 = /^[0-9]/,
            peg$c140 = {
              type: "class",
              value: "[0-9]",
              description: "[0-9]"
            },
            peg$c141 = "\\u",
            peg$c142 = {
              type: "literal",
              value: "\\u",
              description: "\"\\\\u\""
            },
            peg$c143 = function(a) {
              return String.fromCharCode(a);
            },
            peg$c144 = "\\U",
            peg$c145 = {
              type: "literal",
              value: "\\U",
              description: "\"\\\\U\""
            },
            peg$c146 = function(a) {
              return parseInt(a.join(''), 16);
            },
            peg$c147 = /^[a-f]/,
            peg$c148 = {
              type: "class",
              value: "[a-f]",
              description: "[a-f]"
            },
            peg$c149 = /^[A-F]/,
            peg$c150 = {
              type: "class",
              value: "[A-F]",
              description: "[A-F]"
            },
            peg$c151 = "(",
            peg$c152 = {
              type: "literal",
              value: "(",
              description: "\"(\""
            },
            peg$c153 = ")",
            peg$c154 = {
              type: "literal",
              value: ")",
              description: "\")\""
            },
            peg$c155 = ",",
            peg$c156 = {
              type: "literal",
              value: ",",
              description: "\",\""
            },
            peg$c157 = "<",
            peg$c158 = {
              type: "literal",
              value: "<",
              description: "\"<\""
            },
            peg$c159 = /^[=]/,
            peg$c160 = {
              type: "class",
              value: "[=]",
              description: "[=]"
            },
            peg$c161 = ">",
            peg$c162 = {
              type: "literal",
              value: ">",
              description: "\">\""
            },
            peg$c163 = "\"",
            peg$c164 = {
              type: "literal",
              value: "\"",
              description: "\"\\\"\""
            },
            peg$c165 = {
              type: "any",
              description: "any character"
            },
            peg$currPos = 0,
            peg$savedPos = 0,
            peg$posDetailsCache = [{
              line: 1,
              column: 1,
              seenCR: false
            }],
            peg$maxFailPos = 0,
            peg$maxFailExpected = [],
            peg$silentFails = 0,
            peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description) {
          throw peg$buildException(null, [{
            type: "other",
            description: description
          }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function error(message) {
          throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos],
              p,
              ch;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column,
              seenCR: details.seenCR
            };
            while (p < pos) {
              ch = input.charAt(p);
              if (ch === "\n") {
                if (!details.seenCR) {
                  details.line++;
                }
                details.column = 1;
                details.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                details.line++;
                details.column = 1;
                details.seenCR = true;
              } else {
                details.column++;
                details.seenCR = false;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected);
        }
        function peg$buildException(message, expected, found, location) {
          function cleanupExpected(expected) {
            var i = 1;
            expected.sort(function(a, b) {
              if (a.description < b.description) {
                return -1;
              } else if (a.description > b.description) {
                return 1;
              } else {
                return 0;
              }
            });
            while (i < expected.length) {
              if (expected[i - 1] === expected[i]) {
                expected.splice(i, 1);
              } else {
                i++;
              }
            }
          }
          function buildMessage(expected, found) {
            function stringEscape(s) {
              function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
              }
              return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                return '\\x0' + hex(ch);
              }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                return '\\x' + hex(ch);
              }).replace(/[\u0100-\u0FFF]/g, function(ch) {
                return '\\u0' + hex(ch);
              }).replace(/[\u1000-\uFFFF]/g, function(ch) {
                return '\\u' + hex(ch);
              });
            }
            var expectedDescs = new Array(expected.length),
                expectedDesc,
                foundDesc,
                i;
            for (i = 0; i < expected.length; i++) {
              expectedDescs[i] = expected[i].description;
            }
            expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
            foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
            return "Expected " + expectedDesc + " but " + foundDesc + " found.";
          }
          if (expected !== null) {
            cleanupExpected(expected);
          }
          return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
        }
        function peg$parseTranslationUnit() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSpacing();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsePreprocessor();
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parsePrepMacroText();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseSpacing();
                if (s5 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c0(s4, s5);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsePreprocessor();
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$parsePrepMacroText();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseSpacing();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c0(s4, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseEOT();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePreprocessor() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parsePrepDefine();
          if (s1 === peg$FAILED) {
            s1 = peg$parsePrepInclude();
            if (s1 === peg$FAILED) {
              s1 = peg$parseConditionalInclusion();
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c2(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepDefine() {
          var s0;
          s0 = peg$parsePrepFunctionMacro();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepSimpleMacro();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePrepUndef();
            }
          }
          return s0;
        }
        function peg$parsePrepUndef() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseUNDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c3(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepSimpleMacro() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDEFINE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepMacroText();
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c4(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacro() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDEFINE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsePrepMacroText();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c5(s3, s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacroArgs() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parseLPAR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseCOMMA();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseIdentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c6(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseCOMMA();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseIdentifier();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c6(s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepFunctionMacroCallArgs() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6;
          s0 = peg$currPos;
          s1 = peg$parseLPAR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsePrepMacroMacroCallText();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = peg$parseCOMMA();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsePrepMacroMacroCallText();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c6(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = peg$parseCOMMA();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsePrepMacroMacroCallText();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c6(s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseRPAR();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c7(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepMacroMacroCallText() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePrepFunctionMacroCallArgs();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInlineSpacing();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3, s4, s5);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSeperatorArgs();
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroCallArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseInlineSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c8(s3, s4, s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSeperatorArgs();
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsePrepMacroText() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parseIdentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePrepFunctionMacroCallArgs();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseInlineSpacing();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$c8(s3, s4, s5);
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$parseIdentifier();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSeperator();
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePrepFunctionMacroCallArgs();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseInlineSpacing();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c8(s3, s4, s5);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 === peg$FAILED) {
                s2 = peg$parseIdentifier();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSeperator();
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c9(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parsePrepInclude() {
          var s0;
          s0 = peg$parsePrepIncludeLib();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepIncludeLocal();
          }
          return s0;
        }
        function peg$parsePrepIncludeLib() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseINCLUDE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseLT();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseFilename();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseGT();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepIncludeLocal() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseINCLUDE();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseQUO();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseFilename();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseQUO();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c11(s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFilename() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIdChar();
          if (s2 === peg$FAILED) {
            if (peg$c12.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c13);
              }
            }
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIdChar();
              if (s2 === peg$FAILED) {
                if (peg$c12.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c13);
                  }
                }
              }
            }
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseConditionalInclusion() {
          var s0;
          s0 = peg$parsePrepIfdef();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePrepIfndef();
            if (s0 === peg$FAILED) {
              s0 = peg$parsePrepEndif();
              if (s0 === peg$FAILED) {
                s0 = peg$parsePrepElse();
              }
            }
          }
          return s0;
        }
        function peg$parsePrepIfdef() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIFDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c15(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepIfndef() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIFNDEF();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseIdentifier();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c16(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepEndif() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseENDIF();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c17();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePrepElse() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = peg$parseSHARP();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseELSE();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c18();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHARP() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c19;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFINE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c21) {
            s1 = peg$c21;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c22);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNDEF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c24);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINCLUDE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c25) {
            s1 = peg$c25;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIFDEF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c27) {
            s1 = peg$c27;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIFNDEF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c29) {
            s1 = peg$c29;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c30);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENDIF() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c31) {
            s1 = peg$c31;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c32);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseInlineSpacing() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseInlineWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseInlineWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseSpacing() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseWhiteSpace();
          if (s2 === peg$FAILED) {
            s2 = peg$parseLongComment();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLineComment();
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseWhiteSpace();
            if (s2 === peg$FAILED) {
              s2 = peg$parseLongComment();
              if (s2 === peg$FAILED) {
                s2 = peg$parseLineComment();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c35(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseInlineWhiteSpace() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c36.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c37);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseWhiteSpace() {
          var s0,
              s1;
          s0 = peg$currPos;
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c39);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c6(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseLongComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c40) {
            s1 = peg$c40;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c41);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c42) {
              s5 = peg$c42;
              peg$currPos += 2;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c42) {
                s5 = peg$c42;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c42) {
                s3 = peg$c42;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c43);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c44(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLineComment() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c45) {
            s1 = peg$c45;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
              s5 = peg$c47;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c48);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c47;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = void 0;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c44(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseAUTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c49) {
            s1 = peg$c49;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBREAK() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c51) {
            s1 = peg$c51;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCASE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c53) {
            s1 = peg$c53;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c54);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCHAR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c55) {
            s1 = peg$c55;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c56);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONST() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c57) {
            s1 = peg$c57;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c58);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCONTINUE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c59) {
            s1 = peg$c59;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c60);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDEFAULT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c61) {
            s1 = peg$c61;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c62);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c63) {
            s1 = peg$c63;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c64);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c65) {
            s1 = peg$c65;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c66);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseELSE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c33) {
            s1 = peg$c33;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseENUM() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c67) {
            s1 = peg$c67;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c68);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEXTERN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c69) {
            s1 = peg$c69;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c70);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFLOAT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c71) {
            s1 = peg$c71;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseFOR() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c73) {
            s1 = peg$c73;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c74);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGOTO() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c75) {
            s1 = peg$c75;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c77) {
            s1 = peg$c77;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c78);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c79) {
            s1 = peg$c79;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c80);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINLINE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c81) {
            s1 = peg$c81;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c82);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLONG() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c83) {
            s1 = peg$c83;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c84);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseREGISTER() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c85) {
            s1 = peg$c85;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c86);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRESTRICT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c87) {
            s1 = peg$c87;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRETURN() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSHORT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c91) {
            s1 = peg$c91;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c93) {
            s1 = peg$c93;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c94);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSIZEOF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c95) {
            s1 = peg$c95;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c96);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTATIC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c98);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRUCT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c99) {
            s1 = peg$c99;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c100);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSWITCH() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 6) === peg$c101) {
            s1 = peg$c101;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseTYPEDEF() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 7) === peg$c103) {
            s1 = peg$c103;
            peg$currPos += 7;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c104);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNION() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c105) {
            s1 = peg$c105;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c106);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUNSIGNED() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c107) {
            s1 = peg$c107;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c108);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOID() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c109) {
            s1 = peg$c109;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c110);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseVOLATILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c111) {
            s1 = peg$c111;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c112);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseWHILE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c113) {
            s1 = peg$c113;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c114);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOOL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c115) {
            s1 = peg$c115;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c116);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMPLEX() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c117) {
            s1 = peg$c117;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c118);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTDCALL() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c119) {
            s1 = peg$c119;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c120);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseDECLSPEC() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 10) === peg$c121) {
            s1 = peg$c121;
            peg$currPos += 10;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c122);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseATTRIBUTE() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 13) === peg$c123) {
            s1 = peg$c123;
            peg$currPos += 13;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseKeyword() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c49) {
            s1 = peg$c49;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c53) {
                s1 = peg$c53;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c54);
                }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c55) {
                  s1 = peg$c55;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c56);
                  }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c57) {
                    s1 = peg$c57;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c58);
                    }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c59) {
                      s1 = peg$c59;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c60);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c61) {
                        s1 = peg$c61;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c62);
                        }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c63) {
                          s1 = peg$c63;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c64);
                          }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c65) {
                            s1 = peg$c65;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c66);
                            }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 4) === peg$c33) {
                              s1 = peg$c33;
                              peg$currPos += 4;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c34);
                              }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 4) === peg$c67) {
                                s1 = peg$c67;
                                peg$currPos += 4;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c68);
                                }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 6) === peg$c69) {
                                  s1 = peg$c69;
                                  peg$currPos += 6;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c70);
                                  }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c71) {
                                    s1 = peg$c71;
                                    peg$currPos += 5;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c72);
                                    }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 3) === peg$c73) {
                                      s1 = peg$c73;
                                      peg$currPos += 3;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c74);
                                      }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c75) {
                                        s1 = peg$c75;
                                        peg$currPos += 4;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c76);
                                        }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c77) {
                                          s1 = peg$c77;
                                          peg$currPos += 2;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c78);
                                          }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 3) === peg$c79) {
                                            s1 = peg$c79;
                                            peg$currPos += 3;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c80);
                                            }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 6) === peg$c81) {
                                              s1 = peg$c81;
                                              peg$currPos += 6;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c82);
                                              }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 4) === peg$c83) {
                                                s1 = peg$c83;
                                                peg$currPos += 4;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c84);
                                                }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c85) {
                                                  s1 = peg$c85;
                                                  peg$currPos += 8;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c86);
                                                  }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 8) === peg$c87) {
                                                    s1 = peg$c87;
                                                    peg$currPos += 8;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c88);
                                                    }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 6) === peg$c89) {
                                                      s1 = peg$c89;
                                                      peg$currPos += 6;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c90);
                                                      }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c91) {
                                                        s1 = peg$c91;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c92);
                                                        }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 6) === peg$c93) {
                                                          s1 = peg$c93;
                                                          peg$currPos += 6;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c94);
                                                          }
                                                        }
                                                        if (s1 === peg$FAILED) {
                                                          if (input.substr(peg$currPos, 6) === peg$c95) {
                                                            s1 = peg$c95;
                                                            peg$currPos += 6;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c96);
                                                            }
                                                          }
                                                          if (s1 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 6) === peg$c97) {
                                                              s1 = peg$c97;
                                                              peg$currPos += 6;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c98);
                                                              }
                                                            }
                                                            if (s1 === peg$FAILED) {
                                                              if (input.substr(peg$currPos, 6) === peg$c99) {
                                                                s1 = peg$c99;
                                                                peg$currPos += 6;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c100);
                                                                }
                                                              }
                                                              if (s1 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 6) === peg$c101) {
                                                                  s1 = peg$c101;
                                                                  peg$currPos += 6;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c102);
                                                                  }
                                                                }
                                                                if (s1 === peg$FAILED) {
                                                                  if (input.substr(peg$currPos, 7) === peg$c103) {
                                                                    s1 = peg$c103;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) {
                                                                      peg$fail(peg$c104);
                                                                    }
                                                                  }
                                                                  if (s1 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 5) === peg$c105) {
                                                                      s1 = peg$c105;
                                                                      peg$currPos += 5;
                                                                    } else {
                                                                      s1 = peg$FAILED;
                                                                      if (peg$silentFails === 0) {
                                                                        peg$fail(peg$c106);
                                                                      }
                                                                    }
                                                                    if (s1 === peg$FAILED) {
                                                                      if (input.substr(peg$currPos, 8) === peg$c107) {
                                                                        s1 = peg$c107;
                                                                        peg$currPos += 8;
                                                                      } else {
                                                                        s1 = peg$FAILED;
                                                                        if (peg$silentFails === 0) {
                                                                          peg$fail(peg$c108);
                                                                        }
                                                                      }
                                                                      if (s1 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 4) === peg$c109) {
                                                                          s1 = peg$c109;
                                                                          peg$currPos += 4;
                                                                        } else {
                                                                          s1 = peg$FAILED;
                                                                          if (peg$silentFails === 0) {
                                                                            peg$fail(peg$c110);
                                                                          }
                                                                        }
                                                                        if (s1 === peg$FAILED) {
                                                                          if (input.substr(peg$currPos, 8) === peg$c111) {
                                                                            s1 = peg$c111;
                                                                            peg$currPos += 8;
                                                                          } else {
                                                                            s1 = peg$FAILED;
                                                                            if (peg$silentFails === 0) {
                                                                              peg$fail(peg$c112);
                                                                            }
                                                                          }
                                                                          if (s1 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 5) === peg$c113) {
                                                                              s1 = peg$c113;
                                                                              peg$currPos += 5;
                                                                            } else {
                                                                              s1 = peg$FAILED;
                                                                              if (peg$silentFails === 0) {
                                                                                peg$fail(peg$c114);
                                                                              }
                                                                            }
                                                                            if (s1 === peg$FAILED) {
                                                                              if (input.substr(peg$currPos, 5) === peg$c115) {
                                                                                s1 = peg$c115;
                                                                                peg$currPos += 5;
                                                                              } else {
                                                                                s1 = peg$FAILED;
                                                                                if (peg$silentFails === 0) {
                                                                                  peg$fail(peg$c116);
                                                                                }
                                                                              }
                                                                              if (s1 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 8) === peg$c117) {
                                                                                  s1 = peg$c117;
                                                                                  peg$currPos += 8;
                                                                                } else {
                                                                                  s1 = peg$FAILED;
                                                                                  if (peg$silentFails === 0) {
                                                                                    peg$fail(peg$c118);
                                                                                  }
                                                                                }
                                                                                if (s1 === peg$FAILED) {
                                                                                  if (input.substr(peg$currPos, 10) === peg$c125) {
                                                                                    s1 = peg$c125;
                                                                                    peg$currPos += 10;
                                                                                  } else {
                                                                                    s1 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) {
                                                                                      peg$fail(peg$c126);
                                                                                    }
                                                                                  }
                                                                                  if (s1 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 8) === peg$c119) {
                                                                                      s1 = peg$c119;
                                                                                      peg$currPos += 8;
                                                                                    } else {
                                                                                      s1 = peg$FAILED;
                                                                                      if (peg$silentFails === 0) {
                                                                                        peg$fail(peg$c120);
                                                                                      }
                                                                                    }
                                                                                    if (s1 === peg$FAILED) {
                                                                                      if (input.substr(peg$currPos, 10) === peg$c121) {
                                                                                        s1 = peg$c121;
                                                                                        peg$currPos += 10;
                                                                                      } else {
                                                                                        s1 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) {
                                                                                          peg$fail(peg$c122);
                                                                                        }
                                                                                      }
                                                                                      if (s1 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 13) === peg$c123) {
                                                                                          s1 = peg$c123;
                                                                                          peg$currPos += 13;
                                                                                        } else {
                                                                                          s1 = peg$FAILED;
                                                                                          if (peg$silentFails === 0) {
                                                                                            peg$fail(peg$c124);
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdChar();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdentifier() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseKeyword();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = void 0;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIdNondigit();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIdChar();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIdChar();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseInlineSpacing();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c127(s2, s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSeperatorArgs() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseKeyword();
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdNondigit();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (peg$c128.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c129);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c6(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSeperator() {
          var s0,
              s1,
              s2,
              s3,
              s4;
          s0 = peg$currPos;
          s1 = peg$parseKeyword();
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseIdNondigit();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              if (peg$c131.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c132);
                }
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c6(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c130(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIdNondigit() {
          var s0;
          if (peg$c133.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c135.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c136);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c137.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c138);
                }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseUniversalCharacter();
              }
            }
          }
          return s0;
        }
        function peg$parseIdChar() {
          var s0;
          if (peg$c133.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c135.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c136);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c139.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c140);
                }
              }
              if (s0 === peg$FAILED) {
                if (peg$c137.test(input.charAt(peg$currPos))) {
                  s0 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c138);
                  }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseUniversalCharacter();
                }
              }
            }
          }
          return s0;
        }
        function peg$parseUniversalCharacter() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c141) {
            s1 = peg$c141;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c142);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseHexQuad();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c143(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c144) {
              s1 = peg$c144;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c145);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseHexOcto();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c143(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseHexOcto() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5,
              s6,
              s7,
              s8,
              s9;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseHexDigit();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHexDigit();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHexDigit();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHexDigit();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHexDigit();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHexDigit();
                        if (s9 !== peg$FAILED) {
                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c146(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseHexQuad() {
          var s0,
              s1,
              s2,
              s3,
              s4,
              s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parseHexDigit();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHexDigit();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHexDigit();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHexDigit();
                if (s5 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c146(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseHexDigit() {
          var s0;
          if (peg$c147.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c148);
            }
          }
          if (s0 === peg$FAILED) {
            if (peg$c149.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c150);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c139.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c140);
                }
              }
            }
          }
          return s0;
        }
        function peg$parseLPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c151;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c152);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRPAR() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 41) {
            s1 = peg$c153;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c154);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseCOMMA() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c155;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c156);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseLT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c157;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c158);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c159.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c160);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseInlineSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseGT() {
          var s0,
              s1,
              s2,
              s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 62) {
            s1 = peg$c161;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c162);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (peg$c159.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c160);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parseInlineSpacing();
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c6(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseQUO() {
          var s0,
              s1,
              s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c163;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c164);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseInlineSpacing();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c6(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseEOT() {
          var s0,
              s1;
          s0 = peg$currPos;
          peg$silentFails++;
          s1 = peg$parse_();
          peg$silentFails--;
          if (s1 === peg$FAILED) {
            s0 = void 0;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parse_() {
          var s0;
          if (input.length > peg$currPos) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c165);
            }
          }
          return s0;
        }
        function addPositionInfo(r) {
          var posDetails = peg$computePosDetails(peg$currPos);
          r.line = posDetails.line;
          r.column = posDetails.column;
          r.begin = peg$savedPos;
          r.end = peg$currPos;
          return r;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail({
              type: "end",
              description: "end of input"
            });
          }
          throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    })();
  }, {}],
  16: [function(require, module, exports) {
    var PEGUtil,
        Preprocessor,
        prepast;
    prepast = require("./prepast");
    PEGUtil = require("pegjs-util");
    Preprocessor = function(rt) {
      var pushInc,
          self;
      pushInc = function(b) {
        self.doinclude.push(self.doinclude[self.doinclude.length - 1] && b);
      };
      this.rt = rt;
      this.ret = "";
      this.macros = {};
      this.macroStack = [];
      this.doinclude = [true];
      self = this;
      this.visitors = {
        TranslationUnit: function(interp, s, code) {
          var dec,
              i;
          i = 0;
          while (i < s.lines.length) {
            dec = s.lines[i];
            interp.visit(dec, code);
            interp.ret += dec.space;
            i++;
          }
          return interp.ret;
        },
        Code: function(interp, s, code) {
          var i,
              x;
          if (interp.doinclude[interp.doinclude.length - 1]) {
            i = 0;
            while (i < s.val.length) {
              x = interp.work(s.val[i]);
              interp.ret += x;
              i++;
            }
          }
        },
        PrepSimpleMacro: function(interp, s, code) {
          interp.newMacro(s.Identifier, s.Replacement);
        },
        PrepFunctionMacro: function(interp, s, code) {
          interp.newMacroFunction(s.Identifier, s.Args, s.Replacement);
        },
        PrepIncludeLib: function(interp, s, code) {
          interp.rt.include(s.name);
        },
        PrepIncludeLocal: function(interp, s, code) {
          var includes;
          includes = interp.rt.config.includes;
          if (s.name in includes) {
            includes[s.name].load(interp.rt);
          } else {
            interp.rt.raiseException("cannot find file: " + s.name);
          }
        },
        PrepUndef: function(interp, s, code) {
          if (interp.isMacroDefined(s.Identifier)) {
            delete interp.macros[s.Identifier.val];
          }
        },
        PrepIfdef: function(interp, s, code) {
          pushInc(interp.isMacroDefined(s.Identifier));
        },
        PrepIfndef: function(interp, s, code) {
          pushInc(!interp.isMacroDefined(s.Identifier));
        },
        PrepElse: function(interp, s, code) {
          var x;
          if (interp.doinclude.length > 1) {
            x = interp.doinclude.pop();
            pushInc(!x);
          } else {
            interp.rt.raiseException("#else must be used after a #if");
          }
        },
        PrepEndif: function(interp, s, code) {
          if (interp.doinclude.length > 1) {
            interp.doinclude.pop();
          } else {
            interp.rt.raiseException("#endif must be used after a #if");
          }
        },
        unknown: function(interp, s, code) {
          interp.rt.raiseException("unhandled syntax " + s.type);
        }
      };
    };
    Preprocessor.prototype.visit = function(s, code) {
      var _node;
      if ("type" in s) {
        _node = this.currentNode;
        this.currentNode = s;
        if (s.type in this.visitors) {
          return this.visitors[s.type](this, s, code);
        } else {
          return this.visitors["unknown"](this, s, code);
        }
        this.currentNode = _node;
      } else {
        this.currentNode = s;
        this.rt.raiseException("untyped syntax structure: " + JSON.stringify(s));
      }
    };
    Preprocessor.prototype.isMacroDefined = function(node) {
      if (node.type === "Identifier") {
        return node.val in this.macros;
      } else {
        return node.Identifier.val in this.macros;
      }
    };
    Preprocessor.prototype.isMacro = function(node) {
      return this.isMacroDefined(node) && "val" in node && this.macros[node.val].type === "simple";
    };
    Preprocessor.prototype.isMacroFunction = function(node) {
      return this.isMacroDefined(node) && "Identifier" in node && this.macros[node.Identifier.val].type === "function";
    };
    Preprocessor.prototype.newMacro = function(id, replacement) {
      if (this.isMacroDefined(id)) {
        this.rt.raiseException("macro " + id.val + " is already defined");
      }
      this.macros[id.val] = {
        type: "simple",
        replacement: replacement
      };
    };
    Preprocessor.prototype.newMacroFunction = function(id, args, replacement) {
      if (this.isMacroDefined(id)) {
        this.rt.raiseException("macro " + id.val + " is already defined");
      }
      this.macros[id.val] = {
        type: "function",
        args: args,
        replacement: replacement
      };
    };
    Preprocessor.prototype.work = function(node) {
      if (node.type === "Seperator") {
        return node.val + node.space;
      } else {
        if (node in this.macroStack) {
          this.rt.raiseException("recursive macro detected");
        }
        this.macroStack.push(node);
        if (node.type === "Identifier") {
          return this.replaceMacro(node) + node.space;
        } else if (node.type === "PrepFunctionMacroCall") {
          return this.replaceMacroFunction(node);
        }
        this.macroStack.pop();
      }
    };
    Preprocessor.prototype.replaceMacro = function(id) {
      var i,
          rep,
          ret,
          v;
      if (this.isMacro(id)) {
        ret = "";
        rep = this.macros[id.val].replacement;
        i = 0;
        while (i < rep.length) {
          v = this.work(rep[i]);
          ret += v;
          i++;
        }
        return ret;
      } else {
        return id.val;
      }
    };
    Preprocessor.prototype.replaceMacroFunction = function(node) {
      var argi,
          args,
          argsText,
          i,
          j,
          name,
          rep,
          ret,
          v,
          x;
      if (this.isMacroFunction(node)) {
        name = node.Identifier.val;
        argsText = node.Args;
        rep = this.macros[name].replacement;
        args = this.macros[name].args;
        if (args.length === argsText.length) {
          ret = "";
          i = 0;
          while (i < rep.length) {
            if (rep[i].type === "Seperator") {
              v = this.work(rep[i]);
              ret += v;
            } else {
              argi = -1;
              j = 0;
              while (j < args.length) {
                if (rep[i].type === "Identifier" && args[j].val === rep[i].val) {
                  argi = j;
                  break;
                }
                j++;
              }
              if (argi >= 0) {
                v = "";
                j = 0;
                while (j < argsText[argi].length) {
                  v += this.work(argsText[argi][j]);
                  j++;
                }
                ret += v + rep[i].space;
              } else {
                v = this.work(rep[i]);
                ret += v;
              }
            }
            i++;
          }
          return ret;
        } else {
          this.rt.raiseException("macro " + name + " requires " + args.length + " arguments (" + argsText.length + " given)");
        }
      } else {
        argsText = node.Args;
        v = [];
        i = 0;
        while (i < argsText.length) {
          x = "";
          j = 0;
          while (j < argsText[i].length) {
            x += this.work(argsText[i][j]);
            j++;
          }
          v.push(x);
          i++;
        }
        return node.Identifier.val + "(" + v.join(",") + ")" + node.space;
      }
    };
    Preprocessor.prototype.parse = function(code) {
      var result;
      result = PEGUtil.parse(prepast, code);
      if (result.error != null) {
        throw "ERROR: Preprocessing Failure:\n" + PEGUtil.errorMessage(result.error, true);
      }
      this.rt.interp = this;
      return this.visit(result.ast, code);
    };
    module.exports = {parse: function(rt, code) {
        return new Preprocessor(rt).parse(code);
      }};
  }, {
    "./prepast": 15,
    "pegjs-util": 45
  }],
  17: [function(require, module, exports) {
    var CRuntime,
        Defaults,
        indexOf = [].indexOf || function(item) {
          for (var i = 0,
              l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
              return i;
          }
          return -1;
        },
        slice = [].slice;
    Defaults = require("./defaults");
    CRuntime = function(config) {
      var defaults,
          mergeConfig;
      mergeConfig = function(a, b) {
        var o;
        for (o in b) {
          if (o in a && $traceurRuntime.typeof(b[o]) === "object") {
            mergeConfig(a[o], b[o]);
          } else {
            a[o] = b[o];
          }
        }
      };
      defaults = new Defaults();
      this.config = defaults.config;
      mergeConfig(this.config, config);
      this.numericTypeOrder = defaults.numericTypeOrder;
      this.types = defaults.types;
      this.intTypeLiteral = this.primitiveType("int");
      this.unsignedintTypeLiteral = this.primitiveType("unsigned int");
      this.longTypeLiteral = this.primitiveType("long");
      this.floatTypeLiteral = this.primitiveType("float");
      this.doubleTypeLiteral = this.primitiveType("double");
      this.charTypeLiteral = this.primitiveType("char");
      this.unsignedcharTypeLiteral = this.primitiveType("unsigned char");
      this.boolTypeLiteral = this.primitiveType("bool");
      this.voidTypeLiteral = this.primitiveType("void");
      this.nullPointerValue = this.makeNormalPointerValue(null);
      this.voidPointerType = this.normalPointerType(this.voidTypeLiteral);
      this.nullPointer = this.val(this.voidPointerType, this.nullPointerValue);
      this.scope = [{"$name": "global"}];
      this.typedefs = {};
      return this;
    };
    CRuntime.prototype.include = function(name) {
      var includes,
          lib;
      includes = this.config.includes;
      if (name in includes) {
        lib = includes[name];
        if (indexOf.call(this.config.loadedLibraries, name) >= 0) {
          return;
        }
        this.config.loadedLibraries.push(name);
        includes[name].load(this);
      } else {
        this.raiseException("cannot find library: " + name);
      }
    };
    CRuntime.prototype.getSize = function(element) {
      var i,
          ret;
      ret = 0;
      if (this.isArrayType(element.t) && element.v.position === 0) {
        i = 0;
        while (i < element.v.target.length) {
          ret += this.getSize(element.v.target[i]);
          i++;
        }
      } else {
        ret += this.getSizeByType(element.t);
      }
      return ret;
    };
    CRuntime.prototype.getSizeByType = function(type) {
      if (this.isPointerType(type)) {
        return this.config.limits["pointer"].bytes;
      } else if (this.isPrimitiveType(type)) {
        return this.config.limits[type.name].bytes;
      } else {
        this.raiseException("not implemented");
      }
    };
    CRuntime.prototype.getMember = function(l, r) {
      var lt,
          ltsig,
          t;
      lt = l.t;
      if (this.isClassType(lt)) {
        ltsig = this.getTypeSignature(lt);
        if (ltsig in this.types) {
          t = this.types[ltsig];
          if (r in t) {
            return {
              t: {type: "function"},
              v: {
                defineType: lt,
                name: r,
                bindThis: l
              }
            };
          } else if (r in l.v.members) {
            return l.v.members[r];
          }
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
        }
      } else {
        this.raiseException("only a class can have members");
      }
    };
    CRuntime.prototype.defFunc = function(lt, name, retType, argTypes, argNames, stmts, interp) {
      var f,
          rt;
      rt = this;
      if (stmts != null) {
        f = $traceurRuntime.initGeneratorFunction(function $__2() {
          var _this,
              args,
              ret,
              rt,
              $__547,
              $__548,
              $__549,
              $__550,
              $__551;
          var $arguments = arguments;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  rt = $arguments[0], _this = $arguments[1], args = 3 <= $arguments.length ? slice.call($arguments, 2) : [];
                  rt.enterScope("function " + name);
                  argNames.forEach(function(v, i) {
                    rt.defVar(v, argTypes[i], args[i]);
                  });
                  $ctx.state = 22;
                  break;
                case 22:
                  $__547 = interp.run;
                  $__548 = $__547.call(interp, stmts, {scope: "function"});
                  $ctx.state = 16;
                  break;
                case 16:
                  $__550 = $ctx.wrapYieldStar($__548[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__551 = $__550[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__551.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__551.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__551.value;
                case 10:
                  $__549 = $ctx.sentIgnoreThrow;
                  $ctx.state = 14;
                  break;
                case 14:
                  ret = $__549;
                  $ctx.state = 18;
                  break;
                case 18:
                  if (!rt.isTypeEqualTo(retType, rt.voidTypeLiteral)) {
                    if (ret instanceof Array && ret[0] === "return") {
                      ret = rt.cast(retType, ret[1]);
                    } else {
                      rt.raiseException("you must return a value");
                    }
                  } else {
                    if (typeof ret === "Array") {
                      if (ret[0] === "return" && ret[1]) {
                        rt.raiseException("you cannot return a value of a void function");
                      }
                    }
                    ret = void 0;
                  }
                  rt.exitScope("function " + name);
                  $ctx.state = 24;
                  break;
                case 24:
                  $ctx.returnValue = ret;
                  $ctx.state = -2;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__2, this);
        });
        this.regFunc(f, lt, name, argTypes, retType);
      } else {
        this.regFuncPrototype(lt, name, argTypes, retType);
      }
    };
    CRuntime.prototype.makeParametersSignature = function(args) {
      var i,
          ret;
      ret = new Array(args.length);
      i = 0;
      while (i < args.length) {
        ret[i] = this.getTypeSignature(args[i]);
        i++;
      }
      return ret.join(",");
    };
    CRuntime.prototype.getCompatibleFunc = function(lt, name, args) {
      var argsStr,
          compatibles,
          ltsig,
          ret,
          rt,
          sig,
          t,
          ts;
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (name in t) {
          ts = args.map(function(v) {
            return v.t;
          });
          sig = this.makeParametersSignature(ts);
          if (sig in t[name]) {
            ret = t[name][sig];
          } else {
            compatibles = [];
            rt = this;
            t[name]["reg"].forEach(function(dts) {
              var i,
                  newTs,
                  ok;
              if (dts[dts.length - 1] === "?" && dts.length < ts.length) {
                newTs = ts.slice(0, dts.length - 1);
                dts = dts.slice(0, -1);
              } else {
                newTs = ts;
              }
              if (dts.length === newTs.length) {
                ok = true;
                i = 0;
                while (ok && i < newTs.length) {
                  ok = rt.castable(newTs[i], dts[i]);
                  i++;
                }
                if (ok) {
                  compatibles.push(t[name][rt.makeParametersSignature(dts)]);
                }
              }
            });
            if (compatibles.length === 0) {
              if ("#default" in t[name]) {
                ret = t[name]["#default"];
              } else {
                rt = this;
                argsStr = ts.map(function(v) {
                  return rt.makeTypeString(v);
                }).join(",");
                this.raiseException("no method " + name + " in " + lt + " accepts " + argsStr);
              }
            } else if (compatibles.length > 1) {
              this.raiseException("ambiguous method invoking, " + compatibles.length + " compatible methods");
            } else {
              ret = compatibles[0];
            }
          }
        } else {
          this.raiseException("method " + name + " is not defined in " + this.makeTypeString(lt));
        }
      } else {
        this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
      }
      if (ret == null) {
        this.raiseException("method " + name + " does not seem to be implemented");
      }
      return ret;
    };
    CRuntime.prototype.matchVarArg = function(methods, sig) {
      var _sig;
      for (_sig in methods) {
        if (_sig[_sig.length - 1] === "?") {
          _sig = _sig.slice(0, -1);
          if (sig.startsWith(_sig)) {
            return methods[_sig];
          }
        }
      }
      return null;
    };
    CRuntime.prototype.getFunc = function(lt, name, args) {
      var f,
          ltsig,
          method,
          sig,
          t;
      method = void 0;
      if (this.isPointerType(lt) || this.isFunctionType(lt)) {
        f = void 0;
        if (this.isArrayType(lt)) {
          f = "pointer_array";
        } else if (this.isFunctionType(lt)) {
          f = "function";
        } else {
          f = "pointer_normal";
        }
        t = null;
        if (name in this.types[f]) {
          t = this.types[f];
        } else if (name in this.types["pointer"]) {
          t = this.types["pointer"];
        }
        if (t) {
          sig = this.makeParametersSignature(args);
          if (sig in t[name]) {
            return t[name][sig];
          } else if ((method = this.matchVarArg(t[name], sig)) !== null) {
            return method;
          } else if ("#default" in t[name]) {
            return t[name]["#default"];
          } else {
            this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts (" + sig + ")");
          }
        }
      }
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (name in t) {
          sig = this.makeParametersSignature(args);
          if (sig in t[name]) {
            return t[name][sig];
          } else if ((method = this.matchVarArg(t[name], sig)) !== null) {
            return method;
          } else if ("#default" in t[name]) {
            return t[name]["#default"];
          } else {
            this.raiseException("no method " + name + " in " + this.makeTypeString(lt) + " accepts (" + sig + ")");
          }
        } else {
          this.raiseException("method " + name + " is not defined in " + this.makeTypeString(lt));
        }
      } else {
        if (this.isPointerType(lt)) {
          this.raiseException("this pointer has no proper method overload");
        } else {
          this.raiseException("type " + this.makeTypeString(lt) + " is not defined");
        }
      }
    };
    CRuntime.prototype.makeOperatorFuncName = function(name) {
      return "o(" + name + ")";
    };
    CRuntime.prototype.regOperator = function(f, lt, name, args, retType) {
      return this.regFunc(f, lt, this.makeOperatorFuncName(name), args, retType);
    };
    CRuntime.prototype.regFuncPrototype = function(lt, name, args, retType) {
      var ltsig,
          sig,
          t,
          type;
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (!(name in t)) {
          t[name] = {};
        }
        if (!("reg" in t[name])) {
          t[name]["reg"] = [];
        }
        sig = this.makeParametersSignature(args);
        if (sig in t[name]) {
          this.raiseException("method " + name + " with parameters (" + sig + ") is already defined");
        }
        type = this.functionType(retType, args);
        if (lt === "global") {
          this.defVar(name, type, this.val(type, this.makeFunctionPointerValue(null, name, lt, args, retType)));
        }
        t[name][sig] = null;
        t[name]["reg"].push(args);
      } else {
        this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
      }
    };
    CRuntime.prototype.regFunc = function(f, lt, name, args, retType) {
      var func,
          ltsig,
          sig,
          t,
          type;
      ltsig = this.getTypeSignature(lt);
      if (ltsig in this.types) {
        t = this.types[ltsig];
        if (!(name in t)) {
          t[name] = {};
        }
        if (!("reg" in t[name])) {
          t[name]["reg"] = [];
        }
        sig = this.makeParametersSignature(args);
        if (sig in t[name] && (t[name][sig] != null)) {
          this.raiseException("method " + name + " with parameters (" + sig + ") is already defined");
        }
        type = this.functionType(retType, args);
        if (lt === "global") {
          if (this.varAlreadyDefined(name)) {
            func = this.scope[0][name];
            if (func.v.target !== null) {
              this.raiseException("global method " + name + " with parameters (" + sig + ") is already defined");
            } else {
              func.v.target = f;
            }
          } else {
            this.defVar(name, type, this.val(type, this.makeFunctionPointerValue(f, name, lt, args, retType)));
          }
        }
        t[name][sig] = f;
        t[name]["reg"].push(args);
      } else {
        this.raiseException("type " + this.makeTypeString(lt) + " is unknown");
      }
    };
    CRuntime.prototype.registerTypedef = function(basttype, name) {
      return this.typedefs[name] = basttype;
    };
    CRuntime.prototype.promoteNumeric = function(l, r) {
      var rett,
          slt,
          slti,
          srt,
          srti;
      if (!this.isNumericType(l) || !this.isNumericType(r)) {
        this.raiseException("you cannot promote (to) a non numeric type");
      }
      if (this.isTypeEqualTo(l, r)) {
        if (this.isTypeEqualTo(l, this.boolTypeLiteral)) {
          return this.intTypeLiteral;
        }
        if (this.isTypeEqualTo(l, this.charTypeLiteral)) {
          return this.intTypeLiteral;
        }
        if (this.isTypeEqualTo(l, this.unsignedcharTypeLiteral)) {
          return this.unsignedintTypeLiteral;
        }
        return l;
      } else if (this.isIntegerType(l) && this.isIntegerType(r)) {
        slt = this.getSignedType(l);
        srt = this.getSignedType(r);
        if (this.isTypeEqualTo(slt, srt)) {
          rett = slt;
        } else {
          slti = this.numericTypeOrder.indexOf(slt.name);
          srti = this.numericTypeOrder.indexOf(srt.name);
          if (slti <= srti) {
            if (this.isUnsignedType(l) && this.isUnsignedType(r)) {
              rett = r;
            } else {
              rett = srt;
            }
          } else {
            if (this.isUnsignedType(l) && this.isUnsignedType(r)) {
              rett = l;
            } else {
              rett = slt;
            }
          }
        }
        return rett;
      } else if (!this.isIntegerType(l) && this.isIntegerType(r)) {
        return l;
      } else if (this.isIntegerType(l) && !this.isIntegerType(r)) {
        return r;
      } else if (!this.isIntegerType(l) && !this.isIntegerType(r)) {
        return this.primitiveType("double");
      }
    };
    CRuntime.prototype.readVar = function(varname) {
      var i,
          ret,
          vc;
      i = this.scope.length - 1;
      while (i >= 0) {
        vc = this.scope[i];
        if (vc[varname]) {
          ret = vc[varname];
          return ret;
        }
        i--;
      }
      this.raiseException("variable " + varname + " does not exist");
    };
    CRuntime.prototype.varAlreadyDefined = function(varname) {
      var vc;
      vc = this.scope[this.scope.length - 1];
      return varname in vc;
    };
    CRuntime.prototype.defVar = function(varname, type, initval) {
      var vc;
      if (this.varAlreadyDefined(varname)) {
        this.raiseException("variable " + varname + " already defined");
      }
      vc = this.scope[this.scope.length - 1];
      initval = this.clone(this.cast(type, initval));
      if (initval === void 0) {
        vc[varname] = this.defaultValue(type);
        vc[varname].left = true;
      } else {
        vc[varname] = initval;
        vc[varname].left = true;
      }
    };
    CRuntime.prototype.inrange = function(type, value) {
      var limit;
      if (this.isPrimitiveType(type)) {
        limit = this.config.limits[type.name];
        return value <= limit.max && value >= limit.min;
      } else {
        return true;
      }
    };
    CRuntime.prototype.isNumericType = function(type) {
      return this.isFloatType(type) || this.isIntegerType(type);
    };
    CRuntime.prototype.isUnsignedType = function(type) {
      if (typeof type === "string") {
        switch (type) {
          case "unsigned char":
          case "unsigned short":
          case "unsigned short int":
          case "unsigned":
          case "unsigned int":
          case "unsigned long":
          case "unsigned long int":
          case "unsigned long long":
          case "unsigned long long int":
            return true;
          default:
            return false;
        }
      } else {
        return type.type === "primitive" && this.isUnsignedType(type.name);
      }
    };
    CRuntime.prototype.isIntegerType = function(type) {
      if (typeof type === "string") {
        return indexOf.call(this.config.charTypes, type) >= 0 || indexOf.call(this.config.intTypes, type) >= 0;
      } else {
        return type.type === "primitive" && this.isIntegerType(type.name);
      }
    };
    CRuntime.prototype.isFloatType = function(type) {
      if (typeof type === "string") {
        switch (type) {
          case "float":
          case "double":
            return true;
          default:
            return false;
        }
      } else {
        return type.type === "primitive" && this.isFloatType(type.name);
      }
    };
    CRuntime.prototype.getSignedType = function(type) {
      if (type !== "unsigned") {
        return this.primitiveType(type.name.replace("unsigned", "").trim());
      } else {
        return this.primitiveType("int");
      }
    };
    CRuntime.prototype.castable = function(type1, type2) {
      if (this.isTypeEqualTo(type1, type2)) {
        return true;
      }
      if (this.isPrimitiveType(type1) && this.isPrimitiveType(type2)) {
        return this.isNumericType(type2) && this.isNumericType(type1);
      } else if (this.isPointerType(type1) && this.isPointerType(type2)) {
        if (this.isFunctionType(type1)) {
          return this.isPointerType(type2);
        }
        return !this.isFunctionType(type2);
      } else if (this.isClassType(type1) || this.isClassType(type2)) {
        this.raiseException("not implemented");
      }
      return false;
    };
    CRuntime.prototype.cast = function(type, value) {
      var bytes,
          newValue,
          ref,
          v;
      if (this.isTypeEqualTo(value.t, type)) {
        return value;
      }
      if (this.isPrimitiveType(type) && this.isPrimitiveType(value.t)) {
        if (type.name === "bool") {
          return this.val(type, value.v ? 1 : 0);
        } else if ((ref = type.name) === "float" || ref === "double") {
          if (!this.isNumericType(value.t)) {
            this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
          }
          if (this.inrange(type, value.v)) {
            return this.val(type, value.v);
          } else {
            this.raiseException("overflow when casting " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
          }
        } else {
          if (type.name.slice(0, 8) === "unsigned") {
            if (!this.isNumericType(value.t)) {
              this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
            } else if (value.v < 0) {
              bytes = this.config.limits[type.name].bytes;
              newValue = value.v & ((1 << 8 * bytes) - 1);
              if (!this.inrange(type, newValue)) {
                this.raiseException(("cannot cast negative value " + newValue + " to ") + this.makeTypeString(type));
              } else {
                return this.val(type, newValue);
              }
            }
          }
          if (!this.isNumericType(value.t)) {
            this.raiseException("cannot cast " + this.makeTypeString(value.t) + " to " + this.makeTypeString(type));
          }
          if (value.t.name === "float" || value.t.name === "double") {
            v = value.v > 0 ? Math.floor(value.v) : Math.ceil(value.v);
            if (this.inrange(type, v)) {
              return this.val(type, v);
            } else {
              this.raiseException("overflow when casting " + this.makeValString(value) + " to " + this.makeTypeString(type));
            }
          } else {
            if (this.inrange(type, value.v)) {
              return this.val(type, value.v);
            } else {
              this.raiseException("overflow when casting " + this.makeValString(value) + " to " + this.makeTypeString(type));
            }
          }
        }
      } else if (this.isPointerType(type)) {
        if (this.isFunctionType(type)) {
          if (this.isFunctionType(value.t)) {
            return this.val(value.t, value.v);
          } else {
            this.raiseException("cannot cast a regular pointer to a function");
          }
        } else if (this.isArrayType(value.t)) {
          if (this.isNormalPointerType(type)) {
            if (this.isTypeEqualTo(type.targetType, value.t.eleType)) {
              return value;
            } else {
              this.raiseException(this.makeTypeString(type.targetType) + " is not equal to array element type " + this.makeTypeString(value.t.eleType));
            }
          } else if (this.isArrayType(type)) {
            if (this.isTypeEqualTo(type.eleType, value.t.eleType)) {
              return value;
            } else {
              this.raiseException("array element type " + this.makeTypeString(type.eleType) + " is not equal to array element type " + this.makeTypeString(value.t.eleType));
            }
          } else {
            this.raiseException("cannot cast a function to a regular pointer");
          }
        } else {
          if (this.isNormalPointerType(type)) {
            if (this.isTypeEqualTo(type.targetType, value.t.targetType)) {
              return value;
            } else {
              this.raiseException(this.makeTypeString(type.targetType) + " is not equal to " + this.makeTypeString(value.t.eleType));
            }
          } else if (this.isArrayType(type)) {
            if (this.isTypeEqualTo(type.eleType, value.t.targetType)) {
              return value;
            } else {
              this.raiseException("array element type " + this.makeTypeString(type.eleType) + " is not equal to " + this.makeTypeString(value.t.eleType));
            }
          } else {
            this.raiseException("cannot cast a function to a regular pointer");
          }
        }
      } else if (this.isClassType(type)) {
        this.raiseException("not implemented");
      } else if (this.isClassType(value.t)) {
        value = this.getCompatibleFunc(value.t, this.makeOperatorFuncName(type.name), [])(this, value);
        return value;
      } else {
        this.raiseException("cast failed from type " + this.makeTypeString(type) + " to " + this.makeTypeString(value.t));
      }
    };
    CRuntime.prototype.clone = function(v) {
      return this.val(v.t, v.v);
    };
    CRuntime.prototype.enterScope = function(scopename) {
      this.scope.push({"$name": scopename});
    };
    CRuntime.prototype.exitScope = function(scopename) {
      var s;
      while (true) {
        s = this.scope.pop();
        if (!(scopename && this.scope.length > 1 && s["$name"] !== scopename)) {
          break;
        }
      }
    };
    CRuntime.prototype.val = function(type, v, left) {
      if (this.isNumericType(type) && !this.inrange(type, v)) {
        this.raiseException("overflow of " + (this.makeValString({
          t: type,
          v: v
        })));
      }
      if (left === void 0) {
        left = false;
      }
      return {
        "t": type,
        "v": v,
        "left": left
      };
    };
    CRuntime.prototype.isTypeEqualTo = function(type1, type2) {
      var _this;
      if (type1.type === type2.type) {
        switch (type1.type) {
          case "primitive":
          case "class":
            return type1.name === type2.name;
          case "pointer":
            if (type1.ptrType === type2.ptrType || type1.ptrType !== "function" && type2.ptrType !== "function") {
              switch (type1.ptrType) {
                case "array":
                  return this.isTypeEqualTo(type1.eleType, type2.eleType || type2.targetType);
                case "function":
                  return this.isTypeEqualTo(type1.funcType, type2.funcType);
                case "normal":
                  return this.isTypeEqualTo(type1.targetType, type2.eleType || type2.targetType);
              }
            }
            break;
          case "function":
            if (this.isTypeEqualTo(type1.retType, type2.retType) && type1.signature.length === type2.signature.length) {
              _this = this;
              return type1.signature.every(function(type, index, arr) {
                return _this.isTypeEqualTo(type, type2.signature[index]);
              });
            }
        }
      }
      return false;
    };
    CRuntime.prototype.isBoolType = function(type) {
      if (typeof type === "string") {
        return type === "bool";
      } else {
        return type.type === "primitive" && this.isBoolType(type.name);
      }
    };
    CRuntime.prototype.isVoidType = function(type) {
      if (typeof type === "string") {
        return type === "void";
      } else {
        return type.type === "primitive" && this.isVoidType(type.name);
      }
    };
    CRuntime.prototype.isPrimitiveType = function(type) {
      return this.isNumericType(type) || this.isBoolType(type) || this.isVoidType(type);
    };
    CRuntime.prototype.isArrayType = function(type) {
      return this.isPointerType(type) && type.ptrType === "array";
    };
    CRuntime.prototype.isFunctionType = function(type) {
      return type.type === "function" || this.isNormalPointerType(type) && this.isFunctionType(type.targetType);
    };
    CRuntime.prototype.isNormalPointerType = function(type) {
      return this.isPointerType(type) && type.ptrType === "normal";
    };
    CRuntime.prototype.isPointerType = function(type) {
      return type.type === "pointer";
    };
    CRuntime.prototype.isClassType = function(type) {
      return type.type === "class";
    };
    CRuntime.prototype.arrayPointerType = function(eleType, size) {
      return {
        type: "pointer",
        ptrType: "array",
        eleType: eleType,
        size: size
      };
    };
    CRuntime.prototype.makeArrayPointerValue = function(arr, position) {
      return {
        target: arr,
        position: position
      };
    };
    CRuntime.prototype.functionPointerType = function(retType, signature) {
      return this.normalPointerType(this.functionType(retType, signature));
    };
    CRuntime.prototype.functionType = function(retType, signature) {
      return {
        type: "function",
        retType: retType,
        signature: signature
      };
    };
    CRuntime.prototype.makeFunctionPointerValue = function(f, name, lt, args, retType) {
      return {
        target: f,
        name: name,
        defineType: lt,
        args: args,
        retType: retType
      };
    };
    CRuntime.prototype.normalPointerType = function(targetType) {
      return {
        type: "pointer",
        ptrType: "normal",
        targetType: targetType
      };
    };
    CRuntime.prototype.makeNormalPointerValue = function(target) {
      return {target: target};
    };
    CRuntime.prototype.simpleType = function(type) {
      var clsType,
          typeStr;
      if (Array.isArray(type)) {
        if (type.length > 1) {
          typeStr = type.filter((function(_this) {
            return function(t) {
              return indexOf.call(_this.config.specifiers, t) < 0;
            };
          })(this)).join(" ");
          return this.simpleType(typeStr);
        } else {
          return this.typedefs[type[0]] || this.simpleType(type[0]);
        }
      } else {
        if (this.isPrimitiveType(type)) {
          return this.primitiveType(type);
        } else {
          clsType = {
            type: "class",
            name: type
          };
          if (this.getTypeSignature(clsType) in this.types) {
            return clsType;
          } else {
            this.raiseException("type " + this.makeTypeString(type) + " is not defined");
          }
        }
      }
    };
    CRuntime.prototype.newClass = function(classname, members) {
      var clsType,
          sig;
      clsType = {
        type: "class",
        name: classname
      };
      sig = this.getTypeSignature(clsType);
      if (sig in this.types) {
        this.raiseException(this.makeTypeString(clsType) + " is already defined");
      }
      this.types[sig] = {"#constructor": function(rt, _this, initMembers) {
          var i,
              member;
          _this.v.members = {};
          i = 0;
          while (i < members.length) {
            member = members[i];
            _this.v.members[member.name] = initMembers[member.name];
            i++;
          }
        }};
      return clsType;
    };
    CRuntime.prototype.primitiveType = function(type) {
      return {
        type: "primitive",
        name: type
      };
    };
    CRuntime.prototype.isCharType = function(type) {
      return this.config.charTypes.indexOf(type.name) !== -1;
    };
    CRuntime.prototype.isStringType = function(type) {
      return this.isArrayType(type) && this.isCharType(type.eleType);
    };
    CRuntime.prototype.getStringFromCharArray = function(element) {
      var charVal,
          i,
          result,
          target;
      if (this.isStringType(element.t)) {
        target = element.v.target;
        result = "";
        i = 0;
        while (i < target.length) {
          charVal = target[i];
          if (charVal.v === 0) {
            break;
          }
          result += String.fromCharCode(charVal.v);
          i++;
        }
        return result;
      } else {
        this.raiseException("target is not a string");
      }
    };
    CRuntime.prototype.makeCharArrayFromString = function(str, typename) {
      var charType,
          self,
          trailingZero,
          type;
      self = this;
      typename || (typename = "char");
      charType = this.primitiveType(typename);
      type = this.arrayPointerType(charType, str.length + 1);
      trailingZero = this.val(charType, 0);
      return this.val(type, {
        target: str.split("").map(function(c) {
          return self.val(charType, c.charCodeAt(0));
        }).concat([trailingZero]),
        position: 0
      });
    };
    CRuntime.prototype.getTypeSignature = function(type) {
      var ret,
          self;
      ret = type;
      self = this;
      if (type.type === "primitive") {
        ret = "(" + type.name + ")";
      } else if (type.type === "class") {
        ret = "[" + type.name + "]";
      } else if (type.type === "pointer") {
        ret = "{";
        if (type.ptrType === "normal") {
          ret += "!" + this.getTypeSignature(type.targetType);
        } else if (type.ptrType === "array") {
          ret += "!" + this.getTypeSignature(type.eleType);
        }
        ret += "}";
      } else if (type.type === "function") {
        ret = "#" + this.getTypeSignature(type.retType) + "!" + type.signature.map((function(_this) {
          return function(e) {
            return _this.getTypeSignature(e);
          };
        })(this)).join(",");
      }
      return ret;
    };
    CRuntime.prototype.makeTypeString = function(type) {
      var ret;
      ret = "$" + type;
      if (type.type === "primitive") {
        ret = type.name;
      } else if (type.type === "class") {
        ret = type.name;
      } else if (type.type === "pointer") {
        ret = "";
        if (type.ptrType === "normal") {
          ret += this.makeTypeString(type.targetType) + "*";
        } else if (type.ptrType === "array") {
          ret += this.makeTypeString(type.eleType) + ("[" + type.size + "]");
        } else if (type.ptrType === "function") {
          ret += this.makeTypeString(type.retType) + "(*f)" + "(" + type.signature.map((function(_this) {
            return function(e) {
              return _this.makeTypeString(e);
            };
          })(this)).join(",") + ")";
        }
      }
      return ret;
    };
    CRuntime.prototype.makeValueString = function(l, options) {
      var display,
          i,
          j,
          ref,
          ref1;
      options || (options = {});
      if (this.isPrimitiveType(l.t)) {
        if (this.isTypeEqualTo(l.t, this.charTypeLiteral)) {
          display = "'" + String.fromCharCode(l.v) + "'";
        } else if (this.isBoolType(l.t)) {
          display = l.v !== 0 ? "true" : "false";
        } else {
          display = l.v;
        }
      } else if (this.isPointerType(l.t)) {
        if (this.isFunctionType(l.t)) {
          display = "<function>";
        } else if (this.isArrayType(l.t)) {
          if (this.isTypeEqualTo(l.t.eleType, this.charTypeLiteral)) {
            display = "\"" + this.getStringFromCharArray(l) + "\"";
          } else if (options.noArray) {
            display = "[...]";
          } else {
            options.noArray = true;
            display = [];
            for (i = j = ref = l.v.position, ref1 = l.v.target.length; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
              display.push(this.makeValueString(l.v.target[i], options));
            }
            display = "[" + display.join(",") + "]";
          }
        } else if (this.isNormalPointerType(l.t)) {
          if (options.noPointer) {
            display = "->?";
          } else {
            options.noPointer = true;
            display = "->" + this.makeValueString(l.v.target);
          }
        } else {
          this.raiseException("unknown pointer type");
        }
      } else if (this.isClassType(l.t)) {
        display = "<object>";
      }
      return display;
    };
    CRuntime.prototype.makeValString = function(l) {
      return this.makeValueString(l) + "(" + this.makeTypeString(l.t) + ")";
    };
    CRuntime.prototype.defaultValue = function(type, left) {
      var i,
          init,
          j,
          ref;
      if (type.type === "primitive") {
        if (this.isNumericType(type)) {
          return this.val(type, 0, left);
        }
      } else if (type.type === "class") {
        this.raiseException("no default value for object");
      } else if (type.type === "pointer") {
        if (type.ptrType === "normal") {
          return this.val(type, this.nullPointerValue, left);
        } else if (type.ptrType === "array") {
          init = [];
          for (i = j = 0, ref = type.size; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            init[i] = this.defaultValue(type.eleType, true);
          }
          return this.val(type, this.makeArrayPointerValue(init, 0), left);
        }
      }
    };
    CRuntime.prototype.raiseException = function(message) {
      var col,
          interp,
          ln,
          posInfo;
      interp = this.interp;
      if (interp) {
        posInfo = interp.currentNode != null ? (ln = interp.currentNode.sLine, col = interp.currentNode.sColumn, ln + ":" + col) : "<position unavailable>";
        throw posInfo + " " + message;
      } else {
        throw message;
      }
    };
    module.exports = CRuntime;
  }, {"./defaults": 3}],
  18: [function(require, module, exports) {}, {}],
  19: [function(require, module, exports) {
    (function(global) {
      var base64 = require('base64-js');
      var ieee754 = require('ieee754');
      var isArray = require('is-array');
      exports.Buffer = Buffer;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      Buffer.poolSize = 8192;
      var rootParent = {};
      Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
      function typedArraySupport() {
        function Bar() {}
        try {
          var arr = new Uint8Array(1);
          arr.foo = function() {
            return 42;
          };
          arr.constructor = Bar;
          return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
        } catch (e) {
          return false;
        }
      }
      function kMaxLength() {
        return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
      }
      function Buffer(arg) {
        if (!(this instanceof Buffer)) {
          if (arguments.length > 1)
            return new Buffer(arg, arguments[1]);
          return new Buffer(arg);
        }
        this.length = 0;
        this.parent = undefined;
        if (typeof arg === 'number') {
          return fromNumber(this, arg);
        }
        if (typeof arg === 'string') {
          return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
        }
        return fromObject(this, arg);
      }
      function fromNumber(that, length) {
        that = allocate(that, length < 0 ? 0 : checked(length) | 0);
        if (!Buffer.TYPED_ARRAY_SUPPORT) {
          for (var i = 0; i < length; i++) {
            that[i] = 0;
          }
        }
        return that;
      }
      function fromString(that, string, encoding) {
        if (typeof encoding !== 'string' || encoding === '')
          encoding = 'utf8';
        var length = byteLength(string, encoding) | 0;
        that = allocate(that, length);
        that.write(string, encoding);
        return that;
      }
      function fromObject(that, object) {
        if (Buffer.isBuffer(object))
          return fromBuffer(that, object);
        if (isArray(object))
          return fromArray(that, object);
        if (object == null) {
          throw new TypeError('must start with number, buffer, array or string');
        }
        if (typeof ArrayBuffer !== 'undefined') {
          if (object.buffer instanceof ArrayBuffer) {
            return fromTypedArray(that, object);
          }
          if (object instanceof ArrayBuffer) {
            return fromArrayBuffer(that, object);
          }
        }
        if (object.length)
          return fromArrayLike(that, object);
        return fromJsonObject(that, object);
      }
      function fromBuffer(that, buffer) {
        var length = checked(buffer.length) | 0;
        that = allocate(that, length);
        buffer.copy(that, 0, 0, length);
        return that;
      }
      function fromArray(that, array) {
        var length = checked(array.length) | 0;
        that = allocate(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      function fromTypedArray(that, array) {
        var length = checked(array.length) | 0;
        that = allocate(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      function fromArrayBuffer(that, array) {
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          array.byteLength;
          that = Buffer._augment(new Uint8Array(array));
        } else {
          that = fromTypedArray(that, new Uint8Array(array));
        }
        return that;
      }
      function fromArrayLike(that, array) {
        var length = checked(array.length) | 0;
        that = allocate(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      function fromJsonObject(that, object) {
        var array;
        var length = 0;
        if (object.type === 'Buffer' && isArray(object.data)) {
          array = object.data;
          length = checked(array.length) | 0;
        }
        that = allocate(that, length);
        for (var i = 0; i < length; i += 1) {
          that[i] = array[i] & 255;
        }
        return that;
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        Buffer.prototype.__proto__ = Uint8Array.prototype;
        Buffer.__proto__ = Uint8Array;
      }
      function allocate(that, length) {
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          that = Buffer._augment(new Uint8Array(length));
          that.__proto__ = Buffer.prototype;
        } else {
          that.length = length;
          that._isBuffer = true;
        }
        var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
        if (fromPool)
          that.parent = rootParent;
        return that;
      }
      function checked(length) {
        if (length >= kMaxLength()) {
          throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
        }
        return length | 0;
      }
      function SlowBuffer(subject, encoding) {
        if (!(this instanceof SlowBuffer))
          return new SlowBuffer(subject, encoding);
        var buf = new Buffer(subject, encoding);
        delete buf.parent;
        return buf;
      }
      Buffer.isBuffer = function isBuffer(b) {
        return !!(b != null && b._isBuffer);
      };
      Buffer.compare = function compare(a, b) {
        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
          throw new TypeError('Arguments must be Buffers');
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        var i = 0;
        var len = Math.min(x, y);
        while (i < len) {
          if (a[i] !== b[i])
            break;
          ++i;
        }
        if (i !== len) {
          x = a[i];
          y = b[i];
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'raw':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return true;
          default:
            return false;
        }
      };
      Buffer.concat = function concat(list, length) {
        if (!isArray(list))
          throw new TypeError('list argument must be an Array of Buffers.');
        if (list.length === 0) {
          return new Buffer(0);
        }
        var i;
        if (length === undefined) {
          length = 0;
          for (i = 0; i < list.length; i++) {
            length += list[i].length;
          }
        }
        var buf = new Buffer(length);
        var pos = 0;
        for (i = 0; i < list.length; i++) {
          var item = list[i];
          item.copy(buf, pos);
          pos += item.length;
        }
        return buf;
      };
      function byteLength(string, encoding) {
        if (typeof string !== 'string')
          string = '' + string;
        var len = string.length;
        if (len === 0)
          return 0;
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case 'ascii':
            case 'binary':
            case 'raw':
            case 'raws':
              return len;
            case 'utf8':
            case 'utf-8':
              return utf8ToBytes(string).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return len * 2;
            case 'hex':
              return len >>> 1;
            case 'base64':
              return base64ToBytes(string).length;
            default:
              if (loweredCase)
                return utf8ToBytes(string).length;
              encoding = ('' + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer.byteLength = byteLength;
      Buffer.prototype.length = undefined;
      Buffer.prototype.parent = undefined;
      function slowToString(encoding, start, end) {
        var loweredCase = false;
        start = start | 0;
        end = end === undefined || end === Infinity ? this.length : end | 0;
        if (!encoding)
          encoding = 'utf8';
        if (start < 0)
          start = 0;
        if (end > this.length)
          end = this.length;
        if (end <= start)
          return '';
        while (true) {
          switch (encoding) {
            case 'hex':
              return hexSlice(this, start, end);
            case 'utf8':
            case 'utf-8':
              return utf8Slice(this, start, end);
            case 'ascii':
              return asciiSlice(this, start, end);
            case 'binary':
              return binarySlice(this, start, end);
            case 'base64':
              return base64Slice(this, start, end);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError('Unknown encoding: ' + encoding);
              encoding = (encoding + '').toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer.prototype.toString = function toString() {
        var length = this.length | 0;
        if (length === 0)
          return '';
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer.prototype.equals = function equals(b) {
        if (!Buffer.isBuffer(b))
          throw new TypeError('Argument must be a Buffer');
        if (this === b)
          return true;
        return Buffer.compare(this, b) === 0;
      };
      Buffer.prototype.inspect = function inspect() {
        var str = '';
        var max = exports.INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
          if (this.length > max)
            str += ' ... ';
        }
        return '<Buffer ' + str + '>';
      };
      Buffer.prototype.compare = function compare(b) {
        if (!Buffer.isBuffer(b))
          throw new TypeError('Argument must be a Buffer');
        if (this === b)
          return 0;
        return Buffer.compare(this, b);
      };
      Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
        if (byteOffset > 0x7fffffff)
          byteOffset = 0x7fffffff;
        else if (byteOffset < -0x80000000)
          byteOffset = -0x80000000;
        byteOffset >>= 0;
        if (this.length === 0)
          return -1;
        if (byteOffset >= this.length)
          return -1;
        if (byteOffset < 0)
          byteOffset = Math.max(this.length + byteOffset, 0);
        if (typeof val === 'string') {
          if (val.length === 0)
            return -1;
          return String.prototype.indexOf.call(this, val, byteOffset);
        }
        if (Buffer.isBuffer(val)) {
          return arrayIndexOf(this, val, byteOffset);
        }
        if (typeof val === 'number') {
          if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
            return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
          }
          return arrayIndexOf(this, [val], byteOffset);
        }
        function arrayIndexOf(arr, val, byteOffset) {
          var foundIndex = -1;
          for (var i = 0; byteOffset + i < arr.length; i++) {
            if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === val.length)
                return byteOffset + foundIndex;
            } else {
              foundIndex = -1;
            }
          }
          return -1;
        }
        throw new TypeError('val must be string, number or Buffer');
      };
      Buffer.prototype.get = function get(offset) {
        console.log('.get() is deprecated. Access using array indexes instead.');
        return this.readUInt8(offset);
      };
      Buffer.prototype.set = function set(v, offset) {
        console.log('.set() is deprecated. Access using array indexes instead.');
        return this.writeUInt8(v, offset);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        var remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        var strLen = string.length;
        if (strLen % 2 !== 0)
          throw new Error('Invalid hex string');
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        for (var i = 0; i < length; i++) {
          var parsed = parseInt(string.substr(i * 2, 2), 16);
          if (isNaN(parsed))
            throw new Error('Invalid hex string');
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function binaryWrite(buf, string, offset, length) {
        return asciiWrite(buf, string, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer.prototype.write = function write(string, offset, length, encoding) {
        if (offset === undefined) {
          encoding = 'utf8';
          length = this.length;
          offset = 0;
        } else if (length === undefined && typeof offset === 'string') {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === undefined)
              encoding = 'utf8';
          } else {
            encoding = length;
            length = undefined;
          }
        } else {
          var swap = encoding;
          encoding = offset;
          offset = length | 0;
          length = swap;
        }
        var remaining = this.length - offset;
        if (length === undefined || length > remaining)
          length = remaining;
        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
          throw new RangeError('attempt to write outside buffer bounds');
        }
        if (!encoding)
          encoding = 'utf8';
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case 'hex':
              return hexWrite(this, string, offset, length);
            case 'utf8':
            case 'utf-8':
              return utf8Write(this, string, offset, length);
            case 'ascii':
              return asciiWrite(this, string, offset, length);
            case 'binary':
              return binaryWrite(this, string, offset, length);
            case 'base64':
              return base64Write(this, string, offset, length);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError('Unknown encoding: ' + encoding);
              encoding = ('' + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer.prototype.toJSON = function toJSON() {
        return {
          type: 'Buffer',
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        var res = [];
        var i = start;
        while (i < end) {
          var firstByte = buf[i];
          var codePoint = null;
          var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            var secondByte = void 0,
                thirdByte = void 0,
                fourthByte = void 0,
                tempCodePoint = void 0;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 0x80) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                  if (tempCodePoint > 0x7F) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                  if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                  tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                  if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
          } else if (codePoint > 0xFFFF) {
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 0x1000;
      function decodeCodePointsArray(codePoints) {
        var len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        var res = '';
        var i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        var ret = '';
        end = Math.min(buf.length, end);
        for (var i = start; i < end; i++) {
          ret += String.fromCharCode(buf[i] & 0x7F);
        }
        return ret;
      }
      function binarySlice(buf, start, end) {
        var ret = '';
        end = Math.min(buf.length, end);
        for (var i = start; i < end; i++) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        var len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        var out = '';
        for (var i = start; i < end; i++) {
          out += toHex(buf[i]);
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        var bytes = buf.slice(start, end);
        var res = '';
        for (var i = 0; i < bytes.length; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === undefined ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          newBuf = Buffer._augment(this.subarray(start, end));
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer(sliceLen, undefined);
          for (var i = 0; i < sliceLen; i++) {
            newBuf[i] = this[i + start];
          }
        }
        if (newBuf.length)
          newBuf.parent = this.parent || this;
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if ((offset % 1) !== 0 || offset < 0)
          throw new RangeError('offset is not uint');
        if (offset + ext > length)
          throw new RangeError('Trying to access beyond buffer length');
      }
      Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert)
          checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength, this.length);
        }
        var val = this[offset + --byteLength];
        var mul = 1;
        while (byteLength > 0 && (mul *= 0x100)) {
          val += this[offset + --byteLength] * mul;
        }
        return val;
      };
      Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | (this[offset + 1] << 8);
      };
      Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return (this[offset] << 8) | this[offset + 1];
      };
      Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
      };
      Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
      };
      Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert)
          checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
          val += this[offset + i] * mul;
        }
        mul *= 0x80;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength);
        return val;
      };
      Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert)
          checkOffset(offset, byteLength, this.length);
        var i = byteLength;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 0x100)) {
          val += this[offset + --i] * mul;
        }
        mul *= 0x80;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength);
        return val;
      };
      Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 0x80))
          return (this[offset]);
        return ((0xff - this[offset] + 1) * -1);
      };
      Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | (this[offset + 1] << 8);
        return (val & 0x8000) ? val | 0xFFFF0000 : val;
      };
      Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | (this[offset] << 8);
        return (val & 0x8000) ? val | 0xFFFF0000 : val;
      };
      Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
      };
      Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
      };
      Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer.isBuffer(buf))
          throw new TypeError('buffer must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('value is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError('index out of range');
      }
      Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert)
          checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
        var mul = 1;
        var i = 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength = byteLength | 0;
        if (!noAssert)
          checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
        var i = byteLength - 1;
        var mul = 1;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = (value / mul) & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 0xff, 0);
        if (!Buffer.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = (value & 0xff);
        return offset + 1;
      };
      function objectWriteUInt16(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 0xffff + value + 1;
        for (var i = 0,
            j = Math.min(buf.length - offset, 2); i < j; i++) {
          buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
        }
      }
      Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 0xffff, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff);
          this[offset + 1] = (value >>> 8);
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 0xffff, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8);
          this[offset + 1] = (value & 0xff);
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      function objectWriteUInt32(buf, value, offset, littleEndian) {
        if (value < 0)
          value = 0xffffffff + value + 1;
        for (var i = 0,
            j = Math.min(buf.length - offset, 4); i < j; i++) {
          buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
        }
      }
      Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 0xffffffff, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = (value >>> 24);
          this[offset + 2] = (value >>> 16);
          this[offset + 1] = (value >>> 8);
          this[offset] = (value & 0xff);
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 0xffffffff, 0);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24);
          this[offset + 1] = (value >>> 16);
          this[offset + 2] = (value >>> 8);
          this[offset + 3] = (value & 0xff);
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);
          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = value < 0 ? 1 : 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength - 1);
          checkInt(this, value, offset, byteLength, limit - 1, -limit);
        }
        var i = byteLength - 1;
        var mul = 1;
        var sub = value < 0 ? 1 : 0;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
          this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
        }
        return offset + byteLength;
      };
      Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 0x7f, -0x80);
        if (!Buffer.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 0xff + value + 1;
        this[offset] = (value & 0xff);
        return offset + 1;
      };
      Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 0x7fff, -0x8000);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff);
          this[offset + 1] = (value >>> 8);
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 0x7fff, -0x8000);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 8);
          this[offset + 1] = (value & 0xff);
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value & 0xff);
          this[offset + 1] = (value >>> 8);
          this[offset + 2] = (value >>> 16);
          this[offset + 3] = (value >>> 24);
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
        if (value < 0)
          value = 0xffffffff + value + 1;
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          this[offset] = (value >>> 24);
          this[offset + 1] = (value >>> 16);
          this[offset + 2] = (value >>> 8);
          this[offset + 3] = (value & 0xff);
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (value > max || value < min)
          throw new RangeError('value is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError('index out of range');
        if (offset < 0)
          throw new RangeError('index out of range');
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError('targetStart out of bounds');
        }
        if (start < 0 || start >= this.length)
          throw new RangeError('sourceStart out of bounds');
        if (end < 0)
          throw new RangeError('sourceEnd out of bounds');
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; i--) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; i++) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          target._set(this.subarray(start, start + len), targetStart);
        }
        return len;
      };
      Buffer.prototype.fill = function fill(value, start, end) {
        if (!value)
          value = 0;
        if (!start)
          start = 0;
        if (!end)
          end = this.length;
        if (end < start)
          throw new RangeError('end < start');
        if (end === start)
          return;
        if (this.length === 0)
          return;
        if (start < 0 || start >= this.length)
          throw new RangeError('start out of bounds');
        if (end < 0 || end > this.length)
          throw new RangeError('end out of bounds');
        var i;
        if (typeof value === 'number') {
          for (i = start; i < end; i++) {
            this[i] = value;
          }
        } else {
          var bytes = utf8ToBytes(value.toString());
          var len = bytes.length;
          for (i = start; i < end; i++) {
            this[i] = bytes[i % len];
          }
        }
        return this;
      };
      Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
        if (typeof Uint8Array !== 'undefined') {
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            return (new Buffer(this)).buffer;
          } else {
            var buf = new Uint8Array(this.length);
            for (var i = 0,
                len = buf.length; i < len; i += 1) {
              buf[i] = this[i];
            }
            return buf.buffer;
          }
        } else {
          throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
        }
      };
      var BP = Buffer.prototype;
      Buffer._augment = function _augment(arr) {
        arr.constructor = Buffer;
        arr._isBuffer = true;
        arr._set = arr.set;
        arr.get = BP.get;
        arr.set = BP.set;
        arr.write = BP.write;
        arr.toString = BP.toString;
        arr.toLocaleString = BP.toString;
        arr.toJSON = BP.toJSON;
        arr.equals = BP.equals;
        arr.compare = BP.compare;
        arr.indexOf = BP.indexOf;
        arr.copy = BP.copy;
        arr.slice = BP.slice;
        arr.readUIntLE = BP.readUIntLE;
        arr.readUIntBE = BP.readUIntBE;
        arr.readUInt8 = BP.readUInt8;
        arr.readUInt16LE = BP.readUInt16LE;
        arr.readUInt16BE = BP.readUInt16BE;
        arr.readUInt32LE = BP.readUInt32LE;
        arr.readUInt32BE = BP.readUInt32BE;
        arr.readIntLE = BP.readIntLE;
        arr.readIntBE = BP.readIntBE;
        arr.readInt8 = BP.readInt8;
        arr.readInt16LE = BP.readInt16LE;
        arr.readInt16BE = BP.readInt16BE;
        arr.readInt32LE = BP.readInt32LE;
        arr.readInt32BE = BP.readInt32BE;
        arr.readFloatLE = BP.readFloatLE;
        arr.readFloatBE = BP.readFloatBE;
        arr.readDoubleLE = BP.readDoubleLE;
        arr.readDoubleBE = BP.readDoubleBE;
        arr.writeUInt8 = BP.writeUInt8;
        arr.writeUIntLE = BP.writeUIntLE;
        arr.writeUIntBE = BP.writeUIntBE;
        arr.writeUInt16LE = BP.writeUInt16LE;
        arr.writeUInt16BE = BP.writeUInt16BE;
        arr.writeUInt32LE = BP.writeUInt32LE;
        arr.writeUInt32BE = BP.writeUInt32BE;
        arr.writeIntLE = BP.writeIntLE;
        arr.writeIntBE = BP.writeIntBE;
        arr.writeInt8 = BP.writeInt8;
        arr.writeInt16LE = BP.writeInt16LE;
        arr.writeInt16BE = BP.writeInt16BE;
        arr.writeInt32LE = BP.writeInt32LE;
        arr.writeInt32BE = BP.writeInt32BE;
        arr.writeFloatLE = BP.writeFloatLE;
        arr.writeFloatBE = BP.writeFloatBE;
        arr.writeDoubleLE = BP.writeDoubleLE;
        arr.writeDoubleBE = BP.writeDoubleBE;
        arr.fill = BP.fill;
        arr.inspect = BP.inspect;
        arr.toArrayBuffer = BP.toArrayBuffer;
        return arr;
      };
      var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = stringtrim(str).replace(INVALID_BASE64_RE, '');
        if (str.length < 2)
          return '';
        while (str.length % 4 !== 0) {
          str = str + '=';
        }
        return str;
      }
      function stringtrim(str) {
        if (str.trim)
          return str.trim();
        return str.replace(/^\s+|\s+$/g, '');
      }
      function toHex(n) {
        if (n < 16)
          return '0' + n.toString(16);
        return n.toString(16);
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        var codePoint;
        var length = string.length;
        var leadSurrogate = null;
        var bytes = [];
        for (var i = 0; i < length; i++) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 0xD7FF && codePoint < 0xE000) {
            if (!leadSurrogate) {
              if (codePoint > 0xDBFF) {
                if ((units -= 3) > -1)
                  bytes.push(0xEF, 0xBF, 0xBD);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(0xEF, 0xBF, 0xBD);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 0xDC00) {
              if ((units -= 3) > -1)
                bytes.push(0xEF, 0xBF, 0xBD);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
          }
          leadSurrogate = null;
          if (codePoint < 0x80) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 0x800) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
          } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
          } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
          } else {
            throw new Error('Invalid code point');
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
          byteArray.push(str.charCodeAt(i) & 0xFF);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        var c,
            hi,
            lo;
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        for (var i = 0; i < length; i++) {
          if ((i + offset >= dst.length) || (i >= src.length))
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "base64-js": 20,
    "ieee754": 21,
    "is-array": 22
  }],
  20: [function(require, module, exports) {
    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    ;
    (function(exports) {
      'use strict';
      var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
      var PLUS = '+'.charCodeAt(0);
      var SLASH = '/'.charCodeAt(0);
      var NUMBER = '0'.charCodeAt(0);
      var LOWER = 'a'.charCodeAt(0);
      var UPPER = 'A'.charCodeAt(0);
      var PLUS_URL_SAFE = '-'.charCodeAt(0);
      var SLASH_URL_SAFE = '_'.charCodeAt(0);
      function decode(elt) {
        var code = elt.charCodeAt(0);
        if (code === PLUS || code === PLUS_URL_SAFE)
          return 62;
        if (code === SLASH || code === SLASH_URL_SAFE)
          return 63;
        if (code < NUMBER)
          return -1;
        if (code < NUMBER + 10)
          return code - NUMBER + 26 + 26;
        if (code < UPPER + 26)
          return code - UPPER;
        if (code < LOWER + 26)
          return code - LOWER + 26;
      }
      function b64ToByteArray(b64) {
        var i,
            j,
            l,
            tmp,
            placeHolders,
            arr;
        if (b64.length % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }
        var len = b64.length;
        placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
        arr = new Arr(b64.length * 3 / 4 - placeHolders);
        l = placeHolders > 0 ? b64.length - 4 : b64.length;
        var L = 0;
        function push(v) {
          arr[L++] = v;
        }
        for (i = 0, j = 0; i < l; i += 4, j += 3) {
          tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
          push((tmp & 0xFF0000) >> 16);
          push((tmp & 0xFF00) >> 8);
          push(tmp & 0xFF);
        }
        if (placeHolders === 2) {
          tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
          push(tmp & 0xFF);
        } else if (placeHolders === 1) {
          tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
          push((tmp >> 8) & 0xFF);
          push(tmp & 0xFF);
        }
        return arr;
      }
      function uint8ToBase64(uint8) {
        var i,
            extraBytes = uint8.length % 3,
            output = "",
            temp,
            length;
        function encode(num) {
          return lookup.charAt(num);
        }
        function tripletToBase64(num) {
          return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
        }
        for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
          temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
          output += tripletToBase64(temp);
        }
        switch (extraBytes) {
          case 1:
            temp = uint8[uint8.length - 1];
            output += encode(temp >> 2);
            output += encode((temp << 4) & 0x3F);
            output += '==';
            break;
          case 2:
            temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
            output += encode(temp >> 10);
            output += encode((temp >> 4) & 0x3F);
            output += encode((temp << 2) & 0x3F);
            output += '=';
            break;
        }
        return output;
      }
      exports.toByteArray = b64ToByteArray;
      exports.fromByteArray = uint8ToBase64;
    }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  }, {}],
  21: [function(require, module, exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e,
          m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? (nBytes - 1) : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & ((1 << (-nBits)) - 1);
      s >>= (-nBits);
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      m = e & ((1 << (-nBits)) - 1);
      e >>= (-nBits);
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity);
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e,
          m,
          c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
      var i = isLE ? 0 : (nBytes - 1);
      var d = isLE ? 1 : -1;
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
      e = (e << mLen) | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
      buffer[offset + i - d] |= s * 128;
    };
  }, {}],
  22: [function(require, module, exports) {
    var isArray = Array.isArray;
    var str = Object.prototype.toString;
    module.exports = isArray || function(val) {
      return !!val && '[object Array]' == str.call(val);
    };
  }, {}],
  23: [function(require, module, exports) {
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError('n must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.emit = function(type) {
      var er,
          handler,
          len,
          args,
          i,
          listeners;
      if (!this._events)
        this._events = {};
      if (type === 'error') {
        if (!this._events.error || (isObject(this._events.error) && !this._events.error.length)) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er;
          }
          throw TypeError('Uncaught, unspecified "error" event.');
        }
      }
      handler = this._events[type];
      if (isUndefined(handler))
        return false;
      if (isFunction(handler)) {
        switch (arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          default:
            len = arguments.length;
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
          listeners[i].apply(this, args);
      }
      return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
      if (!this._events)
        this._events = {};
      if (this._events.newListener)
        this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
      if (!this._events[type])
        this._events[type] = listener;
      else if (isObject(this._events[type]))
        this._events[type].push(listener);
      else
        this._events[type] = [this._events[type], listener];
      if (isObject(this._events[type]) && !this._events[type].warned) {
        var m;
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
          if (typeof console.trace === 'function') {
            console.trace();
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
      var fired = false;
      function g() {
        this.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
      g.listener = listener;
      this.on(type, g);
      return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list,
          position,
          length,
          i;
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
      if (!this._events || !this._events[type])
        return this;
      list = this._events[type];
      length = list.length;
      position = -1;
      if (list === listener || (isFunction(list.listener) && list.listener === listener)) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      } else if (isObject(list)) {
        for (i = length; i-- > 0; ) {
          if (list[i] === listener || (list[i].listener && list[i].listener === listener)) {
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key,
          listeners;
      if (!this._events)
        return this;
      if (!this._events.removeListener) {
        if (arguments.length === 0)
          this._events = {};
        else if (this._events[type])
          delete this._events[type];
        return this;
      }
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener')
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
      }
      listeners = this._events[type];
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else {
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type])
        ret = [];
      else if (isFunction(this._events[type]))
        ret = [this._events[type]];
      else
        ret = this._events[type].slice();
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      var ret;
      if (!emitter._events || !emitter._events[type])
        ret = 0;
      else if (isFunction(emitter._events[type]))
        ret = 1;
      else
        ret = emitter._events[type].length;
      return ret;
    };
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    function isObject(arg) {
      return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && arg !== null;
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
  }, {}],
  24: [function(require, module, exports) {
    if (typeof Object.create === 'function') {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }});
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }, {}],
  25: [function(require, module, exports) {
    module.exports = function(obj) {
      return !!(obj != null && (obj._isBuffer || (obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj))));
    };
  }, {}],
  26: [function(require, module, exports) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
  }, {}],
  27: [function(require, module, exports) {
    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = setTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      clearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = '';
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.binding = function(name) {
      throw new Error('process.binding is not supported');
    };
    process.cwd = function() {
      return '/';
    };
    process.chdir = function(dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function() {
      return 0;
    };
  }, {}],
  28: [function(require, module, exports) {
    module.exports = require("./lib/_stream_duplex.js");
  }, {"./lib/_stream_duplex.js": 29}],
  29: [function(require, module, exports) {
    'use strict';
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    module.exports = Duplex;
    var processNextTick = require('process-nextick-args');
    var util = require('core-util-is');
    util.inherits = require('inherits');
    var Readable = require('./_stream_readable');
    var Writable = require('./_stream_writable');
    util.inherits(Duplex, Readable);
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once('end', onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      processNextTick(onEndNT, this);
    }
    function onEndNT(self) {
      self.end();
    }
    function forEach(xs, f) {
      for (var i = 0,
          l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }, {
    "./_stream_readable": 31,
    "./_stream_writable": 33,
    "core-util-is": 34,
    "inherits": 24,
    "process-nextick-args": 35
  }],
  30: [function(require, module, exports) {
    'use strict';
    module.exports = PassThrough;
    var Transform = require('./_stream_transform');
    var util = require('core-util-is');
    util.inherits = require('inherits');
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }, {
    "./_stream_transform": 32,
    "core-util-is": 34,
    "inherits": 24
  }],
  31: [function(require, module, exports) {
    (function(process) {
      'use strict';
      module.exports = Readable;
      var processNextTick = require('process-nextick-args');
      var isArray = require('isarray');
      var Buffer = require('buffer').Buffer;
      Readable.ReadableState = ReadableState;
      var EE = require('events').EventEmitter;
      if (!EE.listenerCount)
        EE.listenerCount = function(emitter, type) {
          return emitter.listeners(type).length;
        };
      var Stream;
      (function() {
        try {
          Stream = require('st' + 'ream');
        } catch (_) {} finally {
          if (!Stream)
            Stream = require('events').EventEmitter;
        }
      }());
      var Buffer = require('buffer').Buffer;
      var util = require('core-util-is');
      util.inherits = require('inherits');
      var debug = require('util');
      if (debug && debug.debuglog) {
        debug = debug.debuglog('stream');
      } else {
        debug = function() {};
      }
      var StringDecoder;
      util.inherits(Readable, Stream);
      function ReadableState(options, stream) {
        var Duplex = require('./_stream_duplex');
        options = options || {};
        this.objectMode = !!options.objectMode;
        if (stream instanceof Duplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
        this.highWaterMark = ~~this.highWaterMark;
        this.buffer = [];
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.defaultEncoding = options.defaultEncoding || 'utf8';
        this.ranOut = false;
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder)
            StringDecoder = require('string_decoder/').StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        var Duplex = require('./_stream_duplex');
        if (!(this instanceof Readable))
          return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options && typeof options.read === 'function')
          this._read = options.read;
        Stream.call(this);
      }
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === 'string') {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = new Buffer(chunk, encoding);
            encoding = '';
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, '', true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      function readableAddChunk(stream, state, chunk, encoding, addToFront) {
        var er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit('error', er);
        } else if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (state.ended && !addToFront) {
            var e = new Error('stream.push() after EOF');
            stream.emit('error', e);
          } else if (state.endEmitted && addToFront) {
            var e = new Error('stream.unshift() after end event');
            stream.emit('error', e);
          } else {
            if (state.decoder && !addToFront && !encoding)
              chunk = state.decoder.write(chunk);
            if (!addToFront)
              state.reading = false;
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit('data', chunk);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
        } else if (!addToFront) {
          state.reading = false;
        }
        return needMoreData(state);
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder)
          StringDecoder = require('string_decoder/').StringDecoder;
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 0x800000;
      function roundUpToNextPowerOf2(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          for (var p = 1; p < 32; p <<= 1)
            n |= n >> p;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return n === 0 ? 0 : 1;
        if (n === null || isNaN(n)) {
          if (state.flowing && state.buffer.length)
            return state.buffer[0].length;
          else
            return state.length;
        }
        if (n <= 0)
          return 0;
        if (n > state.highWaterMark)
          state.highWaterMark = roundUpToNextPowerOf2(n);
        if (n > state.length) {
          if (!state.ended) {
            state.needReadable = true;
            return 0;
          } else {
            return state.length;
          }
        }
        return n;
      }
      Readable.prototype.read = function(n) {
        debug('read', n);
        var state = this._readableState;
        var nOrig = n;
        if (typeof n !== 'number' || n > 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug('read: emitReadable', state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug('need readable', doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug('length less than watermark', doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug('reading or ended', doRead);
        }
        if (doRead) {
          debug('do read');
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
        }
        if (doRead && !state.reading)
          n = howMuchToRead(nOrig, state);
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        }
        state.length -= n;
        if (state.length === 0 && !state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended && state.length === 0)
          endReadable(this);
        if (ret !== null)
          this.emit('data', ret);
        return ret;
      };
      function chunkInvalid(state, chunk) {
        var er = null;
        if (!(Buffer.isBuffer(chunk)) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
          er = new TypeError('Invalid non-string/buffer chunk');
        }
        return er;
      }
      function onEofChunk(stream, state) {
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug('emitReadable', state.flowing);
          state.emittedReadable = true;
          if (state.sync)
            processNextTick(emitReadable_, stream);
          else
            emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug('emit readable');
        stream.emit('readable');
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          processNextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug('maybeReadMore read 0');
          stream.read(0);
          if (len === state.length)
            break;
          else
            len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        this.emit('error', new Error('not implemented'));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend : cleanup;
        if (state.endEmitted)
          processNextTick(endFn);
        else
          src.once('end', endFn);
        dest.on('unpipe', onunpipe);
        function onunpipe(readable) {
          debug('onunpipe');
          if (readable === src) {
            cleanup();
          }
        }
        function onend() {
          debug('onend');
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on('drain', ondrain);
        function cleanup() {
          debug('cleanup');
          dest.removeListener('close', onclose);
          dest.removeListener('finish', onfinish);
          dest.removeListener('drain', ondrain);
          dest.removeListener('error', onerror);
          dest.removeListener('unpipe', onunpipe);
          src.removeListener('end', onend);
          src.removeListener('end', cleanup);
          src.removeListener('data', ondata);
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on('data', ondata);
        function ondata(chunk) {
          debug('ondata');
          var ret = dest.write(chunk);
          if (false === ret) {
            debug('false write response, pause', src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            src.pause();
          }
        }
        function onerror(er) {
          debug('onerror', er);
          unpipe();
          dest.removeListener('error', onerror);
          if (EE.listenerCount(dest, 'error') === 0)
            dest.emit('error', er);
        }
        if (!dest._events || !dest._events.error)
          dest.on('error', onerror);
        else if (isArray(dest._events.error))
          dest._events.error.unshift(onerror);
        else
          dest._events.error = [onerror, dest._events.error];
        function onclose() {
          dest.removeListener('finish', onfinish);
          unpipe();
        }
        dest.once('close', onclose);
        function onfinish() {
          debug('onfinish');
          dest.removeListener('close', onclose);
          unpipe();
        }
        dest.once('finish', onfinish);
        function unpipe() {
          debug('unpipe');
          src.unpipe(dest);
        }
        dest.emit('pipe', src);
        if (!state.flowing) {
          debug('pipe resume');
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug('pipeOnDrain', state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit('unpipe', this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++)
            dests[i].emit('unpipe', this);
          return this;
        }
        var i = indexOf(state.pipes, dest);
        if (i === -1)
          return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit('unpipe', this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        if (ev === 'data' && false !== this._readableState.flowing) {
          this.resume();
        }
        if (ev === 'readable' && this.readable) {
          var state = this._readableState;
          if (!state.readableListening) {
            state.readableListening = true;
            state.emittedReadable = false;
            state.needReadable = true;
            if (!state.reading) {
              processNextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this, state);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self) {
        debug('readable nexttick read 0');
        self.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug('resume');
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          processNextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug('resume read 0');
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit('resume');
        flow(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug('call pause flowing=%j', this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug('pause');
          this._readableState.flowing = false;
          this.emit('pause');
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug('flow', state.flowing);
        if (state.flowing) {
          do {
            var chunk = stream.read();
          } while (null !== chunk && state.flowing);
        }
      }
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self = this;
        stream.on('end', function() {
          debug('wrapped end');
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self.push(chunk);
          }
          self.push(null);
        });
        stream.on('data', function(chunk) {
          debug('wrapped data');
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === undefined))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === undefined && typeof stream[i] === 'function') {
            this[i] = function(method) {
              return function() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        var events = ['error', 'close', 'destroy', 'pause', 'resume'];
        forEach(events, function(ev) {
          stream.on(ev, self.emit.bind(self, ev));
        });
        self._read = function(n) {
          debug('wrapped _read', n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self;
      };
      Readable._fromList = fromList;
      function fromList(n, state) {
        var list = state.buffer;
        var length = state.length;
        var stringMode = !!state.decoder;
        var objectMode = !!state.objectMode;
        var ret;
        if (list.length === 0)
          return null;
        if (length === 0)
          ret = null;
        else if (objectMode)
          ret = list.shift();
        else if (!n || n >= length) {
          if (stringMode)
            ret = list.join('');
          else
            ret = Buffer.concat(list, length);
          list.length = 0;
        } else {
          if (n < list[0].length) {
            var buf = list[0];
            ret = buf.slice(0, n);
            list[0] = buf.slice(n);
          } else if (n === list[0].length) {
            ret = list.shift();
          } else {
            if (stringMode)
              ret = '';
            else
              ret = new Buffer(n);
            var c = 0;
            for (var i = 0,
                l = list.length; i < l && c < n; i++) {
              var buf = list[0];
              var cpy = Math.min(n - c, buf.length);
              if (stringMode)
                ret += buf.slice(0, cpy);
              else
                buf.copy(ret, c, 0, cpy);
              if (cpy < buf.length)
                list[0] = buf.slice(cpy);
              else
                list.shift();
              c += cpy;
            }
          }
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0)
          throw new Error('endReadable called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          processNextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit('end');
        }
      }
      function forEach(xs, f) {
        for (var i = 0,
            l = xs.length; i < l; i++) {
          f(xs[i], i);
        }
      }
      function indexOf(xs, x) {
        for (var i = 0,
            l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }).call(this, require('_process'));
  }, {
    "./_stream_duplex": 29,
    "_process": 27,
    "buffer": 19,
    "core-util-is": 34,
    "events": 23,
    "inherits": 24,
    "isarray": 26,
    "process-nextick-args": 35,
    "string_decoder/": 42,
    "util": 18
  }],
  32: [function(require, module, exports) {
    'use strict';
    module.exports = Transform;
    var Duplex = require('./_stream_duplex');
    var util = require('core-util-is');
    util.inherits = require('inherits');
    util.inherits(Transform, Duplex);
    function TransformState(stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== undefined)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === 'function')
          this._transform = options.transform;
        if (typeof options.flush === 'function')
          this._flush = options.flush;
      }
      this.once('prefinish', function() {
        if (typeof this._flush === 'function')
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error('not implemented');
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit('error', er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error('calling transform done when ws.length != 0');
      if (ts.transforming)
        throw new Error('calling transform done when still transforming');
      return stream.push(null);
    }
  }, {
    "./_stream_duplex": 29,
    "core-util-is": 34,
    "inherits": 24
  }],
  33: [function(require, module, exports) {
    'use strict';
    module.exports = Writable;
    var processNextTick = require('process-nextick-args');
    var Buffer = require('buffer').Buffer;
    Writable.WritableState = WritableState;
    var util = require('core-util-is');
    util.inherits = require('inherits');
    var Stream;
    (function() {
      try {
        Stream = require('st' + 'ream');
      } catch (_) {} finally {
        if (!Stream)
          Stream = require('events').EventEmitter;
      }
    }());
    var Buffer = require('buffer').Buffer;
    util.inherits(Writable, Stream);
    function nop() {}
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
      this.next = null;
    }
    function WritableState(options, stream) {
      var Duplex = require('./_stream_duplex');
      options = options || {};
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || 'utf8';
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, 'buffer', {get: require('util-deprecate')(function() {
            return this.getBuffer();
          }, '_writableState.buffer is deprecated. Use ' + '_writableState.getBuffer() instead.')});
      } catch (_) {}
    }());
    function Writable(options) {
      var Duplex = require('./_stream_duplex');
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === 'function')
          this._write = options.write;
        if (typeof options.writev === 'function')
          this._writev = options.writev;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit('error', new Error('Cannot pipe. Not readable.'));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error('write after end');
      stream.emit('error', er);
      processNextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!(Buffer.isBuffer(chunk)) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        var er = new TypeError('Invalid non-string/buffer chunk');
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== 'function')
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
      if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
      this._writableState.defaultEncoding = encoding;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = new Buffer(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer.isBuffer(chunk))
        encoding = 'buffer';
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync)
        processNextTick(cb, er);
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit('error', er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          processNextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var buffer = [];
        var cbs = [];
        while (entry) {
          cbs.push(entry.callback);
          buffer.push(entry);
          entry = entry.next;
        }
        state.pendingcb++;
        state.lastBufferedRequest = null;
        doWrite(stream, state, true, state.length, buffer, '', function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error('not implemented'));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return (state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing);
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit('finish');
        } else {
          prefinish(stream, state);
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          processNextTick(cb);
        else
          stream.once('finish', cb);
      }
      state.ended = true;
    }
  }, {
    "./_stream_duplex": 29,
    "buffer": 19,
    "core-util-is": 34,
    "events": 23,
    "inherits": 24,
    "process-nextick-args": 35,
    "util-deprecate": 36
  }],
  34: [function(require, module, exports) {
    (function(Buffer) {
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === 'number';
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === 'string';
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol';
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === '[object RegExp]';
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === '[object Date]';
      }
      exports.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === 'function';
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol' || typeof arg === 'undefined';
      }
      exports.isPrimitive = isPrimitive;
      function isBuffer(arg) {
        return Buffer.isBuffer(arg);
      }
      exports.isBuffer = isBuffer;
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
    }).call(this, {"isBuffer": require("D:\\projects\\nodejs\\JSCPP\\node_modules\\grunt-browserify\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\is-buffer\\index.js")});
  }, {"D:\\projects\\nodejs\\JSCPP\\node_modules\\grunt-browserify\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\is-buffer\\index.js": 25}],
  35: [function(require, module, exports) {
    (function(process) {
      'use strict';
      module.exports = nextTick;
      function nextTick(fn) {
        var args = new Array(arguments.length - 1);
        var i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
      }
    }).call(this, require('_process'));
  }, {"_process": 27}],
  36: [function(require, module, exports) {
    (function(global) {
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config('noDeprecation')) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config('throwDeprecation')) {
              throw new Error(msg);
            } else if (config('traceDeprecation')) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!global.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = global.localStorage[name];
        if (null == val)
          return false;
        return String(val).toLowerCase() === 'true';
      }
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}],
  37: [function(require, module, exports) {
    module.exports = require("./lib/_stream_passthrough.js");
  }, {"./lib/_stream_passthrough.js": 30}],
  38: [function(require, module, exports) {
    var Stream = (function() {
      try {
        return require('st' + 'ream');
      } catch (_) {}
    }());
    exports = module.exports = require('./lib/_stream_readable.js');
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = require('./lib/_stream_writable.js');
    exports.Duplex = require('./lib/_stream_duplex.js');
    exports.Transform = require('./lib/_stream_transform.js');
    exports.PassThrough = require('./lib/_stream_passthrough.js');
  }, {
    "./lib/_stream_duplex.js": 29,
    "./lib/_stream_passthrough.js": 30,
    "./lib/_stream_readable.js": 31,
    "./lib/_stream_transform.js": 32,
    "./lib/_stream_writable.js": 33
  }],
  39: [function(require, module, exports) {
    module.exports = require("./lib/_stream_transform.js");
  }, {"./lib/_stream_transform.js": 32}],
  40: [function(require, module, exports) {
    module.exports = require("./lib/_stream_writable.js");
  }, {"./lib/_stream_writable.js": 33}],
  41: [function(require, module, exports) {
    module.exports = Stream;
    var EE = require('events').EventEmitter;
    var inherits = require('inherits');
    inherits(Stream, EE);
    Stream.Readable = require('readable-stream/readable.js');
    Stream.Writable = require('readable-stream/writable.js');
    Stream.Duplex = require('readable-stream/duplex.js');
    Stream.Transform = require('readable-stream/transform.js');
    Stream.PassThrough = require('readable-stream/passthrough.js');
    Stream.Stream = Stream;
    function Stream() {
      EE.call(this);
    }
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on('data', ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on('drain', ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function')
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) {
          throw er;
        }
      }
      source.on('error', onerror);
      dest.on('error', onerror);
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
      }
      source.on('end', cleanup);
      source.on('close', cleanup);
      dest.on('close', cleanup);
      dest.emit('pipe', source);
      return dest;
    };
  }, {
    "events": 23,
    "inherits": 24,
    "readable-stream/duplex.js": 28,
    "readable-stream/passthrough.js": 37,
    "readable-stream/readable.js": 38,
    "readable-stream/transform.js": 39,
    "readable-stream/writable.js": 40
  }],
  42: [function(require, module, exports) {
    var Buffer = require('buffer').Buffer;
    var isBufferEncoding = Buffer.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
      assertEncoding(encoding);
      switch (this.encoding) {
        case 'utf8':
          this.surrogateSize = 3;
          break;
        case 'ucs2':
        case 'utf16le':
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case 'base64':
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = '';
      while (this.charLength) {
        var available = (buffer.length >= this.charLength - this.charReceived) ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          this.charLength += this.surrogateSize;
          charStr = '';
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = (buffer.length >= 3) ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 0x06) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 0x0E) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 0x1E) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = '';
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }, {"buffer": 19}],
  43: [function(require, module, exports) {
    module.exports = function isBuffer(arg) {
      return arg && (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
    };
  }, {}],
  44: [function(require, module, exports) {
    (function(process, global) {
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(' ');
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x) {
          if (x === '%%')
            return '%';
          if (i >= len)
            return x;
          switch (x) {
            case '%s':
              return String(args[i++]);
            case '%d':
              return Number(args[i++]);
            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }
            default:
              return x;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
          } else {
            str += ' ' + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (isUndefined(global.process)) {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        if (process.noDeprecation === true) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnviron;
      exports.debuglog = function(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = process.env.NODE_DEBUG || '';
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error('%s %d: %s', set, pid, msg);
            };
          } else {
            debugs[set] = function() {};
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        'bold': [1, 22],
        'italic': [3, 23],
        'underline': [4, 24],
        'inverse': [7, 27],
        'white': [37, 39],
        'grey': [90, 39],
        'black': [30, 39],
        'blue': [34, 39],
        'cyan': [36, 39],
        'green': [32, 39],
        'magenta': [35, 39],
        'red': [31, 39],
        'yellow': [33, 39]
      };
      inspect.styles = {
        'special': 'cyan',
        'number': 'yellow',
        'boolean': 'yellow',
        'undefined': 'grey',
        'null': 'bold',
        'string': 'green',
        'date': 'magenta',
        'regexp': 'red'
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = '',
            array = false,
            braces = ['{', '}'];
        if (isArray(value)) {
          array = true;
          braces = ['[', ']'];
        }
        if (isFunction(value)) {
          var n = value.name ? ': ' + value.name : '';
          base = ' [Function' + n + ']';
        }
        if (isRegExp(value)) {
          base = ' ' + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = ' ' + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = ' ' + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
          } else {
            return ctx.stylize('[Object]', 'special');
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize('undefined', 'undefined');
        if (isString(value)) {
          var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
          return ctx.stylize(simple, 'string');
        }
        if (isNumber(value))
          return ctx.stylize('' + value, 'number');
        if (isBoolean(value))
          return ctx.stylize('' + value, 'boolean');
        if (isNull(value))
          return ctx.stylize('null', 'null');
      }
      function formatError(value) {
        return '[' + Error.prototype.toString.call(value) + ']';
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0,
            l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push('');
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name,
            str,
            desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
          } else {
            str = ctx.stylize('[Getter]', 'special');
          }
        } else {
          if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = '[' + key + ']';
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
              if (array) {
                str = str.split('\n').map(function(line) {
                  return '  ' + line;
                }).join('\n').substr(2);
              } else {
                str = '\n' + str.split('\n').map(function(line) {
                  return '   ' + line;
                }).join('\n');
              }
            }
          } else {
            str = ctx.stylize('[Circular]', 'special');
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify('' + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
          }
        }
        return name + ': ' + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf('\n') >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
        }
        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
      }
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === 'boolean';
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === 'number';
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === 'string';
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol';
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === '[object RegExp]';
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'object' && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === '[object Date]';
      }
      exports.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === 'function';
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : $traceurRuntime.typeof(arg)) === 'symbol' || typeof arg === 'undefined';
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require('./support/isBuffer');
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? '0' + n.toString(10) : n.toString(10);
      }
      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      function timestamp() {
        var d = new Date();
        var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
        return [d.getDate(), months[d.getMonth()], time].join(' ');
      }
      exports.log = function() {
        console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require('inherits');
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {
    "./support/isBuffer": 43,
    "_process": 27,
    "inherits": 24
  }],
  45: [function(require, module, exports) {
    (function(global) {
      (function(root, name, factory) {
        if (typeof define === "function" && typeof define.amd !== "undefined")
          define(name, function() {
            return factory(root);
          });
        else if ((typeof module === 'undefined' ? 'undefined' : $traceurRuntime.typeof(module)) === "object" && $traceurRuntime.typeof(module.exports) === "object")
          module.exports = factory(root);
        else
          root[name] = factory(root);
      }((typeof global !== "undefined" ? global : (typeof window !== "undefined" ? window : this)), "PEGUtil", function() {
        var PEGUtil = {};
        PEGUtil.makeAST = function makeAST(line, column, offset, options) {
          return function() {
            return options.util.__makeAST.call(null, line(), column(), offset(), arguments);
          };
        };
        PEGUtil.makeUnroll = function(line, column, offset, SyntaxError) {
          return function(first, list, take) {
            if ((typeof list === 'undefined' ? 'undefined' : $traceurRuntime.typeof(list)) !== "object" || !(list instanceof Array))
              throw new SyntaxError("unroll: invalid list argument for unrolling", ((typeof list === 'undefined' ? 'undefined' : $traceurRuntime.typeof(list))), "Array", offset(), line(), column());
            if (typeof take !== "undefined") {
              if (typeof take === "number")
                take = [take];
              var result = [];
              if (first !== null)
                result.push(first);
              for (var i = 0; i < list.length; i++) {
                for (var j = 0; j < take.length; j++)
                  result.push(list[i][take[j]]);
              }
              return result;
            } else {
              if (first !== null)
                list.unshift(first);
              return list;
            }
          };
        };
        var excerpt = function(txt, o) {
          var l = txt.length;
          var b = o - 20;
          if (b < 0)
            b = 0;
          var e = o + 20;
          if (e > l)
            e = l;
          var hex = function(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          };
          var extract = function(txt, pos, len) {
            return txt.substr(pos, len).replace(/\\/g, "\\\\").replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
              return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
              return "\\x" + hex(ch);
            }).replace(/[\u0100-\u0FFF]/g, function(ch) {
              return "\\u0" + hex(ch);
            }).replace(/[\u1000-\uFFFF]/g, function(ch) {
              return "\\u" + hex(ch);
            });
          };
          return {
            prolog: extract(txt, b, o - b),
            token: extract(txt, o, 1),
            epilog: extract(txt, o + 1, e - (o + 1))
          };
        };
        PEGUtil.parse = function(parser, txt, options) {
          if ((typeof parser === 'undefined' ? 'undefined' : $traceurRuntime.typeof(parser)) !== "object")
            throw new Error("invalid parser object (not an object)");
          if (typeof parser.parse !== "function")
            throw new Error("invalid parser object (no \"parse\" function)");
          if (typeof txt !== "string")
            throw new Error("invalid input text (not a string)");
          if (typeof options !== "undefined" && (typeof options === 'undefined' ? 'undefined' : $traceurRuntime.typeof(options)) !== "object")
            throw new Error("invalid options (not an object)");
          if (typeof options === "undefined")
            options = {};
          var result = {
            ast: null,
            error: null
          };
          try {
            var makeAST;
            if (typeof options.makeAST === "function")
              makeAST = options.makeAST;
            else {
              makeAST = function(line, column, offset, args) {
                return {
                  line: line,
                  column: column,
                  offset: offset,
                  args: args
                };
              };
            }
            var opts = {util: {
                makeUnroll: PEGUtil.makeUnroll,
                makeAST: PEGUtil.makeAST,
                __makeAST: makeAST
              }};
            if (typeof options.startRule === "string")
              opts.startRule = options.startRule;
            result.ast = parser.parse(txt, opts);
            result.error = null;
          } catch (e) {
            result.ast = null;
            var definedOrElse = function(value, fallback) {
              return (typeof value !== "undefined" ? value : fallback);
            };
            result.error = {
              line: definedOrElse(e.line, 0),
              column: definedOrElse(e.column, 0),
              message: e.message,
              found: definedOrElse(e.found, ""),
              expected: definedOrElse(e.expected, ""),
              location: excerpt(txt, definedOrElse(e.offset, 0))
            };
          }
          return result;
        };
        PEGUtil.errorMessage = function(e, noFinalNewline) {
          var l = e.location;
          var prefix1 = "line " + e.line + " (column " + e.column + "): ";
          var prefix2 = "";
          for (var i = 0; i < prefix1.length + l.prolog.length; i++)
            prefix2 += "-";
          var msg = prefix1 + l.prolog + l.token + l.epilog + "\n" + prefix2 + "^" + "\n" + e.message + (noFinalNewline ? "" : "\n");
          return msg;
        };
        return PEGUtil;
      }));
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}],
  46: [function(require, module, exports) {
    var util = require('util');
    var tokenize = function(str, re, parseDelim, instance) {
      var tokens = [];
      var match,
          content,
          lastIndex = 0;
      while (match = re.exec(str)) {
        content = str.slice(lastIndex, re.lastIndex - match[0].length);
        if (content.length) {
          tokens.push(content);
        }
        if (parseDelim) {
          var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
          if (typeof parsed != 'undefined') {
            if (parsed.specifier === '%') {
              tokens.push('%');
            } else {
              tokens.push(parsed);
            }
          }
        }
        lastIndex = re.lastIndex;
      }
      content = str.slice(lastIndex);
      if (content.length) {
        tokens.push(content);
      }
      return tokens;
    };
    var Formatter = function(format) {
      var tokens = [];
      this._mapped = false;
      this._format = format;
      this._tokens = tokenize(format, this._re, this._parseDelim, this);
    };
    Formatter.prototype._re = /\%(?:\(([\w_]+)\)|([1-9]\d*)\$)?([0 +\-\#]*)(\*|\d+)?(\.)?(\*|\d+)?[hlL]?([\%bscdeEfFgGioOuxX])/g;
    Formatter.prototype._parseDelim = function(mapping, intmapping, flags, minWidth, period, precision, specifier) {
      if (mapping) {
        this._mapped = true;
      }
      return {
        mapping: mapping,
        intmapping: intmapping,
        flags: flags,
        _minWidth: minWidth,
        period: period,
        _precision: precision,
        specifier: specifier
      };
    };
    Formatter.prototype._specifiers = {
      b: {
        base: 2,
        isInt: true
      },
      o: {
        base: 8,
        isInt: true
      },
      x: {
        base: 16,
        isInt: true
      },
      X: {
        extend: ['x'],
        toUpper: true
      },
      d: {
        base: 10,
        isInt: true
      },
      i: {extend: ['d']},
      u: {
        extend: ['d'],
        isUnsigned: true
      },
      c: {setArg: function(token) {
          if (!isNaN(token.arg)) {
            var num = parseInt(token.arg);
            if (num < 0 || num > 127) {
              throw new Error('invalid character code passed to %c in printf');
            }
            token.arg = isNaN(num) ? '' + num : String.fromCharCode(num);
          }
        }},
      s: {setMaxWidth: function(token) {
          token.maxWidth = (token.period == '.') ? token.precision : -1;
        }},
      e: {
        isDouble: true,
        doubleNotation: 'e'
      },
      E: {
        extend: ['e'],
        toUpper: true
      },
      f: {
        isDouble: true,
        doubleNotation: 'f'
      },
      F: {extend: ['f']},
      g: {
        isDouble: true,
        doubleNotation: 'g'
      },
      G: {
        extend: ['g'],
        toUpper: true
      },
      O: {isObject: true}
    };
    Formatter.prototype.format = function(filler) {
      if (this._mapped && (typeof filler === 'undefined' ? 'undefined' : $traceurRuntime.typeof(filler)) != 'object') {
        throw new Error('format requires a mapping');
      }
      var str = '';
      var position = 0;
      for (var i = 0,
          token = void 0; i < this._tokens.length; i++) {
        token = this._tokens[i];
        if (typeof token == 'string') {
          str += token;
        } else {
          if (this._mapped) {
            if (typeof filler[token.mapping] == 'undefined') {
              throw new Error('missing key ' + token.mapping);
            }
            token.arg = filler[token.mapping];
          } else {
            if (token.intmapping) {
              position = parseInt(token.intmapping) - 1;
            }
            if (position >= arguments.length) {
              throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
            }
            token.arg = arguments[position++];
          }
          if (!token.compiled) {
            token.compiled = true;
            token.sign = '';
            token.zeroPad = false;
            token.rightJustify = false;
            token.alternative = false;
            var flags = {};
            for (var fi = token.flags.length; fi--; ) {
              var flag = token.flags.charAt(fi);
              flags[flag] = true;
              switch (flag) {
                case ' ':
                  token.sign = ' ';
                  break;
                case '+':
                  token.sign = '+';
                  break;
                case '0':
                  token.zeroPad = (flags['-']) ? false : true;
                  break;
                case '-':
                  token.rightJustify = true;
                  token.zeroPad = false;
                  break;
                case '#':
                  token.alternative = true;
                  break;
                default:
                  throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
              }
            }
            token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
            token.maxWidth = -1;
            token.toUpper = false;
            token.isUnsigned = false;
            token.isInt = false;
            token.isDouble = false;
            token.isObject = false;
            token.precision = 1;
            if (token.period == '.') {
              if (token._precision) {
                token.precision = parseInt(token._precision);
              } else {
                token.precision = 0;
              }
            }
            var mixins = this._specifiers[token.specifier];
            if (typeof mixins == 'undefined') {
              throw new Error('unexpected specifier \'' + token.specifier + '\'');
            }
            if (mixins.extend) {
              var s = this._specifiers[mixins.extend];
              for (var k in s) {
                mixins[k] = s[k];
              }
              delete mixins.extend;
            }
            for (var l in mixins) {
              token[l] = mixins[l];
            }
          }
          if (typeof token.setArg == 'function') {
            token.setArg(token);
          }
          if (typeof token.setMaxWidth == 'function') {
            token.setMaxWidth(token);
          }
          if (token._minWidth == '*') {
            if (this._mapped) {
              throw new Error('* width not supported in mapped formats');
            }
            token.minWidth = parseInt(arguments[position++]);
            if (isNaN(token.minWidth)) {
              throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
            }
            if (token.minWidth < 0) {
              token.rightJustify = true;
              token.minWidth = -token.minWidth;
            }
          }
          if (token._precision == '*' && token.period == '.') {
            if (this._mapped) {
              throw new Error('* precision not supported in mapped formats');
            }
            token.precision = parseInt(arguments[position++]);
            if (isNaN(token.precision)) {
              throw Error('the argument for * precision at position ' + position + ' is not a number in ' + this._format);
            }
            if (token.precision < 0) {
              token.precision = 1;
              token.period = '';
            }
          }
          if (token.isInt) {
            if (token.period == '.') {
              token.zeroPad = false;
            }
            this.formatInt(token);
          } else if (token.isDouble) {
            if (token.period != '.') {
              token.precision = 6;
            }
            this.formatDouble(token);
          } else if (token.isObject) {
            this.formatObject(token);
          }
          this.fitField(token);
          str += '' + token.arg;
        }
      }
      return str;
    };
    Formatter.prototype._zeros10 = '0000000000';
    Formatter.prototype._spaces10 = '          ';
    Formatter.prototype.formatInt = function(token) {
      var i = parseInt(token.arg);
      if (!isFinite(i)) {
        if (typeof token.arg != 'number') {
          throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
        }
        i = 0;
      }
      if (i < 0 && (token.isUnsigned || token.base != 10)) {
        i = 0xffffffff + i + 1;
      }
      if (i < 0) {
        token.arg = (-i).toString(token.base);
        this.zeroPad(token);
        token.arg = '-' + token.arg;
      } else {
        token.arg = i.toString(token.base);
        if (!i && !token.precision) {
          token.arg = '';
        } else {
          this.zeroPad(token);
        }
        if (token.sign) {
          token.arg = token.sign + token.arg;
        }
      }
      if (token.base == 16) {
        if (token.alternative) {
          token.arg = '0x' + token.arg;
        }
        token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
      }
      if (token.base == 8) {
        if (token.alternative && token.arg.charAt(0) != '0') {
          token.arg = '0' + token.arg;
        }
      }
    };
    Formatter.prototype.formatDouble = function(token) {
      var f = parseFloat(token.arg);
      if (!isFinite(f)) {
        if (typeof token.arg != 'number') {
          throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
        }
        f = 0;
      }
      switch (token.doubleNotation) {
        case 'e':
          {
            token.arg = f.toExponential(token.precision);
            break;
          }
        case 'f':
          {
            token.arg = f.toFixed(token.precision);
            break;
          }
        case 'g':
          {
            if (Math.abs(f) < 0.0001) {
              token.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);
            } else {
              token.arg = f.toPrecision(token.precision);
            }
            if (!token.alternative) {
              token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
              token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/, '');
            }
            break;
          }
        default:
          throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
      }
      token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');
      if (token.alternative) {
        token.arg = token.arg.replace(/^(\d+)$/, '$1.');
        token.arg = token.arg.replace(/^(\d+)e/, '$1.e');
      }
      if (f >= 0 && token.sign) {
        token.arg = token.sign + token.arg;
      }
      token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
    };
    Formatter.prototype.formatObject = function(token) {
      var precision = (token.period === '.') ? token.precision : null;
      token.arg = util.inspect(token.arg, !token.alternative, precision);
    };
    Formatter.prototype.zeroPad = function(token, length) {
      length = (arguments.length == 2) ? length : token.precision;
      var negative = false;
      if (typeof token.arg != "string") {
        token.arg = "" + token.arg;
      }
      if (token.arg.substr(0, 1) === '-') {
        negative = true;
        token.arg = token.arg.substr(1);
      }
      var tenless = length - 10;
      while (token.arg.length < tenless) {
        token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
      }
      var pad = length - token.arg.length;
      token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
      if (negative)
        token.arg = '-' + token.arg;
    };
    Formatter.prototype.fitField = function(token) {
      if (token.maxWidth >= 0 && token.arg.length > token.maxWidth) {
        return token.arg.substring(0, token.maxWidth);
      }
      if (token.zeroPad) {
        this.zeroPad(token, token.minWidth);
        return;
      }
      this.spacePad(token);
    };
    Formatter.prototype.spacePad = function(token, length) {
      length = (arguments.length == 2) ? length : token.minWidth;
      if (typeof token.arg != 'string') {
        token.arg = '' + token.arg;
      }
      var tenless = length - 10;
      while (token.arg.length < tenless) {
        token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
      }
      var pad = length - token.arg.length;
      token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;
    };
    module.exports = function() {
      var args = Array.prototype.slice.call(arguments),
          stream,
          format;
      if (args[0] instanceof require('stream').Stream) {
        stream = args.shift();
      }
      format = args.shift();
      var formatter = new Formatter(format);
      var string = formatter.format.apply(formatter, args);
      if (stream) {
        stream.write(string);
      } else {
        return string;
      }
    };
    module.exports.Formatter = Formatter;
  }, {
    "stream": 41,
    "util": 44
  }]
}, {}, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]);
